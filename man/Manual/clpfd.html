<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.58 Reference Manual: Section A.7</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="clpclp_distinct.html">
<LINK REL=next HREF="clpqr.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="clpclp_distinct.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="clpqr.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:A.7"><SPAN class="sec-nr">A.7</SPAN> <SPAN class="sec-title">clpfd.pl 
-- Constraint Logic Programming over Finite Domains</SPAN></A></H2>

<P><A NAME="sec:clpfd"></A>

<DL>
<DT><B>author</B><DD> Markus Triska
</DL>

<P>Constraint programming is a declarative formalism that lets you 
describe conditions a solution must satisfy. This library provides 
CLP(FD), Constraint Logic Programming over Finite Domains. It can be 
used to model and solve various combinatorial problems such as planning, 
scheduling and allocation tasks.

<P>Most predicates of this library are finite domain <I>constraints</I>, 
which are relations over integers. They generalise arithmetic evaluation 
of integer expressions in that propagation can proceed in all 
directions. This library also provides <I>enumeration</I> <I>predicates</I>, 
which let you systematically search for solutions on variables whose 
domains have become finite. A finite domain <I>expression</I> is one of:
<BLOCKQUOTE>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD>an integer</TD><TD>Given value </TD></TR>
<TR VALIGN=top><TD>a variable</TD><TD>Unknown value </TD></TR>
<TR VALIGN=top><TD>-Expr</TD><TD>Unary minus </TD></TR>
<TR VALIGN=top><TD>Expr + Expr</TD><TD>Addition </TD></TR>
<TR VALIGN=top><TD>Expr * Expr</TD><TD>Multiplication </TD></TR>
<TR VALIGN=top><TD>Expr - Expr</TD><TD>Subtraction </TD></TR>
<TR VALIGN=top><TD>min(Expr,Expr)</TD><TD>Minimum of two expressions </TD></TR>
<TR VALIGN=top><TD>max(Expr,Expr)</TD><TD>Maximum of two expressions </TD></TR>
<TR VALIGN=top><TD>Expr mod Expr</TD><TD>Remainder of integer division </TD></TR>
<TR VALIGN=top><TD>abs(Expr)</TD><TD>Absolute value </TD></TR>
<TR VALIGN=top><TD>Expr / Expr</TD><TD>Integer division </TD></TR>
</TABLE>

</BLOCKQUOTE>

<P>The most important finite domain constraints are:
<BLOCKQUOTE>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD>Expr1 <CODE>#&gt;=</CODE> Expr2</TD><TD>Expr1 is 
larger than or equal to Expr2 </TD></TR>
<TR VALIGN=top><TD>Expr1 <CODE>#=&lt;</CODE> Expr2</TD><TD>Expr1 is 
smaller than or equal to Expr2 </TD></TR>
<TR VALIGN=top><TD>Expr1 <CODE>#=</CODE> Expr2</TD><TD>Expr1 equals 
Expr2 </TD></TR>
<TR VALIGN=top><TD>Expr1 <CODE>#\=</CODE> Expr2</TD><TD>Expr1 is not 
equal to Expr2 </TD></TR>
<TR VALIGN=top><TD>Expr1 <CODE>#&gt;</CODE> Expr2</TD><TD>Expr1 is 
strictly larger than Expr2 </TD></TR>
<TR VALIGN=top><TD>Expr1 <CODE>#&lt;</CODE> Expr2</TD><TD>Expr1 is 
strictly smaller than Expr2 </TD></TR>
</TABLE>

</BLOCKQUOTE>

<P>The constraints <A class="pred" href="clpfd.html#in/2">in/2</A>, <A class="pred" href="clpfd.html##=/2">#=/2</A>, <A class="pred" href="clpfd.html##\=/2">#\=/2</A>, <A class="pred" href="clpfd.html##</2">#&lt;/2</A>, <A class="pred" href="clpfd.html##>/2">#&gt;/2</A>, <A class="pred" href="clpfd.html##=</2">#=&lt;/2</A>, 
and <A class="pred" href="clpfd.html##>=/2">#&gt;=/2</A> can be
<I>reified</I>, which means reflecting their truth values into Boolean 
values represented by the integers 0 and 1. Let P and Q denote reifiable 
constraints or Boolean variables, then:
<BLOCKQUOTE>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><CODE>#\</CODE> Q</TD><TD>True iff Q is false </TD></TR>
<TR VALIGN=top><TD>P <CODE>#\/</CODE> Q</TD><TD>True iff either P or Q </TD></TR>
<TR VALIGN=top><TD>P <CODE>#/\</CODE> Q</TD><TD>True iff both P and Q </TD></TR>
<TR VALIGN=top><TD>P <CODE>#&lt;==&gt;</CODE> Q</TD><TD>True iff P and Q 
are equivalent </TD></TR>
<TR VALIGN=top><TD>P <CODE>#==&gt;</CODE> Q</TD><TD>True iff P implies Q </TD></TR>
<TR VALIGN=top><TD>P <CODE>#&lt;==</CODE> Q</TD><TD>True iff Q implies P </TD></TR>
</TABLE>

</BLOCKQUOTE>

<P>The constraints of this table are reifiable as well. If a variable 
occurs at the place of a constraint that is being reified, it is 
implicitly constrained to the Boolean values 0 and 1. Therefore, the 
following queries all fail: <CODE>?-</CODE> <CODE>#\</CODE> 2., <CODE>?-</CODE> <CODE>#\</CODE> <CODE>#\</CODE> 
2. etc.

<P>A common usage of this library is to first post the desired 
constraints among the variables of a model, and then to use enumeration 
predicates to search for solutions. As an example of a constraint 
satisfaction problem, consider the cryptoarithmetic puzzle SEND + MORE = 
MONEY, where different letters denote distinct integers between 0 and 9. 
It can be modeled in CLP(FD) as follows:

<PRE class="code">
:- use_module(library(clpfd)).

puzzle([S,E,N,D] + [M,O,R,E] = [M,O,N,E,Y]) :-
        Vars = [S,E,N,D,M,O,R,Y],
        Vars ins 0..9,
        all_different(Vars),
                  S*1000 + E*100 + N*10 + D +
                  M*1000 + O*100 + R*10 + E #=
        M*10000 + O*1000 + N*100 + E*10 + Y,
        M #\= 0, S #\= 0.
</PRE>

<P>Sample query and its result:

<PRE class="code">
?- puzzle(As+Bs=Cs).
As = [9, _G10107, _G10110, _G10113],
Bs = [1, 0, _G10128, _G10107],
Cs = [1, 0, _G10110, _G10107, _G10152],
_G10107 in 4..7,
1000*9+91*_G10107+ -90*_G10110+_G10113+ -9000*1+ -900*0+10*_G10128+ -1*_G10152#=0,
all_different([_G10107, _G10110, _G10113, _G10128, _G10152, 0, 1, 9]),
_G10110 in 5..8,
_G10113 in 2..8,
_G10128 in 2..8,
_G10152 in 2..8.
</PRE>

<P>Here, the constraint solver has deduced more stringent bounds for all 
variables. Keeping the modeling part separate from the search allows to 
view these residual goals, observe termination and determinism 
properties of the modeling part in isolation from the search, and to 
more easily experiment with different search strategies. Labeling can 
then be used to search for solutions:

<PRE class="code">
?- puzzle(As+Bs=Cs), label(As).
As = [9, 5, 6, 7],
Bs = [1, 0, 8, 5],
Cs = [1, 0, 6, 5, 2] ;
false.
</PRE>

<P>In this case, it suffices to label a subset of variables to find the 
puzzle's unique solution, since the constraint solver is strong enough 
to reduce the domains of remaining variables to singleton sets. In 
general though, it is necessary to label all variables to obtain ground 
solutions.

<P>It is perfectly reasonable to use CLP(FD) constraints instead of 
ordinary integer arithmetic with <A class="pred" href="arith.html#is/2">is/2</A>, <A class="pred" href="arith.html#>/2">&gt;/2</A> 
etc. For example:

<PRE class="code">
:- use_module(library(clpfd)).

fac(0, 1).
fac(N, F) :- N #&gt; 0, N1 #= N - 1, F #= N * F1, fac(N1, F1).
</PRE>

<P>This predicate can be used in all directions. For example:

<PRE class="code">
?- fac(47, F).
F = 258623241511168180642964355153611979969197632389120000000000 ;
false.

?- fac(N, 1).
N = 0 ;
N = 1 ;
false.

?- fac(N, 3).
false.
</PRE>

<P>To make the predicate terminate if any argument is instantiated, add 
the (implied) constraint F <CODE>#\=</CODE> 0 before the recursive call. 
Otherwise, the query fac(N, 0) is the only non-terminating case of this 
kind.

<P>This library uses <A class="pred" href="consulting.html#goal_expansion/2">goal_expansion/2</A> 
to rewrite constraints at compilation time. The expansion's aim is to 
transparently bring the performance of CLP(FD) constraints close to that 
of conventional arithmetic predicates (<A class="pred" href="arith.html#</2">&lt;/2</A>, <A class="pred" href="arith.html#=:=/2">=:=/2</A>, <A class="pred" href="arith.html#is/2">is/2</A> 
etc.) when the constraints are used in modes that can also be handled by 
built-in arithmetic. To disable the expansion, set the flag 
clpfd_goal_expansion to false.

<P>Use <A class="pred" href="coroutining.html#call_residue_vars/2">call_residue_vars/2</A> 
and <A class="pred" href="attvar.html#copy_term/3">copy_term/3</A> to 
inspect residual goals and the constraints in which a variable is 
involved. This library also provides <I>reflection</I> predicates (like <A class="pred" href="clpfd.html#fd_dom/2">fd_dom/2</A>, <A class="pred" href="clpfd.html#fd_size/2">fd_size/2</A> 
etc.) with which you can inspect a variable's current domain. These 
predicates can be useful if you want to implement your own labeling 
strategies.

<P>You can also define custom constraints. The mechanism to do this is 
not yet finalised, and we welcome suggestions and descriptions of use 
cases that are important to you. As an example of how it can be done 
currently, let us define a new custom constraint "oneground(X,Y,Z)", 
where Z shall be 1 if at least one of X and Y is instantiated:

<PRE class="code">
:- use_module(library(clpfd)).

:- multifile clpfd:run_propagator/2.

oneground(X, Y, Z) :-
        clpfd:make_propagator(oneground(X, Y, Z), Prop),
        clpfd:init_propagator(X, Prop),
        clpfd:init_propagator(Y, Prop),
        clpfd:trigger_once(Prop).

clpfd:run_propagator(oneground(X, Y, Z), MState) :-
        (   integer(X) -&gt; clpfd:kill(MState), Z = 1
        ;   integer(Y) -&gt; clpfd:kill(MState), Z = 1
        ;   true
        ).
</PRE>

<P>First, clpfd:<SPAN class="pred-ext">make_propagator/2</SPAN> is used 
to transform a user-defined representation of the new constraint to an 
internal form. With clpfd:<SPAN class="pred-ext">init_propagator/2</SPAN>, 
this internal form is then attached to X and Y. From now on, the 
propagator will be invoked whenever the domains of X or Y are changed. 
Then, clpfd:<SPAN class="pred-ext">trigger_once/1</SPAN> is used to give 
the propagator its first chance for propagation even though the 
variables' domains have not yet changed. Finally, clpfd:<SPAN class="pred-ext">run_propagator/2</SPAN> 
is extended to define the actual propagator. As explained, this 
predicate is automatically called by the constraint solver. The first 
argument is the user-defined representation of the constraint as used in 
clpfd:<SPAN class="pred-ext">make_propagator/2</SPAN>, and the second 
argument is a mutable state that can be used to prevent further 
invocations of the propagator when the constraint has become entailed, 
by using clpfd:<SPAN class="pred-ext">kill/1</SPAN>. An example of using 
the new constraint:

<PRE class="code">
?- oneground(X, Y, Z), Y = 5.
Y = 5,
Z = 1,
X in inf..sup.
</PRE>

<DL>
<DT class="pubdef"><A NAME="in/2"><VAR>?Var</VAR> <STRONG>in</STRONG> <VAR>+Domain</VAR></A></DT>
<DD class="defbody">
<VAR>Var</VAR> is an element of <VAR>Domain</VAR>. <VAR>Domain</VAR> is 
one of:

<DL>
<DT><STRONG><VAR>Integer</VAR></STRONG></DT>
<DD class="defbody">
Singleton set consisting only of <I>Integer</I>.
</DD>
<DT><VAR><VAR>Lower</VAR></VAR> <STRONG>..</STRONG> <VAR><VAR>Upper</VAR></VAR></DT>
<DD class="defbody">
All integers <I>I</I> such that <I>Lower</I> <CODE>=&lt;</CODE> <I>I</I> <CODE>=&lt;</CODE> <I>Upper</I>.
<I>Lower</I> must be an integer or the atom <B>inf</B>, which denotes 
negative infinity. <I>Upper</I> must be an integer or the atom <B>sup</B>, 
which denotes positive infinity.
</DD>
<DT><VAR><VAR>Domain1</VAR></VAR> <STRONG><CODE>\/</CODE></STRONG> <VAR><VAR>Domain2</VAR></VAR></DT>
<DD class="defbody">
The union of Domain1 and Domain2.
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="ins/2"><VAR>+Vars</VAR> <STRONG>ins</STRONG> <VAR>+Domain</VAR></A></DT>
<DD class="defbody">
The variables in the list <VAR>Vars</VAR> are elements of <VAR>Domain</VAR>.</DD>
<DT class="pubdef"><A NAME="indomain/1"><STRONG>indomain</STRONG>(<VAR>?Var</VAR>)</A></DT>
<DD class="defbody">
Bind <VAR>Var</VAR> to all feasible values of its domain on 
backtracking. The domain of <VAR>Var</VAR> must be finite.</DD>
<DT class="pubdef"><A NAME="label/1"><STRONG>label</STRONG>(<VAR>+Vars</VAR>)</A></DT>
<DD class="defbody">
Equivalent to labeling([], <VAR>Vars</VAR>).</DD>
<DT class="pubdef"><A NAME="labeling/2"><STRONG>labeling</STRONG>(<VAR>+Options, 
+Vars</VAR>)</A></DT>
<DD class="defbody">
Labeling means systematically trying out values for the finite domain 
variables <VAR>Vars</VAR> until all of them are ground. The domain of 
each variable in <VAR>Vars</VAR> must be finite. <VAR>Options</VAR> is a 
list of options that let you exhibit some control over the search 
process. Several categories of options exist:

<P>The variable selection strategy lets you specify which variable of
<VAR>Vars</VAR> should be labeled next and is one of:

<DL>
<DT><STRONG>leftmost</STRONG></DT>
<DD class="defbody">
Label the variables in the order they occur in <VAR>Vars</VAR>. This is 
the default.
</DD>
<DT><STRONG>ff</STRONG></DT>
<DD class="defbody">
<I>First fail</I>. Label the leftmost variable with smallest domain 
next, in order to detect infeasibility early. This is often a good 
strategy.
</DD>
<DT><STRONG>ffc</STRONG></DT>
<DD class="defbody">
Of the variables with smallest domains, the leftmost one participating 
in most constraints is labeled next.
</DD>
<DT><STRONG>min</STRONG></DT>
<DD class="defbody">
Label the leftmost variable whose lower bound is the lowest next.
</DD>
<DT><STRONG>max</STRONG></DT>
<DD class="defbody">
Label the leftmost variable whose upper bound is the highest next.
</DD>
</DL>

<P>The value order is one of:

<DL>
<DT><STRONG>up</STRONG></DT>
<DD class="defbody">
Try the elements of the chosen variable's domain in ascending order. 
This is the default.
</DD>
<DT><STRONG>down</STRONG></DT>
<DD class="defbody">
Try the domain elements in descending order.
</DD>
</DL>

<P>The branching strategy is one of:

<DL>
<DT><STRONG>step</STRONG></DT>
<DD class="defbody">
For each variable X, a choice is made between X = V and X <CODE>#\=</CODE> 
V, where V is determined by the value ordering options. This is the 
default.
</DD>
<DT><STRONG>enum</STRONG></DT>
<DD class="defbody">
For each variable X, a choice is made between X = V_1, X = V_2 etc., for 
all values V_i of the domain of X. The order is determined by the value 
ordering options.
</DD>
<DT><STRONG>bisect</STRONG></DT>
<DD class="defbody">
For each variable X, a choice is made between X <CODE>#=&lt;</CODE> M 
and X <CODE>#&gt;</CODE> M, where M is the midpoint of the domain of X.
</DD>
</DL>

<P>At most one option of each category can be specified, and an option 
must not occur repeatedly.

<P>The order of solutions can be influenced with:

<DL>
<DT><STRONG>min</STRONG>(<VAR>Expr</VAR>)</DT>
<DD class="defbody">
</DD>
<DT><STRONG>max</STRONG>(<VAR>Expr</VAR>)</DT>
<DD class="defbody">
</DD>
</DL>

<P>This generates solutions in ascending/descending order with respect 
to the evaluation of the arithmetic expression Expr. Labeling <VAR>Vars</VAR> 
must make Expr ground. If several such options are specified, they are 
interpreted from left to right, e.g.:

<PRE class="code">
?- [X,Y] ins 10..20, labeling([max(X),min(Y)],[X,Y]).
</PRE>

<P>This generates solutions in descending order of X, and for each 
binding of X, solutions are generated in ascending order of Y. To obtain 
the incomplete behaviour that other systems exhibit with 
"maximize(Expr)" and "minimize(Expr)", use <A class="pred" href="metacall.html#once/1">once/1</A>, 
e.g.:

<PRE class="code">
once(labeling([max(Expr)], Vars))
</PRE>

<P>Labeling is always complete, always terminates, and yields no 
redundant solutions.</DD>
<DT class="pubdef"><A NAME="all_different/1"><STRONG>all_different</STRONG>(<VAR>+Vars</VAR>)</A></DT>
<DD class="defbody">
<VAR>Vars</VAR> are pairwise distinct.</DD>
<DT class="pubdef"><A NAME="sum/3"><STRONG>sum</STRONG>(<VAR>+Vars, 
+Rel, +Expr</VAR>)</A></DT>
<DD class="defbody">
The sum of elements of the list <VAR>Vars</VAR> is in relation <VAR>Rel</VAR> 
to <VAR>Expr</VAR>. For example:

<PRE class="code">
?- [A,B,C] ins 0..sup, sum([A,B,C], #=, 100).
A in 0..100,
A+B+C#=100,
B in 0..100,
C in 0..100.
</PRE>

</DD>
<DT class="pubdef"><A NAME="#>=/2"><VAR>?X</VAR> <STRONG>#&gt;=</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> is greater than or equal to <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#=</2"><VAR>?X</VAR> <STRONG>#=&lt;</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> is less than or equal to <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#=/2"><VAR>?X</VAR> <STRONG>#=</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> equals <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#\=/2"><VAR>?X</VAR> <STRONG>#\=</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> is not <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#>/2"><VAR>?X</VAR> <STRONG>#&gt;</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> is greater than <VAR>Y</VAR>.</DD>
<DT class="pubdef"><A NAME="#</2"><VAR>?X</VAR> <STRONG>#&lt;</STRONG> <VAR>?Y</VAR></A></DT>
<DD class="defbody">
<VAR>X</VAR> is less than <VAR>Y</VAR>. In addition to its regular use 
in problems that require it, this constraint can also be useful to 
eliminate uninteresting symmetries from a problem. For example, all 
possible matches between pairs built from four players in total:

<PRE class="code">
?- Vs = [A,B,C,D], Vs ins 1..4, all_different(Vs), A #&lt; B, C #&lt; D, A #&lt; C,
   findall(pair(A,B)-pair(C,D), label(Vs), Ms).
Ms = [pair(1, 2)-pair(3, 4), pair(1, 3)-pair(2, 4), pair(1, 4)-pair(2, 3)]
</PRE>

</DD>
<DT class="pubdef"><A NAME="#\/1"><STRONG>#\</STRONG> <VAR>+Q</VAR></A></DT>
<DD class="defbody">
The reifiable constraint <VAR>Q</VAR> does <I>not</I> hold. For example, 
to obtain the complement of a domain:

<PRE class="code">
?- #\ X in -3..0\/10..80.
X in inf.. -4\/1..9\/81..sup.
</PRE>

</DD>
<DT class="pubdef"><A NAME="#<==>/2"><VAR>?P</VAR> <STRONG>#&lt;==&gt;</STRONG> <VAR>?Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> and <VAR>Q</VAR> are equivalent. For example:

<PRE class="code">
?- X #= 4 #&lt;==&gt; B, X #\= 4.
B = 0,
X in inf..3\/5..sup.
</PRE>

</DD>
<DT class="pubdef"><A NAME="#==>/2"><VAR>?P</VAR> <STRONG>#==&gt;</STRONG> <VAR>?Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> implies <VAR>Q</VAR>.</DD>
<DT class="pubdef"><A NAME="#<==/2"><VAR>?P</VAR> <STRONG>#&lt;==</STRONG> <VAR>?Q</VAR></A></DT>
<DD class="defbody">
<VAR>Q</VAR> implies <VAR>P</VAR>.</DD>
<DT class="pubdef"><A NAME="#/\/2"><VAR>?P</VAR> <STRONG>#/\</STRONG> <VAR>?Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> and <VAR>Q</VAR> hold.</DD>
<DT class="pubdef"><A NAME="#\//2"><VAR>?P</VAR> <STRONG>#\/</STRONG> <VAR>?Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> or <VAR>Q</VAR> holds. For example, the sum of natural 
numbers below 1000 that are multiples of 3 or 5:

<PRE class="code">
?- N mod 3 #= 0 #\/ N mod 5 #= 0, N in 0..999, findall(N, indomain(N), Ns), sum(Ns, #=, Sum).
Ns = [0, 3, 5, 6, 9, 10, 12, 15, 18|...],
Sum = 233168
</PRE>

</DD>
<DT class="pubdef"><A NAME="lex_chain/1"><STRONG>lex_chain</STRONG>(<VAR>+Lists</VAR>)</A></DT>
<DD class="defbody">
<VAR>Lists</VAR> are lexicographically non-decreasing.</DD>
<DT class="pubdef"><A NAME="tuples_in/2"><STRONG>tuples_in</STRONG>(<VAR>+Tuples, 
+Relation</VAR>)</A></DT>
<DD class="defbody">
<VAR>Relation</VAR> must be a list of lists of integers. The elements of 
the list <VAR>Tuples</VAR> are constrained to be elements of <VAR>Relation</VAR>. 
Arbitrary finite relations, such as compatibility tables, can be modeled 
in this way. For example, if 1 is compatible with 2 and 5, and 4 is 
compatible with 0 and 3:

<PRE class="code">
?- tuples_in([[X,Y]], [[1,2],[1,5],[4,0],[4,3]]), X = 4.
X = 4,
Y in 0\/3.
</PRE>

<P>As another example, consider a train schedule represented as a list 
of quadruples, denoting departure and arrival places and times for each 
train. In the following program, Ps is a feasible journey of length 3 
from A to D via trains that are part of the given schedule.

<PRE class="code">
:- use_module(library(clpfd)).
 
trains([[1,2,0,1],[2,3,4,5],[2,3,0,1],[3,4,5,6],[3,4,2,3],[3,4,8,9]]).
 
threepath(A, D, Ps) :-
        Ps = [[A,B,_T0,T1],[B,C,T2,T3],[C,D,T4,_T5]],
        T2 #&gt; T1,
        T4 #&gt; T3,
        trains(Ts),
        tuples_in(Ps, Ts).
</PRE>

<P>In this example, the unique solution is found without labeling:

<PRE class="code">
?- threepath(1, 4, Ps).
Ps = [[1, 2, 0, 1], [2, 3, 4, 5], [3, 4, 8, 9]].
</PRE>

</DD>
<DT class="pubdef"><A NAME="all_distinct/1"><STRONG>all_distinct</STRONG>(<VAR>+Ls</VAR>)</A></DT>
<DD class="defbody">
Like <A class="pred" href="clpfd.html#all_different/1">all_different/1</A>, 
with stronger propagation.</DD>
<DT class="pubdef"><A NAME="serialized/2"><STRONG>serialized</STRONG>(<VAR>+Starts, 
+Durations</VAR>)</A></DT>
<DD class="defbody">
Constrain a set of intervals to a non-overlapping sequence.
<VAR>Starts</VAR> = [S_1,...,S_n], is a list of variables or integers,
<VAR>Durations</VAR> = [D_1,...,D_n] is a list of non-negative integers. 
Constrains <VAR>Starts</VAR> and <VAR>Durations</VAR> to denote a set of 
non-overlapping tasks, i.e.: S_i + D_i <CODE>=&lt;</CODE> S_j or S_j + 
D_j <CODE>=&lt;</CODE> S_i for all 1 <CODE>=&lt;</CODE> i <VAR>&lt;</VAR> 
j <CODE>=&lt;</CODE> n.

<DL>
<DT><B>See also</B><DD> Dorndorf et al. 2000, "Constraint Propagation 
Techniques for the Disjunctive Scheduling Problem"
</DL>

</DD>
<DT class="pubdef"><A NAME="fd_var/1"><STRONG>fd_var</STRONG>(<VAR>+Var</VAR>)</A></DT>
<DD class="defbody">
True iff <VAR>Var</VAR> is a CLP(FD) variable.</DD>
<DT class="pubdef"><A NAME="fd_inf/2"><STRONG>fd_inf</STRONG>(<VAR>+Var, 
-Inf</VAR>)</A></DT>
<DD class="defbody">
<VAR>Inf</VAR> is the infimum of the current domain of <VAR>Var</VAR>.</DD>
<DT class="pubdef"><A NAME="fd_sup/2"><STRONG>fd_sup</STRONG>(<VAR>+Var, 
-Sup</VAR>)</A></DT>
<DD class="defbody">
<VAR>Sup</VAR> is the supremum of the current domain of <VAR>Var</VAR>.</DD>
<DT class="pubdef"><A NAME="fd_size/2"><STRONG>fd_size</STRONG>(<VAR>+Var, 
-Size</VAR>)</A></DT>
<DD class="defbody">
<VAR>Size</VAR> is the number of elements of the current domain of <VAR>Var</VAR>, 
or the atom <B>sup</B> if the domain is unbounded.</DD>
<DT class="pubdef"><A NAME="fd_dom/2"><STRONG>fd_dom</STRONG>(<VAR>+Var, 
-Dom</VAR>)</A></DT>
<DD class="defbody">
<VAR>Dom</VAR> is the current domain (see <A class="pred" href="clpfd.html#in/2">in/2</A>) 
of <VAR>Var</VAR>. This predicate is useful if you want to reason about 
domains. It is not needed if you only want to display remaining domains; 
instead, separate your model from the search part and let the toplevel 
display this information via residual goals.
</DD>
</DL>

<P></BODY></HTML>