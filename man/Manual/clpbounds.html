<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.38 Reference Manual: Section A.13</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="url.html">
<LINK REL=next HREF="clpqr.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text: { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="url.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="clpqr.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:A.13"><SPAN class="sec-nr">A.13</SPAN> <SPAN class="sec-title">library( 
clp/bounds ): Integer Bounds Constraint Solver</SPAN></A></H2>

<A NAME="clp/bounds"></A>

<P>Author: <EM>Tom Schrijvers</EM>, K.U.Leuven

<P>The bounds solver is a rather simple integer constraint solver, 
implemented with attributed variables. Its syntax is a subset of the 
SICStus clp(FD) syntax. The <CODE>library(bounds)</CODE> library is <EM>not</EM> 
an <EM>autoload</EM> library and therefore it must be loaded explicitly 
before using it via:

<PRE class="code">
:- use_module(library(bounds)).
</PRE>

<H3><A NAME="sec:A.13.1"><SPAN class="sec-nr">A.13.1</SPAN> <SPAN class="sec-title">Constraints</SPAN></A></H3>

The following constraints are supported:

<DL>
<DT class="pubdef"><A NAME="in/2"><VAR>-Var</VAR> <STRONG>in</STRONG> <VAR>+Range</VAR></A></DT>
<DD class="defbody">
Varibale <VAR>Var</VAR> is restricted to be in range <VAR>Range</VAR>. A 
range is denoted by <TT>L..U</TT> where both <VAR>L</VAR> and <VAR>U</VAR> 
are integers.
</DD>
<DT class="pubdef"><A NAME="in/2"><VAR>-Vars</VAR> <STRONG>in</STRONG> <VAR>+Range</VAR></A></DT>
<DD class="defbody">
A list of variables <VAR>Vars</VAR> are restriced to be in range
<VAR>Range</VAR>.
</DD>
<DT class="pubdef"><A NAME="tuples_in/2"><STRONG>tuples_in</STRONG>(<VAR>+Tuples, 
+Extension</VAR>)</A></DT>
<DD class="defbody">
Where <VAR>Tuples</VAR> is a list of tuples (lists) of variables and 
integers, each of length&nbsp;<VAR>N</VAR>, and <VAR>Extension</VAR> is 
a list of tuples of integers, each of length&nbsp;<VAR>N</VAR>. Each 
tuple of
<VAR>Tuples</VAR> is constrained to be in the relation defined by <VAR>Extension</VAR>. 
See <A class="sec" href="clpbounds.html">section A.13.4</A> for an 
example.
</DD>
<DT class="pubdef"><A NAME="#>/2"><VAR>?Expr</VAR> <STRONG>#&gt;</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be greater than the 
right-hand expressions.
</DD>
<DT class="pubdef"><A NAME="#</2"><VAR>?Expr</VAR> <STRONG>#&lt;</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be smaller than the 
right-hand expressions.
</DD>
<DT class="pubdef"><A NAME="#>=/2"><VAR>?Expr</VAR> <STRONG>#&gt;=</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be greater than or equal to 
the right-hand expressions.
</DD>
<DT class="pubdef"><A NAME="#=</2"><VAR>?Expr</VAR> <STRONG>#=&lt;</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be smaller than or equal to 
the right-hand expressions.
</DD>
<DT class="pubdef"><A NAME="#=/2"><VAR>?Expr</VAR> <STRONG>#=</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be equal to the right-hand 
expressions.
</DD>
<DT class="pubdef"><A NAME="#\=/2"><VAR>?Expr</VAR> <STRONG>#\=</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be not equal to the 
right-hand expressions.
</DD>
<DT class="pubdef"><A NAME="sum/3"><STRONG>sum</STRONG>(<VAR>+Vars,+Op,?Value</VAR>)</A></DT>
<DD class="defbody">
Here <VAR>Vars</VAR> is a list of variables and integers,
<VAR>Op</VAR> is one of the binary constraint relation symbols above and <VAR>Value</VAR> 
is an integer or variable. It represents the constraint (<VAR>&Sigma;</VAR><VAR>Vars</VAR>) <VAR>Op</VAR> <VAR>Value</VAR>.
</DD>
<DT class="pubdef"><A NAME="lex_chain/1"><STRONG>lex_chain</STRONG>(<VAR>+VarsLists</VAR>)</A></DT>
<DD class="defbody">
The constraint enforces lexicographic ordering on the lists in the 
argument. The argument <VAR>VarsLists</VAR> is a list of lists of 
variables and integers. The current implementation was contributed by 
Markus Triska.
</DD>
<DT class="pubdef"><A NAME="all_different/1"><STRONG>all_different</STRONG>(<VAR>+Vars</VAR>)</A></DT>
<DD class="defbody">
Constrains all variabls in the list <VAR>Vars</VAR> to be pairwise not 
equal.
</DD>
<DT class="pubdef"><A NAME="indomain/1"><STRONG>indomain</STRONG>(<VAR>+Var</VAR>)</A></DT>
<DD class="defbody">
Unify variable <VAR>Var</VAR> with a value in its domain. Backtracks 
over all possible values from lowest to greatest. Contributed by Markus 
Triska.
</DD>
<DT class="pubdef"><A NAME="label/1"><STRONG>label</STRONG>(<VAR>+Vars</VAR>)</A></DT>
<DD class="defbody">
Equivalent to labeling([], Vars).
</DD>
<DT class="pubdef"><A NAME="labeling/2"><STRONG>labeling</STRONG>(<VAR>+Options, 
+Vars</VAR>)</A></DT>
<DD class="defbody">
All variables in the list <VAR>Vars</VAR> are assigned values from their 
respective domains such that no constraint on them is violated. <VAR>Options</VAR> 
is a list of options. One set of options lets you choose the variable 
selection strategy:

<DL>
<DT><STRONG>leftmost</STRONG></DT>
<DD class="defbody">
Label the variables in the order they occur in <VAR>Vars</VAR> from left 
to right. This is the default.</DD>
<DT><STRONG>ff</STRONG></DT>
<DD class="defbody">
Label the variable whose domain contains the smallest number of elements 
among the remaining variables next. This is called "first-fail". The 
intention here is twofold: First, to detect infeasibility early by 
always considering the variable most likely to cause failure; second, to 
give priority to variables that are close to running out of domain 
elements.</DD>
<DT><STRONG>min</STRONG></DT>
<DD class="defbody">
Label the variable whose lower bound is the lowest among the remaining 
variables next.</DD>
<DT><STRONG>max</STRONG></DT>
<DD class="defbody">
Label the variable whose upper bound is the highest among the remaining 
variables next.
</DD>
</DL>

<P>Another set of options lets you search for extrema:

<DL>
<DT><STRONG>min</STRONG>(<VAR>Expr</VAR>)</DT>
<DD class="defbody">
</DD>
<DT><STRONG>max</STRONG>(<VAR>Expr</VAR>)</DT>
<DD class="defbody">
Label the variables such that <VAR>Expr</VAR> assumes the 
smallest/highest possible value.
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="serialized/2"><STRONG>serialized</STRONG>(<VAR>+Starts,+Durations</VAR>)</A></DT>
<DD class="defbody">
<VAR>Starts</VAR> = <VAR>[S_1, ... ,S_n]</VAR> is a list of variables or 
integers, and <VAR>Durations</VAR> =
<VAR>[D_1, ... ,D_n]</VAR> is a list of non-negative integers.
<VAR>Starts</VAR> are constrained to denote the starting times of 
non-overlapping tasks, i.e., <VAR>S_i + D_i =&lt; S_j</VAR> or <VAR>S_j 
+ D_j =&lt; S_i</VAR> for all <VAR>1 =&lt; i &lt; j =&lt; n</VAR>.
</DD>
</DL>

<P>Here <VAR>Expr</VAR> can be one of

<DL>
<DT><B>integer</B></DT>
<DD>
Any integer.
</DD>
<DT><B>variable</B></DT>
<DD>
A variable.
</DD>
<DT class="pubdef"><A NAME="+/2"><VAR>?Expr</VAR> <STRONG>+</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The sum of two expressions.
</DD>
<DT class="pubdef"><A NAME="*/2"><VAR>?Expr</VAR> <STRONG>*</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The product of two expressions.
</DD>
<DT class="pubdef"><A NAME="-/2"><VAR>?Expr</VAR> <STRONG>-</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The difference of two expressions.
</DD>
<DT class="pubdef"><A NAME="max/2"><STRONG>max</STRONG>(<VAR>?Expr,?Expr</VAR>)</A></DT>
<DD class="defbody">
The maximum of two expressions.
</DD>
<DT class="pubdef"><A NAME="min/2"><STRONG>min</STRONG>(<VAR>?Expr,?Expr</VAR>)</A></DT>
<DD class="defbody">
The minimum of two expressions.
</DD>
<DT class="pubdef"><A NAME="mod/2"><VAR>?Expr</VAR> <STRONG>mod</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The first expression modulo the second expression.
</DD>
<DT class="pubdef"><A NAME="abs/1"><STRONG>abs</STRONG>(<VAR>?Expr</VAR>)</A></DT>
<DD class="defbody">
The absolute value of an expression.
</DD>
</DL>

<H3><A NAME="sec:A.13.2"><SPAN class="sec-nr">A.13.2</SPAN> <SPAN class="sec-title">Constraint 
Implication and Reified Constraints</SPAN></A></H3>

The following constraint implication predicates are available:

<DL>
<DT class="pubdef"><A NAME="#=>/2"><VAR>+P</VAR> <STRONG>#=&gt;</STRONG> <VAR>+Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> implies <VAR>Q</VAR>, where <VAR>P</VAR> and <VAR>Q</VAR> 
are reifyable constraints.
</DD>
<DT class="pubdef"><A NAME="#<=/2"><VAR>+Q</VAR> <STRONG>#&lt;=</STRONG> <VAR>+P</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> implies <VAR>Q</VAR>, where <VAR>P</VAR> and <VAR>Q</VAR> 
are reifyable constraints.
</DD>
<DT class="pubdef"><A NAME="#<=>/2"><VAR>+P</VAR> <STRONG>#&lt;=&gt;</STRONG> <VAR>+Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> and <VAR>Q</VAR> are equivalent, where <VAR>P</VAR> and <VAR>Q</VAR> 
are reifyable constraints.
</DD>
</DL>

<P>In addition, instead of being a reifyable constraint, either <VAR>P</VAR> 
or
<VAR>Q</VAR> can be a boolean variable that is the truth value of the 
corresponding constraint.

<P>The following constraints are reifyable: <A class="pred" href="clpbounds.html##=/2">#=/2</A>,
<A class="pred" href="clpbounds.html##\=/2">#\=/2</A>, <A class="pred" href="clpbounds.html##</2">#&lt;/2</A>, <A class="pred" href="clpbounds.html##>/2">#&gt;/2</A>, <A class="pred" href="clpbounds.html##=</2">#=&lt;/2</A>,
<A class="pred" href="clpbounds.html##>/2">#&gt;/2</A>.

<P>For example, to count the number of occurrences of a particular value 
in a list of constraint variables:
<UL>
<LI><I>Using constraint implication</I><BR>

<PRE class="code">
occurrences(List,Value,Count) :-
        occurrences(List,Value,0,Count).

occurrences([],_,Count,Count).
occurrences([X|Xs],Value,Acc,Count) :-
        X #= Value  #=&gt; NAcc #= Acc + 1,
        X #\= Value #=&gt; NAcc #= Acc,
        occurrences(Xs,Value,NAcc,Count).
</PRE>

<P>
<LI><I>Using reified constraints</I><BR>

<PRE class="code">
occurrences(List,Value,Count) :-
        occurrences(List,Value,0,Count).

occurrences([],_,Count,Count).
occurrences([X|Xs],Value,Acc,Count) :-
        X #= Value #=&gt; B,
        NAcc #= Acc + B,
        occurrences(Xs,Value,NAcc,Count).
</PRE>

<P>
</UL>

<H3><A NAME="sec:A.13.3"><SPAN class="sec-nr">A.13.3</SPAN> <SPAN class="sec-title">Example 
1: Send+More=Money</SPAN></A></H3>

The following is an implementation of the classic alphametics puzzle 
SEND + MORE = MONEY:

<PRE class="code">
:- use_module(library(bounds)).

send([[S,E,N,D], [M,O,R,E], [M,O,N,E,Y]])  :-
              Digits   =  [S,E,N,D,M,O,R,Y],
              Carries  =  [C1,C2,C3,C4],
              Digits  in  0..9,
              Carries in  0..1,

              M                #=              C4,
              O  +  10  *  C4  #=  M  +  S  +  C3,
              N  +  10  *  C3  #=  O  +  E  +  C2,
              E  +  10  *  C2  #=  R  +  N  +  C1,
              Y  +  10  *  C1  #=  E  +  D,

              M  #&gt;=  1,
              S  #&gt;=  1,
              all_different(Digits),
              label(Digits).
</PRE>

<H3><A NAME="sec:A.13.4"><SPAN class="sec-nr">A.13.4</SPAN> <SPAN class="sec-title">Example 
2: Using tuples_in for a train schedule</SPAN></A></H3>

<A NAME="sec:ex:tuplesin"></A>

<P>This example demonstrates <A NAME="idx:tuplesin2:1441"></A><A class="pred" href="clpbounds.html#tuples_in/2">tuples_in/2</A>. 
A train schedule is represented as a list&nbsp;<VAR>Ts</VAR> of 
quadruples, denoting departure and arrival places and times for each 
train. The <EM>path/3</EM> predicate given below constrains&nbsp;<VAR>Ps</VAR> 
to a feasible journey from&nbsp;<VAR>A</VAR> to&nbsp;<VAR>D</VAR> via 3&nbsp;trains 
that are part of the given schedule.

<PRE class="code">
:- use_module(library(bounds)).

schedule(Ts) :-
        Ts = [[1,2,0,1],[2,3,4,5],[2,3,0,1],[3,4,5,6],[3,4,2,3],[3,4,8,9]].

path(A, D, Ps) :-
        schedule(Ts),
        Ps = [[A,B,_T0,T1],[B,C,T2,T3],[C,D,T4,_T5]],
        tuples_in(Ps, Ts),
        T2 #&gt; T1,
        T4 #&gt; T3.
</PRE>

<P>An example query:

<PRE class="code">
?- path(1, 4, Ps), flatten(Ps, Vars), label(Vars).

Ps = [[1, 2, 0, 1], [2, 3, 4, 5], [3, 4, 8, 9]]
</PRE>

<H3><A NAME="sec:A.13.5"><SPAN class="sec-nr">A.13.5</SPAN> <SPAN class="sec-title">SICStus 
clp(FD) compatibility</SPAN></A></H3>

Apart from the limited syntax, the bounds solver differs in the 
following ways from the SICStus clp(FD) solver:

<P>
<UL>
<LI><I><TT>inf</TT> and <TT>sup</TT></I><BR>
The smallest lowerbound and greatest upperbound in bounds are
<TT>max_integer</TT> and <TT>min_integer + 1</TT>.
</UL>
</BODY></HTML>