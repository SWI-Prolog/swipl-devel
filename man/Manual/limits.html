<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.17 Reference Manual: Section 2.18</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="widechars.html">
<LINK REL=next HREF="IDE.html">
<style type="text/css"> 
dd.defbody 
{ margin-bottom: 1em; 
}

dt.pubdef 
{ background-color: #c5e1ff; 
}

pre.code 
{ margin-left: 1.5em; 
margin-right: 1.5em; 
border: 1px dotted; 
padding-top: 5px; 
padding-left: 5px; 
padding-bottom: 5px; 
background-color: #f8f8f8; 
}

div.navigate
{ text-align: center; 
background-color: #f0f0f0; 
border: 1px dotted; 
padding: 5px;
}
</style>
</HEAD>
<BODY BGCOLOR="white"><DIV class="navigate"><A HREF="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A HREF="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A HREF="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A HREF="widechars.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A HREF="IDE.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:2.18">2.18 System limits</A></H2>

<A NAME="sec:limits"></A>

<H3><A NAME="sec:2.18.1">2.18.1 Limits on memory areas</A></H3>

<A NAME="sec:memlimit"></A>

<P>SWI-Prolog has a number of memory areas which are only enlarged to a 
certain limit. The default sizes for these areas should suffice for most 
applications, but big applications may require larger ones. They are 
modified by command-line options. The table below shows these areas. The 
first column gives the option name to modify the size of the area. The 
option character is immediately followed by a number and optionally by a
<CODE>k</CODE> or <CODE>m</CODE>. With <CODE>k</CODE> or no unit 
indicator, the value is interpreted in Kbytes (1024 bytes), with <CODE>m</CODE>, 
the value is interpreted in Mbytes (<VAR>1024 &times; 1024</VAR> bytes).

<P>The local-, global- and trail-stack are limited to 128 Mbytes on 32 
bit processors, or more generally to <VAR>2 ** bits-per-long - 5</VAR> 
bytes.

<P>The PrologScript facility described in <A HREF="compilation.html">section 
2.10.2.1</A> provides a mechanism for specifying options with the 
load-file. On Windows the default stack-sizes are controlled using the 
Windows <A NAME="idx:registry:245">registry</A> on the key <CODE>HKEY_CURRENT_USER\Software\SWI\Prolog</CODE> 
using the names <CODE>localSize</CODE>, <CODE>globalSize</CODE> and <CODE>trailSize</CODE>. 
The value is a <CODE>DWORD</CODE> expressing the default stack size in 
Kbytes. A GUI for modifying these values is provided using the XPCE 
package. To use this, start the XPCE manual tools using <A NAME="idx:manpce0:246"></A><B>manpce/0</B>, 
after which you find <I>Preferences</I> in the <I>File</I> menu.

<P>
<CENTER>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD ALIGN=center>Option</TD><TD ALIGN=center>Default</TD><TD>Area 
name</TD><TD>Description </TD></TR>
<TBODY>
<TR VALIGN=top><TD ALIGN=center><STRONG>-L</STRONG> </TD><TD ALIGN=center>2M</TD><TD><B>local 
stack</B></TD><TD>The local stack is used to store the execution 
environments of procedure invocations. The space for an environment is 
reclaimed when it fails, exits without leaving choice points, the 
alternatives are cut of with the !/0 predicate or no choice points have 
been created since the invocation and the last subclause is started 
(tail recursion optimisation). </TD></TR>
<TR VALIGN=top><TD ALIGN=center><STRONG>-G</STRONG> </TD><TD ALIGN=center>4M</TD><TD><B>global 
stack</B></TD><TD>The global stack is used to store terms created during 
Prolog's execution. Terms on this stack will be reclaimed by 
backtracking to a point before the term was created or by garbage 
collection (provided the term is no longer referenced). </TD></TR>
<TR VALIGN=top><TD ALIGN=center><STRONG>-T</STRONG> </TD><TD ALIGN=center>4M</TD><TD><B>trail 
stack</B></TD><TD>The trail stack is used to store assignments during 
execution. Entries on this stack remain alive until backtracking before 
the point of creation or the garbage collector determines they are nor 
needed any longer. </TD></TR>
<TR VALIGN=top><TD ALIGN=center><STRONG>-A</STRONG> </TD><TD ALIGN=center>1M</TD><TD><B>argument 
stack</B></TD><TD>The argument stack is used to store one of the 
intermediate code interpreter's registers. The amount of space needed on 
this stack is determined entirely by the depth in which terms are nested 
in the clauses that constitute the program. Overflow is most likely when 
using long strings in a clause.

<P>In addition, this stack is used by some built-in predicates to handle 
cyclic terms. Its default size limit is proportional to the global stack 
limit such that it will never overflow. </TD></TR>
</TABLE>

</CENTER>
<TABLE ALIGN=center WIDTH="75%"><TR><TD>
<B>Table 2 : </B>Memory areas</TABLE>

<A NAME="tab:areas"></A>

<H4><A NAME="sec:2.18.1.1">2.18.1.1 The heap</A></H4>

<A NAME="sec:heap"></A>

<P><A NAME="idx:stackmemorymanagement:247"></A><A NAME="idx:memorylayout:248"></A>With 
the heap, we refer to the memory area used by <B>malloc()</B> and 
friends. SWI-Prolog uses the area to store atoms, functors, predicates 
and their clauses, records and other dynamic data. As of SWI-Prolog 
2.8.5, no limits are imposed on the addresses returned by
<B>malloc()</B> and friends.

<P>On some machines, the runtime stacks described above are allocated 
using `sparse allocation'. Virtual space up to the limit is claimed at 
startup and committed and released while the area grows and shrinks. On 
Win32 platform this is realised using <B>VirtualAlloc()</B> and friends. 
On Unix systems this is realised using <B>mmap()</B>.

<H3><A NAME="sec:2.18.2">2.18.2 Other Limits</A></H3>

<A NAME="sec:morelimits"></A>

<DL>
<DT><B>Clauses</B></DT>
<DD>
The only limit on clauses is their arity (the number of arguments to the 
head), which is limited to 1024. Raising this limit is easy and 
relatively cheap, removing it is harder.</DD>
<DT><B>Atoms and Strings</B></DT>
<DD>
SWI-Prolog has no limits on the sizes of atoms and strings. <A NAME="idx:read1:249"></A><A HREF="termrw.html#read/1">read/1</A> 
and its derivatives however normally limit the number of newlines in an 
atom or string to 5 to improve error detection and recovery. This can be 
switched off with <A NAME="idx:stylecheck1:250"></A><A HREF="debugger.html#style_check/1">style_check/1</A>.

<P>The number of atoms is limited to 16777216 (16M) on 32-bit machines. 
On 64-bit machines this is virtually unlimited. See also <A HREF="foreigninclude.html">section 
9.6.2.1</A>.</DD>
<DT><B>Memory areas</B></DT>
<DD>
On 32-bit hardware, SWI-Prolog data is packed in a 32-bit word, which 
contains both type and value information. The size of the various memory 
areas is limited to 128 Mb for each of the areas, except for the program 
heap, which is not limited. On 64-bit hardware there are no meaningful 
limits.</DD>
<DT><B>Integers</B></DT>
<DD>
Integers are 64-bit on 32 as well as 64-bit machines. Integers up to the 
value of the <CODE>max_tagged_integer</CODE> prolog-flag are represented 
more efficiently on the stack. For clauses and records the difference is 
much smaller.</DD>
<DT><B>Floats</B></DT>
<DD>
Floating point numbers are represented as C-native double precision 
floats, 64 bit IEEE on most machines.
</DD>
</DL>

<H3><A NAME="sec:2.18.3">2.18.3 Reserved Names</A></H3>

<A NAME="sec:resnames"></A>

<P>The boot compiler (see <STRONG>-b</STRONG> option) does not support 
the module system. As large parts of the system are written in Prolog 
itself we need some way to avoid name clashes with the user's 
predicates, database keys, etc. Like Edinburgh C-Prolog <CITE><A HREF="Bibliography.html#CPROLOG:manual">Pereira, 
1986</A></CITE> all predicates, database keys, etc. that should be 
hidden from the user start with a dollar (<CODE>$</CODE>) sign (see <A NAME="idx:stylecheck1:251"></A><A HREF="debugger.html#style_check/1">style_check/1</A>).
</BODY></HTML>