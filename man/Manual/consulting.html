<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.37 Reference Manual: Section 4.3</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="chars.html">
<LINK REL=next HREF="listing.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text: { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="chars.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="listing.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:4.3"><SPAN class="sec-nr">4.3</SPAN> <SPAN class="sec-title">Loading 
Prolog source files</SPAN></A></H2>

<A NAME="sec:consulting"></A>

<P>This section deals with loading Prolog source-files. A Prolog source 
file is a plain text file containing a Prolog program or part thereof. 
Prolog source files come in three flavours:

<DL>
<DT><B> A traditional</B></DT>
<DD>
Prolog source file contains a Prolog clauses and directives, but no <EM>module-declaration</EM>. 
They are normally loaded using <A NAME="idx:consult1:325"></A><A class="pred" href="consulting.html#consult/1">consult/1</A> 
or <A NAME="idx:ensureloaded1:326"></A><A class="pred" href="consulting.html#ensure_loaded/1">ensure_loaded/1</A>.</DD>
<DT><B> A module</B></DT>
<DD>
Prolog source file starts with a module declaration. The subsequent 
Prolog code is loaded into the specified module and only the <EM>public</EM> 
predicates are made available to the context loading the module. Module 
files are normally loaded using <A NAME="idx:usemodule12:327"></A><A class="pred" href="import.html#use_module/1">use_module/[1,2]</A>. 
See <A class="sec" href="modules.html">chapter 5</A> for details.</DD>
<DT><B> An include</B></DT>
<DD>
Prolog source file is loaded using the <A NAME="idx:include1:328"></A><A class="pred" href="consulting.html#include/1">include/1</A> 
directive and normally contains only directives.
</DD>
</DL>

<P>Prolog source-files are located using <A NAME="idx:absolutefilename3:329"></A><A class="pred" href="files.html#absolute_file_name/3">absolute_file_name/3</A> 
with the following options:

<PRE class="code">
locate_prolog_file(Spec, Path) :-
        absolute_file_name(Spec,
                           [ file_type(prolog),
                             access(read)
                           ],
                           Path).
</PRE>

<P>The <CODE>file_type(prolog)</CODE> option is used to determine the 
extension of the file using <A NAME="idx:prologfiletype2:330"></A><A class="pred" href="consulting.html#prolog_file_type/2">prolog_file_type/2</A>. 
The default extension is
<CODE>.pl</CODE>. <VAR>Spec</VAR> allows for the <EM>path-alias</EM> 
construct defined by <A NAME="idx:absolutefilename3:331"></A><A class="pred" href="files.html#absolute_file_name/3">absolute_file_name/3</A>. 
The most commonly used path-alias is <CODE>library(LibraryFile)</CODE>. 
The example below loads the library file <CODE>ordsets.pl</CODE> 
(containing predicates for manipulating ordered sets).

<PRE class="code">
:- use_module(library(ordsets)).
</PRE>

<P>SWI-Prolog recognises grammar rules (<A NAME="idx:DCG:332">DCG</A>) 
as defined in
<CITE><A class="cite" href="Bibliography.html#Clocksin:87">Clocksin &amp; 
Melish, 1987</A></CITE>. The user may define additional compilation of 
the source file by defining the dynamic predicates <A NAME="idx:termexpansion2:333"></A><A class="pred" href="consulting.html#term_expansion/2">term_expansion/2</A> 
and
<A NAME="idx:goalexpansion2:334"></A><A class="pred" href="consulting.html#goal_expansion/2">goal_expansion/2</A>. 
Transformations by <A NAME="idx:termexpansion2:335"></A><A class="pred" href="consulting.html#term_expansion/2">term_expansion/2</A> 
overrule the systems grammar rule transformations. It is not allowed to 
use <A NAME="idx:assert1:336"></A><A class="pred" href="db.html#assert/1">assert/1</A>,
<A NAME="idx:retract1:337"></A><A class="pred" href="db.html#retract/1">retract/1</A> 
or any other database predicate in <A NAME="idx:termexpansion2:338"></A><A class="pred" href="consulting.html#term_expansion/2">term_expansion/2</A> 
other than for local computational purposes.<SUP class="fn">22<SPAN class="fn-text">It 
does work for normal loading, but not for <A NAME="idx:qcompile1:339"></A><A class="pred" href="consulting.html#qcompile/1">qcompile/1</A>.</SPAN></SUP>

<P>Directives may be placed anywhere in a source file, invoking any 
predicate. They are executed when encountered. If the directive fails, a 
warning is printed. Directives are specified by :-/1 or ?-/1. There is 
no difference between the two.

<P>SWI-Prolog does not have a separate reconsult/1 predicate. 
Reconsulting is implied automatically by the fact that a file is 
consulted which is already loaded.

<DL>
<DT class="pubdef"><A NAME="load_files/2"><STRONG>load_files</STRONG>(<VAR>+Files, 
+Options</VAR>)</A></DT>
<DD class="defbody">
The predicate <A NAME="idx:loadfiles2:340"></A><A class="pred" href="consulting.html#load_files/2">load_files/2</A> 
is the parent of all the other loading predicates except for <A NAME="idx:include1:341"></A><A class="pred" href="consulting.html#include/1">include/1</A>. 
It currently supports a subset of the options of Quintus <A NAME="idx:loadfiles2:342"></A><A class="pred" href="consulting.html#load_files/2">load_files/2</A>. <VAR>Files</VAR> 
is either a single source-file, or a list of source-files. The 
specification for a source-file is handed to <A NAME="idx:absolutefilename2:343"></A><A class="pred" href="files.html#absolute_file_name/2">absolute_file_name/2</A>. 
See this predicate for the supported expansions. <VAR>Options</VAR> is a 
list of options using the format
<BLOCKQUOTE>
<VAR>OptionName</VAR>(<VAR>OptionValue</VAR>)
</BLOCKQUOTE>

<P>The following options are currently supported:

<DL>
<DT><STRONG>autoload</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
If <CODE>true</CODE> (default <CODE>false</CODE>), indicate this load is 
a
<EM>demand</EM> load. This implies that, depending on the setting of the 
Prolog flag <A class="flag" href="flags.html#flag:verbose_autoload">verbose_autoload</A> 
the load-action is printed at level <CODE>informational</CODE> or <CODE>silent</CODE>. 
See also <A NAME="idx:printmessage2:344"></A><A class="pred" href="exception.html#print_message/2">print_message/2</A> 
and <A NAME="idx:currentprologflag2:345"></A><A class="pred" href="flags.html#current_prolog_flag/2">current_prolog_flag/2</A>.</DD>
<DT><STRONG>derived_from</STRONG>(<VAR>File</VAR>)</DT>
<DD class="defbody">
Indicate that the loaded file is derived from <VAR>File</VAR>. Used by
<A NAME="idx:make0:346"></A><A class="pred" href="consulting.html#make/0">make/0</A> 
to time-check and load the original file rather than the derived file.</DD>
<DT><STRONG>encoding</STRONG>(<VAR>Encoding</VAR>)</DT>
<DD class="defbody">
Specify the way characters are encoded in the file. Default is taken 
from the prolog flag <A class="flag" href="flags.html#flag:encoding">encoding</A>. 
See <A class="sec" href="widechars.html">section 2.17.1</A> for details.</DD>
<DT><STRONG>expand</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
If <CODE>true</CODE>, run the filenames through <A NAME="idx:expandfilename2:347"></A><A class="pred" href="files.html#expand_file_name/2">expand_file_name/2</A> 
and load the returned files. Default is <CODE>false</CODE>, except for <A NAME="idx:consult1:348"></A><A class="pred" href="consulting.html#consult/1">consult/1</A> 
which is intended for interactive use. Flexible location of files is 
defined by <A NAME="idx:filesearchpath2:349"></A><A class="pred" href="consulting.html#file_search_path/2">file_search_path/2</A>.</DD>
<DT><STRONG>if</STRONG>(<VAR>Condition</VAR>)</DT>
<DD class="defbody">
Load the file only if the specified condition is satisfied. The value
<CODE>true</CODE> loads the file unconditionally, <CODE>changed</CODE> 
loads the file if it was not loaded before, or has been modified since 
it was loaded the last time, <CODE>not_loaded</CODE> loads the file if 
it was not loaded before.</DD>
<DT><STRONG>imports</STRONG>(<VAR>ListOrAll</VAR>)</DT>
<DD class="defbody">
If <CODE>all</CODE> and the file is a module file, import all public 
predicates. Otherwise import only the named predicates. Each predicate 
is referred to as &lt;<VAR>name</VAR>&gt;/&lt;<VAR>arity</VAR>&gt;. This 
option has no effect if the file is not a module file.</DD>
<DT><STRONG>must_be_module</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
If <CODE>true</CODE>, raise an error if the file is not a module file. 
Used by
<A NAME="idx:usemodule12:350"></A><A class="pred" href="import.html#use_module/1">use_module/[1,2]</A>.</DD>
<DT><STRONG>qcompile</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
If this call appears in a directive of a file that is compiled into 
Quick Load Format using <A NAME="idx:qcompile1:351"></A><A class="pred" href="consulting.html#qcompile/1">qcompile/1</A> 
and this flag is <CODE>true</CODE>, the contents of the argument files 
are included in the <CODE>.qlf</CODE> file instead of the loading 
directive.</DD>
<DT><STRONG>silent</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
If <CODE>true</CODE>, load the file without printing a message. The 
specified value is the default for all files loaded as a result of 
loading the specified files. This option writes the prolog flag
<A class="flag" href="flags.html#flag:verbose_load">verbose_load</A> 
with the negation of <VAR>Bool</VAR>.</DD>
<DT><STRONG>stream</STRONG>(<VAR>Input</VAR>)</DT>
<DD class="defbody">
This SWI-Prolog extension compiles the data from the stream
<VAR>Input</VAR>. If this option is used, <VAR>Files</VAR> must be a 
single atom which is used to identify the source-location of the loaded 
clauses as well as remove all clauses if the data is re-consulted.

<P>This option is added to allow compiling from non-file locations such 
as databases, the web, the <EM>user</EM> (see <A NAME="idx:consult1:352"></A><A class="pred" href="consulting.html#consult/1">consult/1</A>) 
or other servers.
</DD>
</DL>

<P>The <A NAME="idx:loadfiles2:353"></A><A class="pred" href="consulting.html#load_files/2">load_files/2</A> 
predicate can be hooked to load other data or data from other objects 
than files. See <A NAME="idx:prologloadfile2:354"></A><A class="pred" href="loadfilehook.html#prolog_load_file/2">prolog_load_file/2</A> 
for a description and
<CODE>library(http_load)</CODE> for an example.</DD>
<DT class="pubdef"><A NAME="consult/1"><STRONG>consult</STRONG>(<VAR>+File</VAR>)</A></DT>
<DD class="defbody">
Read <VAR>File</VAR> as a Prolog source file. <VAR>File</VAR> may be a 
list of files, in which case all members are consulted in turn. <VAR>File</VAR> 
may start with the Unix shell special sequences <CODE> </CODE>, <CODE>&nbsp;&lt;<VAR>user</VAR>&gt;</CODE> 
and <CODE>$&lt;<VAR>var</VAR>&gt;</CODE>. <VAR>File</VAR> may also be <CODE>library(Name)</CODE>, 
in which case the libraries are searched for a file with the specified 
name. See also <A NAME="idx:librarydirectory1:355"></A><A class="pred" href="consulting.html#library_directory/1">library_directory/1</A> 
and <A NAME="idx:filesearchpath2:356"></A><A class="pred" href="consulting.html#file_search_path/2">file_search_path/2</A>. <A NAME="idx:consult1:357"></A><A class="pred" href="consulting.html#consult/1">consult/1</A> 
may be abbreviated by just typing a number of file names in a list. 
Examples:

<P>
<CENTER>
<TABLE BORDER=0 FRAME=void RULES=groups>
<TR VALIGN=top><TD><CODE>?- consult(load).</CODE> </TD><TD>% consult <CODE>load</CODE> 
or <CODE>load.pl</CODE> </TD></TR>
<TR VALIGN=top><TD><CODE>?- [library(quintus)].</CODE> </TD><TD>% load 
Quintus compatibility library </TD></TR>
<TR VALIGN=top><TD><CODE>?- [user].</CODE></TD></TR>
</TABLE>

</CENTER>

<P>The predicate <A NAME="idx:consult1:358"></A><A class="pred" href="consulting.html#consult/1">consult/1</A> 
is equivalent to load_files(Files, []), except for handling the special 
file <CODE>user</CODE>, which reads clauses from the terminal. See also 
the <CODE>stream(Input)</CODE> option of <A NAME="idx:loadfiles2:359"></A><A class="pred" href="consulting.html#load_files/2">load_files/2</A>.</DD>
<DT class="pubdef"><A NAME="ensure_loaded/1"><STRONG>ensure_loaded</STRONG>(<VAR>+File</VAR>)</A></DT>
<DD class="defbody">
If the file is not already loaded, this is equivalent to <A NAME="idx:consult1:360"></A><A class="pred" href="consulting.html#consult/1">consult/1</A>. 
Otherwise, if the file defines a module, import all public predicates. 
Finally, if the file is already loaded, is not a module file and the 
context module is not the global user module, <A NAME="idx:ensureloaded1:361"></A><A class="pred" href="consulting.html#ensure_loaded/1">ensure_loaded/1</A> 
will call <A NAME="idx:consult1:362"></A><A class="pred" href="consulting.html#consult/1">consult/1</A>.

<P>With the semantics, we hope to get as closely possible to the clear 
semantics without the presence of a module system. Applications using 
modules should consider using <A NAME="idx:usemodule12:363"></A><A class="pred" href="import.html#use_module/1">use_module/[1,2]</A>.

<P>Equivalent to load_files(Files, [if(not_loaded)]).<SUP class="fn">23<SPAN class="fn-text">On 
older versions the condition used to be if(changed). Poor time 
management on some machines or due to copying often caused problems. The <A NAME="idx:make0:364"></A><A class="pred" href="consulting.html#make/0">make/0</A> 
predicate deals with updating the running system after changing the 
source code.</SPAN></SUP></DD>
<DT class="pubdef"><A NAME="include/1"><STRONG>include</STRONG>(<VAR>+File</VAR>)</A></DT>
<DD class="defbody">
Pretend the terms in <VAR>File</VAR> are in the source-file in which
<CODE>:- include(File)</CODE> appears. The include construct is only 
honoured if it appears as a directive in a source-file. Normally
<VAR>File</VAR> contains a sequence of directives.</DD>
<DT class="pubdef"><A NAME="require/1"><STRONG>require</STRONG>(<VAR>+ListOfNameAndArity</VAR>)</A></DT>
<DD class="defbody">
Declare that this file/module requires the specified predicates to be 
defined ``with their commonly accepted definition''. This predicate 
originates from the Prolog portability layer for XPCE. It is intended to 
provide a portable mechanism for specifying that this module requires 
the specified predicates.

<P>The implementation normally first verifies whether the predicate is 
already defined. If not, it will search the libraries and load the 
required library.

<P>SWI-Prolog, having autoloading, does <B>not</B> load the library. 
Instead it creates a procedure header for the predicate if it does not 
exist. This will flag the predicate as `undefined'. See also <A NAME="idx:check0:365"></A><A class="pred" href="check.html#check/0">check/0</A> 
and
<A NAME="idx:autoload0:366"></A><A class="pred" href="runtime.html#autoload/0">autoload/0</A>.</DD>
<DT class="pubdef"><A NAME="encoding/1"><STRONG>encoding</STRONG>(<VAR>+Encoding</VAR>)</A></DT>
<DD class="defbody">
This directive can appear anywhere in a source file to define how 
characters are encoded in the remainder of the file. It can be used in 
files that are encoded with a superset of US-ASCII, currently UTF-8 and 
ISO Latin-1. See also <A class="sec" href="widechars.html">section 
2.17.1</A>.</DD>
<DT class="pubdef"><A NAME="make/0"><STRONG>make</STRONG></A></DT>
<DD class="defbody">
Consult all source files that have been changed since they were 
consulted. It checks <VAR>all</VAR> loaded source files: files loaded 
into a compiled state using <CODE>pl -c ...</CODE> and files loaded 
using consult or one of its derivatives. The predicate <A NAME="idx:make0:367"></A><A class="pred" href="consulting.html#make/0">make/0</A> 
is called after
<A NAME="idx:edit1:368"></A><A class="pred" href="listing.html#edit/1">edit/1</A>, 
automatically reloading all modified files. It the user uses an external 
editor (in a separate window), <A NAME="idx:make0:369"></A><A class="pred" href="consulting.html#make/0">make/0</A> 
is normally used to update the program after editing. In addition, <A NAME="idx:make0:370"></A><A class="pred" href="consulting.html#make/0">make/0</A> 
updates the autoload indices (see <A class="sec" href="autoload.html">section 
2.13</A>) and runs <A NAME="idx:listundefined0:371"></A><A class="pred" href="check.html#list_undefined/0">list_undefined/0</A> 
from the <CODE>library(check)</CODE> library to report on undefined 
predicates.</DD>
<DT class="pubdef"><A NAME="library_directory/1"><STRONG>library_directory</STRONG>(<VAR>?Atom</VAR>)</A></DT>
<DD class="defbody">
Dynamic predicate used to specify library directories. Default
<CODE>./lib</CODE>, <CODE> /lib/prolog</CODE> and the system's library 
(in this order) are defined. The user may add library directories using <A NAME="idx:assert1:372"></A><A class="pred" href="db.html#assert/1">assert/1</A>, <A NAME="idx:asserta1:373"></A><A class="pred" href="db.html#asserta/1">asserta/1</A> 
or remove system defaults using <A NAME="idx:retract1:374"></A><A class="pred" href="db.html#retract/1">retract/1</A>.</DD>
<DT class="pubdef"><A NAME="file_search_path/2"><STRONG>file_search_path</STRONG>(<VAR>+Alias, 
?Path</VAR>)</A></DT>
<DD class="defbody">
Dynamic predicate used to specify `path-aliases'. This feature is best 
described using an example. Given the definition

<PRE class="code">
file_search_path(demo, '/usr/lib/prolog/demo').
</PRE>

<P>the file specification <CODE>demo(myfile)</CODE> will be expanded to
<CODE>/usr/lib/prolog/demo/myfile</CODE>. The second argument of
<A NAME="idx:filesearchpath2:375"></A><A class="pred" href="consulting.html#file_search_path/2">file_search_path/2</A> 
may be another alias.

<P>Below is the initial definition of the file search path. This path 
implies <CODE>swi(&lt;<VAR>Path</VAR>&gt;)</CODE> refers to a file in 
the SWI-Prolog home directory. The alias <CODE>foreign(&lt;<VAR>Path</VAR>&gt;)</CODE> 
is intended for storing shared libraries (<CODE>.so</CODE> or <CODE>.DLL</CODE> 
files). See also
<A NAME="idx:loadforeignlibrary12:376"></A><A class="pred" href="DLL.html#load_foreign_library/1">load_foreign_library/[1,2]</A>.

<PRE class="code">
user:file_search_path(library, X) :-
        library_directory(X).
user:file_search_path(swi, Home) :-
        current_prolog_flag(home, Home).
user:file_search_path(foreign, swi(ArchLib)) :-
        current_prolog_flag(arch, Arch),
        atom_concat('lib/', Arch, ArchLib).
user:file_search_path(foreign, swi(lib)).
</PRE>

<P>The <A NAME="idx:filesearchpath2:377"></A><A class="pred" href="consulting.html#file_search_path/2">file_search_path/2</A> 
expansion is used by all loading predicates as well as by <A NAME="idx:absolutefilename23:378"></A><A class="pred" href="files.html#absolute_file_name/2">absolute_file_name/[2,3]</A>.

<P>The Prolog flag <A class="flag" href="flags.html#flag:verbose_file_search">verbose_file_search</A> 
can be set to <CODE>true</CODE> to help debugging Prolog's search for 
files.</DD>
<DT class="pubdef"><A NAME="expand_file_search_path/2"><STRONG>expand_file_search_path</STRONG>(<VAR>+Spec, 
-Path</VAR>)</A></DT>
<DD class="defbody">
Unifies <VAR>Path</VAR> with all possible expansions of the file name 
specification <VAR>Spec</VAR>. See also <A NAME="idx:absolutefilename3:379"></A><A class="pred" href="files.html#absolute_file_name/3">absolute_file_name/3</A>.</DD>
<DT class="pubdef"><A NAME="prolog_file_type/2"><STRONG>prolog_file_type</STRONG>(<VAR>?Extension, 
?Type</VAR>)</A></DT>
<DD class="defbody">
This dynamic multifile predicate defined in module <CODE>user</CODE> 
determines the extensions considered by <A NAME="idx:filesearchpath2:380"></A><A class="pred" href="consulting.html#file_search_path/2">file_search_path/2</A>.
<VAR>Extension</VAR> is the filename extension without the leading dot,
<VAR>Type</VAR> denotes the type as used by the <CODE>file_type(Type)</CODE> 
option of <A NAME="idx:filesearchpath2:381"></A><A class="pred" href="consulting.html#file_search_path/2">file_search_path/2</A>. 
Here is the initial definition of
<A NAME="idx:prologfiletype2:382"></A><A class="pred" href="consulting.html#prolog_file_type/2">prolog_file_type/2</A>:

<PRE class="code">
user:prolog_file_type(pl,       prolog).
user:prolog_file_type(Ext,      prolog) :-
        current_prolog_flag(associate, Ext),
        Ext \== pl.
user:prolog_file_type(qlf,      qlf).
user:prolog_file_type(Ext,      executable) :-
        current_prolog_flag(shared_object_extension, Ext).
</PRE>

<P>Users may wish to change the extension used for Prolog source files 
to avoid conflicts (for example with <B>perl</B>) as well as to be 
compatible with some specific implementation. The preferred alternative 
extension is <CODE>.pro</CODE>.</DD>
<DT class="pubdef"><A NAME="source_file/1"><STRONG>source_file</STRONG>(<VAR>?File</VAR>)</A></DT>
<DD class="defbody">
True if <VAR>File</VAR> is a loaded Prolog source file. <VAR>File</VAR> 
is the absolute and canonical path to the source-file.</DD>
<DT class="pubdef"><A NAME="source_file/2"><STRONG>source_file</STRONG>(<VAR>?Pred, 
?File</VAR>)</A></DT>
<DD class="defbody">
Is true if the predicate specified by <VAR>Pred</VAR> was loaded from 
file
<VAR>File</VAR>, where <VAR>File</VAR> is an absolute path name (see
<A NAME="idx:absolutefilename2:383"></A><A class="pred" href="files.html#absolute_file_name/2">absolute_file_name/2</A>). 
Can be used with any instantiation pattern, but the database only 
maintains the source file for each predicate. See also <A NAME="idx:clauseproperty2:384"></A><A class="pred" href="examineprog.html#clause_property/2">clause_property/2</A>.</DD>
<DT class="pubdef"><A NAME="prolog_load_context/2"><STRONG>prolog_load_context</STRONG>(<VAR>?Key, 
?Value</VAR>)</A></DT>
<DD class="defbody">
Determine loading context. The following keys are defined:
<CENTER>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><B>Key</B></TD><TD><B>Description </B></TD></TR>
<TBODY>
<TR VALIGN=top><TD><CODE>module</CODE> </TD><TD>Module into which file 
is loaded </TD></TR>
<TR VALIGN=top><TD><CODE>source</CODE> </TD><TD>File loaded. Returns the 
original Prolog file when loading a <CODE>.qlf</CODE> file. Compatible 
to SICStus Prolog. </TD></TR>
<TR VALIGN=top><TD><CODE>file</CODE> </TD><TD>Currently equivalent to <CODE>file</CODE>. 
In future versions it may report a different values for files being 
loaded using <A NAME="idx:include1:385"></A><A class="pred" href="consulting.html#include/1">include/1</A>. </TD></TR>
<TR VALIGN=top><TD><CODE>stream</CODE> </TD><TD>Stream identifier (see <A NAME="idx:currentinput1:386"></A><A class="pred" href="IO.html#current_input/1">current_input/1</A>) </TD></TR>
<TR VALIGN=top><TD><CODE>directory</CODE> </TD><TD>Directory in which <VAR>File</VAR> 
lives. </TD></TR>
<TR VALIGN=top><TD><CODE>term_position</CODE> </TD><TD>Position of last 
term read. Term of the form
<TT>'$stream_position'(0,&lt;<VAR>Line</VAR>&gt;,0,0,0)</TT>. See also <A NAME="idx:streampositiondata3:387"></A><A class="pred" href="IO.html#stream_position_data/3">stream_position_data/3</A>. </TD></TR>
</TABLE>

</CENTER>
Quintus compatibility predicate. See also <A NAME="idx:sourcelocation2:388"></A><A class="pred" href="consulting.html#source_location/2">source_location/2</A>.</DD>
<DT class="pubdef"><A NAME="source_location/2"><STRONG>source_location</STRONG>(<VAR>-File, 
-Line</VAR>)</A></DT>
<DD class="defbody">
If the last term has been read from a physical file (i.e., not from the 
file <CODE>user</CODE> or a string), unify <VAR>File</VAR> with an 
absolute path to the file and <VAR>Line</VAR> with the line-number in 
the file. New code should use <A NAME="idx:prologloadcontext2:389"></A><A class="pred" href="consulting.html#prolog_load_context/2">prolog_load_context/2</A>.</DD>
<DT class="pubdef"><A NAME="term_expansion/2"><STRONG>term_expansion</STRONG>(<VAR>+Term1, 
-Term2</VAR>)</A></DT>
<DD class="defbody">
Dynamic and multifile predicate, normally not defined. When defined by 
the user all terms read during consulting are given to this predicate. 
If the predicate succeeds Prolog will assert <VAR>Term2</VAR> in the 
database rather then the read term (<VAR>Term1</VAR>). <VAR>Term2</VAR> 
may be a term of a the form `?- <VAR>Goal</VAR>' or `:- <VAR>Goal</VAR>'. <VAR>Goal</VAR> 
is then treated as a directive. If <VAR>Term2</VAR> is a list all terms 
of the list are stored in the database or called (for directives). If
<VAR>Term2</VAR> is of the form below, the system will assert <VAR>Clause</VAR> 
and record the indicated source-location with it.
<BLOCKQUOTE>
<TT>'$source_location'(&lt;<VAR>File</VAR>&gt;, &lt;<VAR>Line</VAR>&gt;):&lt;<VAR>Clause</VAR>&gt;</TT>
</BLOCKQUOTE>

<P>When compiling a module (see <A class="sec" href="modules.html">chapter 
5</A> and the directive <A NAME="idx:module2:390"></A><A class="pred" href="manipmodule.html#module/2">module/2</A>),
<A NAME="idx:expandterm2:391"></A><A class="pred" href="consulting.html#expand_term/2">expand_term/2</A> 
will first try <A NAME="idx:termexpansion2:392"></A><A class="pred" href="consulting.html#term_expansion/2">term_expansion/2</A> 
in the module being compiled to allow for term-expansion rules that are 
local to a module. If there is no local definition, or the local 
definition fails to translate the term, <A NAME="idx:expandterm2:393"></A><A class="pred" href="consulting.html#expand_term/2">expand_term/2</A> 
will try <A NAME="idx:termexpansion2:394"></A><A class="pred" href="consulting.html#term_expansion/2">term_expansion/2</A> 
in module
<CODE>user</CODE>. For compatibility with SICStus and Quintus Prolog, 
this feature should not be used. See also <A NAME="idx:expandterm2:395"></A><A class="pred" href="consulting.html#expand_term/2">expand_term/2</A>, <A NAME="idx:goalexpansion2:396"></A><A class="pred" href="consulting.html#goal_expansion/2">goal_expansion/2</A> 
and
<A NAME="idx:expandgoal2:397"></A><A class="pred" href="consulting.html#expand_goal/2">expand_goal/2</A>.</DD>
<DT class="pubdef"><A NAME="expand_term/2"><STRONG>expand_term</STRONG>(<VAR>+Term1, 
-Term2</VAR>)</A></DT>
<DD class="defbody">
This predicate is normally called by the compiler to perform 
preprocessing. First it calls <A NAME="idx:termexpansion2:398"></A><A class="pred" href="consulting.html#term_expansion/2">term_expansion/2</A>. 
If this predicate fails it performs a grammar-rule translation. If this 
fails it returns the first argument.</DD>
<DT class="pubdef"><A NAME="goal_expansion/2"><STRONG>goal_expansion</STRONG>(<VAR>+Goal1, 
-Goal2</VAR>)</A></DT>
<DD class="defbody">
Like <A NAME="idx:termexpansion2:399"></A><A class="pred" href="consulting.html#term_expansion/2">term_expansion/2</A>, <A NAME="idx:goalexpansion2:400"></A><A class="pred" href="consulting.html#goal_expansion/2">goal_expansion/2</A> 
provides for macro-expansion of Prolog source-code. Between <A NAME="idx:expandterm2:401"></A><A class="pred" href="consulting.html#expand_term/2">expand_term/2</A> 
and the actual compilation, the body of clauses analysed and the goals 
are handed to <A NAME="idx:expandgoal2:402"></A><A class="pred" href="consulting.html#expand_goal/2">expand_goal/2</A>, 
which uses the <A NAME="idx:goalexpansion2:403"></A><A class="pred" href="consulting.html#goal_expansion/2">goal_expansion/2</A> 
hook to do user-defined expansion.

<P>The predicate <A NAME="idx:goalexpansion2:404"></A><A class="pred" href="consulting.html#goal_expansion/2">goal_expansion/2</A> 
is first called in the module that is being compiled, and then on the <CODE>user</CODE> 
module. If <VAR>Goal</VAR> is of the form <VAR>Module</VAR>:<VAR>Goal</VAR> 
where <VAR>Module</VAR> is instantiated,
<A NAME="idx:goalexpansion2:405"></A><A class="pred" href="consulting.html#goal_expansion/2">goal_expansion/2</A> 
is called on <VAR>Goal</VAR> using rules from module
<VAR>Module</VAR> followed by <CODE>user</CODE>.

<P>Only goals appearing in the body of clauses when reading a 
source-file are expanded using mechanism, and only if they appear 
literally in the clause, or as an argument to the meta-predicates <A NAME="idx:not1:406"></A><A class="pred" href="metacall.html#not/1">not/1</A>, <A NAME="idx:call1:407"></A><A class="pred" href="metacall.html#call/1">call/1</A>, <A NAME="idx:once1:408"></A><A class="pred" href="metacall.html#once/1">once/1</A>,
<A NAME="idx:ignore1:409"></A><A class="pred" href="metacall.html#ignore/1">ignore/1</A>, <A NAME="idx:findall3:410"></A><A class="pred" href="allsolutions.html#findall/3">findall/3</A>, <A NAME="idx:bagof3:411"></A><A class="pred" href="allsolutions.html#bagof/3">bagof/3</A>, <A NAME="idx:setof3:412"></A><A class="pred" href="allsolutions.html#setof/3">setof/3</A> 
or <A NAME="idx:forall2:413"></A><A class="pred" href="forall2.html#forall/2">forall/2</A>. 
A real predicate definition is required to deal with dynamically 
constructed calls.</DD>
<DT class="pubdef"><A NAME="expand_goal/2"><STRONG>expand_goal</STRONG>(<VAR>+Goal1, 
-Goal2</VAR>)</A></DT>
<DD class="defbody">
This predicate is normally called by the compiler to perform 
preprocessing. First it calls <A NAME="idx:goalexpansion2:414"></A><A class="pred" href="consulting.html#goal_expansion/2">goal_expansion/2</A>. 
If this fails it returns the first argument.</DD>
<DT class="pubdef"><A NAME="at_initialization/1"><STRONG>at_initialization</STRONG>(<VAR>+Goal</VAR>)</A></DT>
<DD class="defbody">
Register <VAR>Goal</VAR> to be run when the system initialises. 
Initialisation takes place after reloading a .qlf (formerly .wic) file 
as well as after reloading a saved-state. The hooks are run in the order 
they were registered. A warning message is issued if <VAR>Goal</VAR> 
fails, but execution continues. See also <A NAME="idx:athalt1:415"></A><A class="pred" href="consulting.html#at_halt/1">at_halt/1</A></DD>
<DT class="pubdef"><A NAME="at_halt/1"><STRONG>at_halt</STRONG>(<VAR>+Goal</VAR>)</A></DT>
<DD class="defbody">
Register <VAR>Goal</VAR> to be run from PL_cleanup(), which is called 
when the system halts. The hooks are run in the reverse order they were 
registered (FIFO). Success or failure executing a hook is ignored. If 
the hook raises an exception this is printed using <A NAME="idx:printmessage2:416"></A><A class="pred" href="exception.html#print_message/2">print_message/2</A>. 
An attempt to call <A NAME="idx:halt01:417"></A><A class="pred" href="toplevel.html#halt/0">halt/[0,1]</A> 
from a hook is ignored.</DD>
<DT class="pubdef"><A NAME="initialization/1"><STRONG>initialization</STRONG>(<VAR>+Goal</VAR>)</A></DT>
<DD class="defbody">
Call <VAR>Goal</VAR> and register it using <A NAME="idx:atinitialization1:418"></A><A class="pred" href="consulting.html#at_initialization/1">at_initialization/1</A>. 
Directives that do other things than creating clauses, records, flags or 
setting predicate attributes should normally be written using this tag 
to ensure the initialisation is executed when a saved system starts. See 
also <A NAME="idx:qsaveprogram12:419"></A><A class="pred" href="runtime.html#qsave_program/1">qsave_program/[1,2]</A>.</DD>
<DT class="pubdef"><A NAME="compiling/0"><STRONG>compiling</STRONG></A></DT>
<DD class="defbody">
True if the system is compiling source files with the <STRONG>-c</STRONG> 
option or <A NAME="idx:qcompile1:420"></A><A class="pred" href="consulting.html#qcompile/1">qcompile/1</A> 
into an intermediate code file. Can be used to perform conditional code 
optimisations in <A NAME="idx:termexpansion2:421"></A><A class="pred" href="consulting.html#term_expansion/2">term_expansion/2</A> 
(see also the
<STRONG>-O</STRONG> option) or to omit execution of directives during 
compilation.</DD>
<DT class="pubdef"><A NAME="preprocessor/2"><STRONG>preprocessor</STRONG>(<VAR>-Old, 
+New</VAR>)</A></DT>
<DD class="defbody">
Read the input file via a Unix process that acts as preprocessor. A 
preprocessor is specified as an atom. The first occurrence of the string 
`<CODE>%f</CODE>' is replaced by the name of the file to be loaded. The 
resulting atom is called as a Unix command and the standard output of 
this command is loaded. To use the Unix C preprocessor one should 
define:

<PRE class="code">
?- preprocessor(Old, '/lib/cpp -C -P %f'), consult(...).

Old = none
</PRE>

<P></DD>
</DL>

<H3><A NAME="sec:4.3.1"><SPAN class="sec-nr">4.3.1</SPAN> <SPAN class="sec-title">Loading 
files, active code and threads</SPAN></A></H3>

<P>Traditionally, Prolog environments allow for reloading files holding 
currently active code. In particular, the following sequence is valid 
use of the development environment:

<P>
<UL>
<LI>Trace a goal
<LI>Find unexpected behaviour of a predicate
<LI>Enter a <EM>break</EM> using the <B>b</B> command
<LI>Fix the sources and reload them using <A NAME="idx:make0:422"></A><A class="pred" href="consulting.html#make/0">make/0</A>
<LI>Exit the break, <EM>retry</EM> using the <B>r</B> command
</UL>

<P>Goals running during the reload keep running on the old definition, 
while new goals use the reloaded definition, which is why the
<EM>retry</EM> must be used <EM>after</EM> the reload. This implies that 
clauses of predicates that are active during the reload cannot be 
reclaimed. Normally a small amount of dead clauses should not be an 
issue during development. Such clauses can be reclaimed with
<A NAME="idx:garbagecollectclauses0:423"></A><A class="pred" href="consulting.html#garbage_collect_clauses/0">garbage_collect_clauses/0</A>.

<DL>
<DT class="pubdef"><A NAME="garbage_collect_clauses/0"><STRONG>garbage_collect_clauses</STRONG></A></DT>
<DD class="defbody">
leanup all <EM>dirty</EM> predicates, where dirty predicates are defined 
to be predicates that have both old and new definitions due to reloading 
a source file while the predicate was active. Of course, predicates that 
are active using <A NAME="idx:garbagecollectclauses0:424"></A><A class="pred" href="consulting.html#garbage_collect_clauses/0">garbage_collect_clauses/0</A> 
cannot be reclaimed and remain <EM>dirty</EM>. Predicate are -like 
atoms- shared resources and therefore all threads are suspended during 
the execution of this predicate.
</DD>
</DL>

<H4><A NAME="sec:4.3.1.1"><SPAN class="sec-nr">4.3.1.1</SPAN> <SPAN class="sec-title">Threads 
and reloading running code</SPAN></A></H4>

<P>As of version 5.5.30, there is basic thread-safety for reloading 
source files while other threads are executing code defined in these 
source files. Reloading a file freezes all threads after marking the 
active predicates originating from the file being reloaded. The threads 
are resumed after the file has been loaded. In addition, after 
completing loading the outermost file the system runs
<A NAME="idx:garbagecollectclauses0:425"></A><A class="pred" href="consulting.html#garbage_collect_clauses/0">garbage_collect_clauses/0</A>.

<P>What does that mean? Unfortunately it does <EM>not</EM> mean we can 
`hot-swap' modules. Consider the case where thread <VAR>A</VAR> is 
executing the recursive predicate <VAR>P</VAR>. We `fix' <VAR>P</VAR> 
and reload. The already running goals for <VAR>P</VAR> continue to run 
the old definition, but new recursive calls will use the new definition! 
Many similar cases can be constructed with dependent predicates.

<P>It provides some basic security for reloading files in multi-threaded 
applications during development. In the above scenarios the system does 
not crash uncontrolled, but behaves like any broken program: it may 
return the wrong bindings, wrong truth value or raise an exception.

<P>Future versions may have an `update now' facility. Such as facility 
can be implemented on top of the <EM>logical update view</EM>. It would 
allow threads to do a controlled update between processing independent 
jobs.

<H3><A NAME="sec:4.3.2"><SPAN class="sec-nr">4.3.2</SPAN> <SPAN class="sec-title">Quick 
load files</SPAN></A></H3>

<A NAME="sec:qlf"></A>

<P>SWI-Prolog supports compilation of individual or multiple Prolog 
source files into `Quick Load Files'. A `Quick Load Files' (<CODE>.qlf</CODE> 
file) stores the contents of the file in a precompiled format.

<P>These files load considerably faster than source files and are 
normally more compact. They are machine independent and may thus be 
loaded on any implementation of SWI-Prolog. Note however that clauses 
are stored as virtual machine instructions. Changes to the compiler will 
generally make old compiled files unusable.

<P>Quick Load Files are created using <A NAME="idx:qcompile1:426"></A><A class="pred" href="consulting.html#qcompile/1">qcompile/1</A>. 
They are loaded using
<A NAME="idx:consult1:427"></A><A class="pred" href="consulting.html#consult/1">consult/1</A> 
or one of the other file-loading predicates described in
<A class="sec" href="consulting.html">section 4.3</A>. If consult is 
given the explicit <CODE>.pl</CODE> file, it will load the Prolog 
source. When given the <CODE>.qlf</CODE> file, it will load the file. 
When no extension is specified, it will load the
<CODE>.qlf</CODE> file when present and the <CODE>.pl</CODE> file 
otherwise.

<DL>
<DT class="pubdef"><A NAME="qcompile/1"><STRONG>qcompile</STRONG>(<VAR>+File</VAR>)</A></DT>
<DD class="defbody">
Takes a single file specification like <A NAME="idx:consult1:428"></A><A class="pred" href="consulting.html#consult/1">consult/1</A> 
(i.e., accepts constructs like <CODE>library(LibFile)</CODE> and, in 
addition to the normal compilation, creates a <EM>Quick Load File</EM> 
from <VAR>File</VAR>. The file-extension of this file is <CODE>.qlf</CODE>. 
The base name of the Quick Load File is the same as the input file.

<P>If the file contains `<CODE>:- consult(<VAR>+File</VAR>)</CODE>', `<CODE>:- 
[<VAR>+File</VAR>]</CODE>' or <CODE>:- load_files(<VAR>+File</VAR>, 
[qcompile(true), ...])</CODE> statements, the referred files are 
compiled into the same <CODE>.qlf</CODE> file. Other directives will be 
stored in the
<CODE>.qlf</CODE> file and executed in the same fashion as when loading 
the
<CODE>.pl</CODE> file.

<P>For <A NAME="idx:termexpansion2:429"></A><A class="pred" href="consulting.html#term_expansion/2">term_expansion/2</A>, 
the same rules as described in
<A class="sec" href="compilation.html">section 2.10</A> apply.

<P>Conditional execution or optimisation may test the predicate
<A NAME="idx:compiling0:430"></A><A class="pred" href="consulting.html#compiling/0">compiling/0</A>.

<P>Source references (<A NAME="idx:sourcefile2:431"></A><A class="pred" href="consulting.html#source_file/2">source_file/2</A>) 
in the Quick Load File refer to the Prolog source file from which the 
compiled code originates.
</DD>
</DL>

<P></BODY></HTML>