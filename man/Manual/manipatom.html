<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.22 Reference Manual: Section 4.21</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="manipterm.html">
<LINK REL=next HREF="chartype.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ margin-left: 0.5em;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text: { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 250px;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="manipterm.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="chartype.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:4.21"><SPAN class="sec-nr">4.21</SPAN><SPAN class="sec-title">Analysing 
and Constructing Atoms</SPAN></A></H2>

<A NAME="sec:manipatom"></A>

<P>These predicates convert between Prolog constants and lists of 
character codes. The predicates <A NAME="idx:atomcodes2:833"></A><A class="pred" href="manipatom.html#atom_codes/2">atom_codes/2</A>, <A NAME="idx:numbercodes2:834"></A><A class="pred" href="manipatom.html#number_codes/2">number_codes/2</A> 
and <A NAME="idx:name2:835"></A><A class="pred" href="manipatom.html#name/2">name/2</A> 
behave the same when converting from a constant to a list of character 
codes. When converting the other way around, <A NAME="idx:atomcodes2:836"></A><A class="pred" href="manipatom.html#atom_codes/2">atom_codes/2</A> 
will generate an atom, <A NAME="idx:numbercodes2:837"></A><A class="pred" href="manipatom.html#number_codes/2">number_codes/2</A> 
will generate a number or exception and <A NAME="idx:name2:838"></A><A class="pred" href="manipatom.html#name/2">name/2</A> 
will return a number if possible and an atom otherwise.

<P>The ISO standard defines <A NAME="idx:atomchars2:839"></A><A class="pred" href="manipatom.html#atom_chars/2">atom_chars/2</A> 
to describe the `broken-up' atom as a list of one-character atoms 
instead of a list of codes. Up-to version 3.2.x, SWI-Prolog's <A NAME="idx:atomchars2:840"></A><A class="pred" href="manipatom.html#atom_chars/2">atom_chars/2</A> 
behaved, compatible to Quintus and SICStus Prolog, like atom_codes. As 
of 3.3.x SWI-Prolog
<A NAME="idx:atomcodes2:841"></A><A class="pred" href="manipatom.html#atom_codes/2">atom_codes/2</A> 
and <A NAME="idx:atomchars2:842"></A><A class="pred" href="manipatom.html#atom_chars/2">atom_chars/2</A> 
are compliant to the ISO standard.

<P>To ease the pain of all variations in the Prolog community, all 
SWI-Prolog predicates behave as flexible as possible. This implies the 
`list-side' accepts either a code-list or a char-list and the 
`atom-side' accept all atomic types (atom, number and string).

<DL>
<DT class="pubdef"><A NAME="atom_codes/2"><STRONG>atom_codes</STRONG>(<VAR>?Atom, 
?String</VAR>)</A></DT>
<DD class="defbody">
Convert between an atom and a list of character codes. If
<VAR>Atom</VAR> is instantiated, if will be translated into a list of 
character codes and the result is unified with <VAR>String</VAR>. If <VAR>Atom</VAR> 
is unbound and <VAR>String</VAR> is a list of character codes, it will
<VAR>Atom</VAR> will be unified with an atom constructed from this list.</DD>
<DT class="pubdef"><A NAME="atom_chars/2"><STRONG>atom_chars</STRONG>(<VAR>?Atom, 
?CharList</VAR>)</A></DT>
<DD class="defbody">
As <A NAME="idx:atomcodes2:843"></A><A class="pred" href="manipatom.html#atom_codes/2">atom_codes/2</A>, 
but <VAR>CharList</VAR> is a list of one-character atoms rather than a 
list of character codes<SUP class="fn">45<SPAN class="fn-text">Up-to 
version 3.2.x, <A NAME="idx:atomchars2:844"></A><A class="pred" href="manipatom.html#atom_chars/2">atom_chars/2</A> 
behaved as the current <A NAME="idx:atomcodes2:845"></A><A class="pred" href="manipatom.html#atom_codes/2">atom_codes/2</A>. 
The current definition is compliant with the ISO standard</SPAN></SUP>.

<PRE class="code">
?- atom_chars(hello, X).

X = [h, e, l, l, o]
</PRE>

</DD>
<DT class="pubdef"><A NAME="char_code/2"><STRONG>char_code</STRONG>(<VAR>?Atom, 
?Code</VAR>)</A></DT>
<DD class="defbody">
Convert between character and character code for a single character.<SUP class="fn">46<SPAN class="fn-text">This 
is also called atom_char/2 in older versions of SWI-Prolog as well as 
some other Prolog implementations. The atom_char/2 predicate is 
available from the library <CODE>backcomp.pl</CODE></SPAN></SUP></DD>
<DT class="pubdef"><A NAME="number_chars/2"><STRONG>number_chars</STRONG>(<VAR>?Number, 
?CharList</VAR>)</A></DT>
<DD class="defbody">
Similar to <A NAME="idx:atomchars2:846"></A><A class="pred" href="manipatom.html#atom_chars/2">atom_chars/2</A>, 
but converts between a number and its representation as a list of 
one-character atoms. Fails with a
<CODE>representation_error</CODE> if <VAR>Number</VAR> is unbound and
<VAR>CharList</VAR> does not describe a number.</DD>
<DT class="pubdef"><A NAME="number_codes/2"><STRONG>number_codes</STRONG>(<VAR>?Number, 
?CodeList</VAR>)</A></DT>
<DD class="defbody">
As <A NAME="idx:numberchars2:847"></A><A class="pred" href="manipatom.html#number_chars/2">number_chars/2</A>, 
but converts to a list of character codes rather than one-character 
atoms. In the mode -, +, both predicates behave identically to improve 
handling of non-ISO source.</DD>
<DT class="pubdef"><A NAME="atom_number/2"><STRONG>atom_number</STRONG>(<VAR>?Atom, 
?Number</VAR>)</A></DT>
<DD class="defbody">
Realises the popular combination of <A NAME="idx:atomcodes2:848"></A><A class="pred" href="manipatom.html#atom_codes/2">atom_codes/2</A> 
and <A NAME="idx:numbercodes2:849"></A><A class="pred" href="manipatom.html#number_codes/2">number_codes/2</A> 
to convert between atom and number (integer or float) in one predicate, 
avoiding the intermediate list.</DD>
<DT class="pubdef"><A NAME="name/2"><STRONG>name</STRONG>(<VAR>?AtomOrInt, 
?String</VAR>)</A></DT>
<DD class="defbody">
<VAR>String</VAR> is a list of character codes representing the same 
text as <VAR>Atom</VAR>. Each of the arguments may be a variable, but 
not both. When <VAR>String</VAR> is bound to an character code list 
describing an integer and <VAR>Atom</VAR> is a variable <VAR>Atom</VAR> 
will be unified with the integer value described by <VAR>String</VAR> 
(e.g. `<CODE>name(N, "300"), 400 is N + 100</CODE>' succeeds).</DD>
<DT class="pubdef"><A NAME="term_to_atom/2"><STRONG>term_to_atom</STRONG>(<VAR>?Term, 
?Atom</VAR>)</A></DT>
<DD class="defbody">
True if <VAR>Atom</VAR> describes a term that unifies with <VAR>Term</VAR>. 
When
<VAR>Atom</VAR> is instantiated <VAR>Atom</VAR> is converted and then 
unified with
<VAR>Term</VAR>. If <VAR>Atom</VAR> has no valid syntax, a <CODE>syntax_error</CODE> 
exception is raised. Otherwise <VAR>Term</VAR> is ``written'' on <VAR>Atom</VAR> 
using <A NAME="idx:write1:850"></A><A class="pred" href="termrw.html#write/1">write/1</A>.</DD>
<DT class="pubdef"><A NAME="atom_to_term/3"><STRONG>atom_to_term</STRONG>(<VAR>+Atom, 
-Term, -Bindings</VAR>)</A></DT>
<DD class="defbody">
Use <VAR>Atom</VAR> as input to <A NAME="idx:readterm2:851"></A><A class="pred" href="termrw.html#read_term/2">read_term/2</A> 
using the option
<CODE>variable_names</CODE> and return the read term in <VAR>Term</VAR> 
and the variable bindings in <VAR>Bindings</VAR>. <VAR>Bindings</VAR> is 
a list of
<VAR><VAR>Name</VAR> = <VAR>Var</VAR></VAR> couples, thus providing 
access to the actual variable names. See also <A NAME="idx:readterm2:852"></A><A class="pred" href="termrw.html#read_term/2">read_term/2</A>. 
If <VAR>Atom</VAR> has no valid syntax, a <CODE>syntax_error</CODE> 
exception is raised.</DD>
<DT class="pubdef"><A NAME="atom_concat/3"><STRONG>atom_concat</STRONG>(<VAR>?Atom1, 
?Atom2, ?Atom3</VAR>)</A></DT>
<DD class="defbody">
<VAR>Atom3</VAR> forms the concatenation of <VAR>Atom1</VAR> and <VAR>Atom2</VAR>. 
At least two of the arguments must be instantiated to atoms, integers or 
floating point numbers. For ISO compliance, the instantiation-pattern -, 
-, + is allowed too, non-deterministically splitting the 3-th argument 
into two parts (as <A NAME="idx:append3:853"></A><A class="pred" href="lists.html#append/3">append/3</A> 
does for lists). See also
<A NAME="idx:stringconcat3:854"></A><A class="pred" href="strings.html#string_concat/3">string_concat/3</A>.</DD>
<DT class="pubdef"><A NAME="concat_atom/2"><STRONG>concat_atom</STRONG>(<VAR>+List, 
-Atom</VAR>)</A></DT>
<DD class="defbody">
<VAR>List</VAR> is a list of atoms, integers or floating point numbers. 
Succeeds if <VAR>Atom</VAR> can be unified with the concatenated 
elements of <VAR>List</VAR>. If
<VAR>List</VAR> has exactly 2 elements it is equivalent to <A NAME="idx:atomconcat3:855"></A><A class="pred" href="manipatom.html#atom_concat/3">atom_concat/3</A>, 
allowing for variables in the list.</DD>
<DT class="pubdef"><A NAME="concat_atom/3"><STRONG>concat_atom</STRONG>(<VAR>?List, 
+Separator, ?Atom</VAR>)</A></DT>
<DD class="defbody">
Creates an atom just like <A NAME="idx:concatatom2:856"></A><A class="pred" href="manipatom.html#concat_atom/2">concat_atom/2</A>, 
but inserts <VAR>Separator</VAR> between each pair of atoms. For 
example:

<PRE class="code">
?- concat_atom([gnu, gnat], ', ', A).

A = 'gnu, gnat'
</PRE>

<P>This predicate can also be used to split atoms by instantiating
<VAR>Separator</VAR> and <VAR>Atom</VAR>:

<PRE class="code">
?- concat_atom(L, -, 'gnu-gnat').

L = [gnu, gnat]
</PRE>

</DD>
<DT class="pubdef"><A NAME="atom_length/2"><STRONG>atom_length</STRONG>(<VAR>+Atom, 
-Length</VAR>)</A></DT>
<DD class="defbody">
True if <VAR>Atom</VAR> is an atom of <VAR>Length</VAR> characters long. 
This predicate also works for strings (see <A class="sec" href="strings.html">section 
4.23</A>). If the prolog flag <CODE>iso</CODE> is <EM>not</EM> set, it 
also accepts integers and floats, expressing the number of characters 
output when given to <A NAME="idx:write1:857"></A><A class="pred" href="termrw.html#write/1">write/1</A> 
as well as code-lists and character-lists, expressing the length of the 
list.<SUP class="fn">bug<SPAN class="fn-text">Note that <CODE>[]</CODE> 
is both an atom an empty code/character list. The predicate <A NAME="idx:atomlength2:858"></A><A class="pred" href="manipatom.html#atom_length/2">atom_length/2</A> 
returns 2 for this atom.</SPAN></SUP></DD>
<DT class="pubdef"><A NAME="atom_prefix/2"><STRONG>atom_prefix</STRONG>(<VAR>+Atom, 
+Prefix</VAR>)</A></DT>
<DD class="defbody">
True if <VAR>Atom</VAR> starts with the characters from <VAR>Prefix</VAR>. 
Its behaviour is equivalent to
<CODE>?- sub_atom(<VAR>Atom</VAR>, 0, _, _, <VAR>Prefix</VAR>)</CODE>. 
Depreciated.</DD>
<DT class="pubdef"><A NAME="sub_atom/5"><STRONG>sub_atom</STRONG>(<VAR>+Atom, 
?Before, ?Len, ?After, ?Sub</VAR>)</A></DT>
<DD class="defbody">
ISO predicate for breaking atoms. It maintains the following relation:
<VAR>Sub</VAR> is a sub-atom of <VAR>Atom</VAR> that starts at <VAR>Before</VAR>, 
has
<VAR>Len</VAR> characters and <VAR>Atom</VAR> contains <VAR>After</VAR> 
characters after the match.

<PRE class="code">
?- sub_atom(abc, 1, 1, A, S).

A = 1, S = b
</PRE>

<P>The implementation minimises non-determinism and creation of atoms. 
This is a very flexible predicate that can do search, prefix- and 
suffix-matching, etc.
</DD>
</DL>

<P></BODY></HTML>