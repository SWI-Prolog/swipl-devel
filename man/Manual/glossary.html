<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.45 Reference Manual</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="portabilitystrategies.html">
<LINK REL=next HREF="license.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text: { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="portabilitystrategies.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="license.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H1><A NAME="sec:D"><SPAN class="sec-nr">D</SPAN> <SPAN class="sec-title">Glossary 
of Terms</SPAN></A></H1>

<A NAME="sec:glossary"></A>

<DL>
<DT><A NAME="gloss:anonymou"><STRONG>anonymous [variable]</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:anonymousvariable:1562"></A><A NAME="idx:variableanonymous:1563"></A> 
The variable <CODE>_</CODE> is called the <A class="gloss" href="glossary.html#gloss:anonymou">anonymous</A> 
variable. Multiple occurrences of <CODE>_</CODE> in a single <A class="gloss" href="glossary.html#gloss:term">term</A> 
are not <A class="gloss" href="glossary.html#gloss:shared">shared</A>.</DD>
<DT><A NAME="gloss:argument"><STRONG>arguments</STRONG></A></DT>
<DD class="defbody">
Arguments are <A class="gloss" href="glossary.html#gloss:term">terms</A> 
that appear in a <A class="gloss" href="glossary.html#gloss:compound">compound</A> <A class="gloss" href="glossary.html#gloss:term">term</A>. <VAR>A1</VAR> 
and <VAR>a2</VAR> are the first and second argument of the term
<CODE>myterm(A1, a2)</CODE>.</DD>
<DT><A NAME="gloss:arity"><STRONG>arity</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:arity:1564"></A>Argument count (is number of arguments) of 
a <A class="gloss" href="glossary.html#gloss:compound">compound</A> <A class="gloss" href="glossary.html#gloss:term">term</A>.</DD>
<DT><A NAME="gloss:assert"><STRONG>assert</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:assert:1565"></A>Add a <A class="gloss" href="glossary.html#gloss:clause">clause</A> 
to a <A class="gloss" href="glossary.html#gloss:predicate">predicate</A>. 
Clauses can be added at either end of the clause-list of a <A class="gloss" href="glossary.html#gloss:predicate">predicate</A>. 
See <A NAME="idx:assert1:1566"></A><A class="pred" href="db.html#assert/1">assert/1</A> 
and <A NAME="idx:assertz1:1567"></A><A class="pred" href="db.html#assertz/1">assertz/1</A>.</DD>
<DT><A NAME="gloss:atom"><STRONG>atom</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:atom:1568"></A>Textual constant. Used as name for <A class="gloss" href="glossary.html#gloss:compound">compound</A> 
terms, to represent constants or text.</DD>
<DT><A NAME="gloss:backtracking"><STRONG>backtracking</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:backtracking:1569"></A>Searching process used by Prolog. If 
a predicate offers multiple
<A class="gloss" href="glossary.html#gloss:clause">clauses</A> to solve 
a <A class="gloss" href="glossary.html#gloss:goal">goal</A>, they are 
tried one-by-one until one <A class="gloss" href="glossary.html#gloss:succeed">succeeds</A>. 
If a subsequent part of the proof is not satisfied with the resulting <A class="gloss" href="glossary.html#gloss:variable">variable</A> <A class="gloss" href="glossary.html#gloss:binding">binding</A>, 
it may ask for an alternative <A class="gloss" href="glossary.html#gloss:solution">solution</A> 
(= <A class="gloss" href="glossary.html#gloss:binding">binding</A> of 
the <A class="gloss" href="glossary.html#gloss:variable">variables</A>), 
causing Prolog to reject the previously chosen <A class="gloss" href="glossary.html#gloss:clause">clause</A> 
and try the next one.</DD>
<DT><A NAME="gloss:binding"><STRONG>binding [of a variable]</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:binding:1570"></A>Current value of the <A class="gloss" href="glossary.html#gloss:variable">variable</A>. 
See also <A class="gloss" href="glossary.html#gloss:backtracking">backtracking</A> 
and
<A class="gloss" href="glossary.html#gloss:query">query</A>.</DD>
<DT><A NAME="gloss:built-in"><STRONG>built-in [predicate]</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:builtinpredicate:1571"></A>Predicate that is part of the 
Prolog system. Built in predicates cannot be redefined by the user, 
unless this is overruled using
<A NAME="idx:redefinesystempredicate1:1572"></A><A class="pred" href="db.html#redefine_system_predicate/1">redefine_system_predicate/1</A>.</DD>
<DT><A NAME="gloss:body"><STRONG>body</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:body:1573"></A>Part of a <A class="gloss" href="glossary.html#gloss:clause">clause</A> 
behind the <A class="gloss" href="glossary.html#gloss:neck">neck</A> 
operator (<CODE><CODE>:-</CODE></CODE>).</DD>
<DT><A NAME="gloss:clause"><STRONG>clause</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:clause:1574"></A>`Sentence' of a Prolog program. A <A class="gloss" href="glossary.html#gloss:clause">clause</A> 
consists of a <A class="gloss" href="glossary.html#gloss:head">head</A> 
and
<A class="gloss" href="glossary.html#gloss:body">body</A> separated by 
the <A class="gloss" href="glossary.html#gloss:neck">neck</A> operator (<CODE><CODE>:-</CODE></CODE>) 
or it is a
<A class="gloss" href="glossary.html#gloss:fact">fact</A>. For example:

<PRE class="code">
parent(X) :-
        father(X, _).
</PRE>

<P>Expressed ``X is a parent if X is a father of someone''. See also
<A class="gloss" href="glossary.html#gloss:variable">variable</A> and <A class="gloss" href="glossary.html#gloss:predicate">predicate</A>.</DD>
<DT><A NAME="gloss:compile"><STRONG>compile</STRONG></A></DT>
<DD class="defbody">
Process where a Prolog <A class="gloss" href="glossary.html#gloss:program">program</A> 
is translated to a sequence of instructions. See also <A class="gloss" href="glossary.html#gloss:interpreted">interpreted</A>. 
SWI-Prolog always compiles your program before executing it.</DD>
<DT><A NAME="gloss:compound"><STRONG>compound [term]</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:compound:1575"></A>Also called <A class="gloss" href="glossary.html#gloss:structure">structure</A>. 
It consists of a name followed by <VAR>N</VAR>
<A class="gloss" href="glossary.html#gloss:argument">arguments</A>, each 
of which are <A class="gloss" href="glossary.html#gloss:term">terms</A>. <VAR>N</VAR> 
is called the
<A class="gloss" href="glossary.html#gloss:arity">arity</A> of the term.</DD>
<DT><A NAME="gloss:context-module"><STRONG>context module</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:contextmodule:1576"></A><A NAME="idx:modulecontex:1577"></A>If 
a <A class="gloss" href="glossary.html#gloss:term">term</A> is referring 
to a <A class="gloss" href="glossary.html#gloss:predicate">predicate</A> 
in a <A class="gloss" href="glossary.html#gloss:module">module</A>, the
<A class="gloss" href="glossary.html#gloss:context-module">context module</A> 
is used to find the target module. The context module of a <A class="gloss" href="glossary.html#gloss:goal">goal</A> 
is the module in which the <A class="gloss" href="glossary.html#gloss:predicate">predicate</A> 
is defined, unless this <A class="gloss" href="glossary.html#gloss:predicate">predicate</A> 
is <A class="gloss" href="glossary.html#gloss:module-transparent">module transparent</A>, 
in which case the <A class="gloss" href="glossary.html#gloss:context-module">context module</A> 
is inherited from the parent
<A class="gloss" href="glossary.html#gloss:goal">goal</A>. See also <A NAME="idx:moduletransparent1:1578"></A><A class="pred" href="manipmodule.html#module_transparent/1">module_transparent/1</A>.</DD>
<DT><A NAME="gloss:dynamic"><STRONG>dynamic [predicate]</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:dynamicpredicate:1579"></A><A NAME="idx:predicatedynamic:1580"></A>A <A class="gloss" href="glossary.html#gloss:dynamic">dynamic</A> 
predicate is a predicate to which <A class="gloss" href="glossary.html#gloss:clause">clauses</A> 
may be
<A class="gloss" href="glossary.html#gloss:assert">assert</A>ed and from 
which <A class="gloss" href="glossary.html#gloss:clause">clauses</A> may 
be <A class="gloss" href="glossary.html#gloss:retract">retract</A>ed 
while the program is running. See also <A class="gloss" href="glossary.html#gloss:update-view">update view</A>.</DD>
<DT><A NAME="gloss:exported"><STRONG>exported [predicate]</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:exportedpredicate:1581"></A><A NAME="idx:predicateexported:1582"></A>A <A class="gloss" href="glossary.html#gloss:predicate">predicate</A> 
is said to be <A class="gloss" href="glossary.html#gloss:exported">exported</A> 
from a <A class="gloss" href="glossary.html#gloss:module">module</A> if 
it appears in the <A class="gloss" href="glossary.html#gloss:public-list">public list</A>. 
This implies that the predicate can be <A class="gloss" href="glossary.html#gloss:imported">imported</A> 
into another module to make it visible there. See also <A NAME="idx:usemodule12:1583"></A><A class="pred" href="import.html#use_module/1">use_module/[1,2]</A>.</DD>
<DT><A NAME="gloss:fact"><STRONG>fact</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:fact:1584"></A><A class="gloss" href="glossary.html#gloss:clause">Clause</A> 
without a <A class="gloss" href="glossary.html#gloss:body">body</A>. 
This is called a fact because interpreted as logic, there is no 
condition to be satisfied. The example below states <CODE>john</CODE> is 
a person.

<PRE class="code">
person(john).
</PRE>

</DD>
<DT><A NAME="gloss:fail"><STRONG>fail</STRONG></A></DT>
<DD class="defbody">
A <A class="gloss" href="glossary.html#gloss:goal">goal</A> is said to 
haved failed if it could not be <A class="gloss" href="glossary.html#gloss:prove">proven</A>.</DD>
<DT><A NAME="gloss:float"><STRONG>float</STRONG></A></DT>
<DD class="defbody">
Computers crippled representation of a real number. Represented as `IEEE 
double'.</DD>
<DT><A NAME="gloss:foreign"><STRONG>foreign</STRONG></A></DT>
<DD class="defbody">
Computer code expressed in other languages than Prolog. SWI-Prolog can 
only cooperate directly with the C and C++ computer languages.</DD>
<DT><A NAME="gloss:functor"><STRONG>functor</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:functor:1585"></A>Combination of name and <A class="gloss" href="glossary.html#gloss:arity">arity</A> 
of a <A class="gloss" href="glossary.html#gloss:compound">compound</A> 
term. The term
<CODE>foo(a, b, c)</CODE> is said to be a term belonging to the functor 
foo/3 . foo/0 is used to refer to the <A class="gloss" href="glossary.html#gloss:atom">atom</A>
<CODE>foo</CODE>.</DD>
<DT><A NAME="gloss:goal"><STRONG>goal</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:goal:1586"></A><A NAME="idx:query:1587"></A>Question stated 
to the Prolog engine. A <A class="gloss" href="glossary.html#gloss:goal">goal</A> 
is either an <A class="gloss" href="glossary.html#gloss:atom">atom</A> 
or a <A class="gloss" href="glossary.html#gloss:compound">compound</A> 
term. A <A class="gloss" href="glossary.html#gloss:goal">goal</A> 
succeeds, in which case the
<A class="gloss" href="glossary.html#gloss:variable">variables</A> in 
the <A class="gloss" href="glossary.html#gloss:compound">compound</A> 
terms have a <A class="gloss" href="glossary.html#gloss:binding">binding</A> 
or <A class="gloss" href="glossary.html#gloss:fail">fails</A> if Prolog 
fails to prove the <A class="gloss" href="glossary.html#gloss:goal">goal</A>.</DD>
<DT><A NAME="gloss:hashing"><STRONG>hashing</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:hashing:1588"></A><A class="gloss" href="glossary.html#gloss:indexing">Indexing</A> 
technique used for quick lookup.</DD>
<DT><A NAME="gloss:head"><STRONG>head</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:head:1589"></A>Part of a <A class="gloss" href="glossary.html#gloss:clause">clause</A> 
before the <A class="gloss" href="glossary.html#gloss:neck">neck</A> 
instruction. This is an atom or <A class="gloss" href="glossary.html#gloss:compound">compound</A> 
term.</DD>
<DT><A NAME="gloss:imported"><STRONG>imported [predicate]</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:importedpredicate:1590"></A><A NAME="idx:predicateimported:1591"></A>A <A class="gloss" href="glossary.html#gloss:predicate">predicate</A> 
is said to be <A class="gloss" href="glossary.html#gloss:imported">imported</A> 
into a <A class="gloss" href="glossary.html#gloss:module">module</A> if 
it is defined in another <A class="gloss" href="glossary.html#gloss:module">module</A> 
and made available in this <A class="gloss" href="glossary.html#gloss:module">module</A>. 
See also <A class="sec" href="modules.html">chapter 5</A>.</DD>
<DT><A NAME="gloss:indexing"><STRONG>indexing</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:indexing:1592"></A>Indexing is a technique used to quickly 
select candidate <A class="gloss" href="glossary.html#gloss:clause">clauses</A> 
of a <A class="gloss" href="glossary.html#gloss:predicate">predicate</A> 
for a specific <A class="gloss" href="glossary.html#gloss:goal">goal</A>. 
In most Prolog systems, including SWI-Prolog, indexing is done on the 
first <A class="gloss" href="glossary.html#gloss:argument">argument</A> 
of the <A class="gloss" href="glossary.html#gloss:head">head</A>. If 
this argument is instantiated to an <A class="gloss" href="glossary.html#gloss:atom">atom</A>,
<A class="gloss" href="glossary.html#gloss:integer">integer</A>, <A class="gloss" href="glossary.html#gloss:float">float</A> 
or <A class="gloss" href="glossary.html#gloss:compound">compound</A> 
term with <A class="gloss" href="glossary.html#gloss:functor">functor</A>,
<A class="gloss" href="glossary.html#gloss:hashing">hashing</A> is used 
quickly select all <A class="gloss" href="glossary.html#gloss:clause">clauses</A> 
of which the first argument may <A class="gloss" href="glossary.html#gloss:unify">unify</A> 
with the first argument of the <A class="gloss" href="glossary.html#gloss:goal">goal</A>.</DD>
<DT><A NAME="gloss:integer"><STRONG>integer</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:integer:1593"></A>Whole number. On all implementations of 
SWI-Prolog integers are at least 64-bit signed values. When linked to 
the GNU GMP library, integer arithmetic is unbounded. See also <A NAME="idx:currentprologflag2:1594"></A><A class="pred" href="flags.html#current_prolog_flag/2">current_prolog_flag/2</A>, 
flags <A class="flag" href="flags.html#flag:bounded">bounded</A>, <A class="flag" href="flags.html#flag:max_integer">max_integer</A> 
and <A class="flag" href="flags.html#flag:min_integer">min_integer</A>.</DD>
<DT><A NAME="gloss:interpreted"><STRONG>interpreted</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:interpreted:1595"></A>As opposed to <A class="gloss" href="glossary.html#gloss:compile">compiled</A>, 
interpreted means the Prolog system attempts to prove a <A class="gloss" href="glossary.html#gloss:goal">goal</A> 
by directly reading the <A class="gloss" href="glossary.html#gloss:clause">clauses</A> 
rather than executing instructions from an (abstract) instruction set 
that is not or only indirectly related to Prolog.</DD>
<DT><A NAME="gloss:meta-predicate"><STRONG>meta-predicate</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:metapredicate:1596"></A>A <A class="gloss" href="glossary.html#gloss:predicate">predicate</A> 
that reasons about other <A class="gloss" href="glossary.html#gloss:predicate">predicates</A>, 
either by calling them, (re)defining them or querying <A class="gloss" href="glossary.html#gloss:property">properties</A>.</DD>
<DT><A NAME="gloss:module"><STRONG>module</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:module:1597"></A>Collection of predicates. Each module 
defines a name-space for predicates. <A class="gloss" href="glossary.html#gloss:built-in">built-in</A> 
predicates are accessible from all modules. Predicates can be published 
(<A class="gloss" href="glossary.html#gloss:exported">exported</A>) and <A class="gloss" href="glossary.html#gloss:imported">imported</A> 
to make their definition available to other modules.</DD>
<DT><A NAME="gloss:module-transparent"><STRONG>module transparent [predicate]</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:moduletransparent:1598"></A><A NAME="idx:transparent:1599"></A>A <A class="gloss" href="glossary.html#gloss:predicate">predicate</A> 
that does not change the <A class="gloss" href="glossary.html#gloss:context-module">context module</A>. 
Sometimes also called a <A class="gloss" href="glossary.html#gloss:meta-predicate">meta-predicate</A>.</DD>
<DT><A NAME="gloss:multifile"><STRONG>multifile [predicate]</STRONG></A></DT>
<DD class="defbody">
Predicate for which the definition is distributed over multiple 
source-files. See <A NAME="idx:multifile1:1600"></A><A class="pred" href="dynamic.html#multifile/1">multifile/1</A>.</DD>
<DT><A NAME="gloss:neck"><STRONG>neck</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:neck:1601"></A>Operator (<CODE><CODE>:-</CODE></CODE>) 
separating <A class="gloss" href="glossary.html#gloss:head">head</A> 
from <A class="gloss" href="glossary.html#gloss:body">body</A> in a <A class="gloss" href="glossary.html#gloss:clause">clause</A>.</DD>
<DT><A NAME="gloss:operator"><STRONG>operator</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:operator:1602"></A>Symbol (<A class="gloss" href="glossary.html#gloss:atom">atom</A>) 
that may be placed before its <A class="gloss" href="glossary.html#gloss:operand">operand</A> 
(prefix), after its <A class="gloss" href="glossary.html#gloss:operand">operand</A> 
(postfix) or between its two <A class="gloss" href="glossary.html#gloss:operand">operands</A> 
(infix).

<P>In Prolog, the expression <CODE>a+b</CODE> is exactly the same as the 
canonical term <CODE>+(a,b)</CODE>.</DD>
<DT><A NAME="gloss:operand"><STRONG>operand</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:operand:1603"></A><A class="gloss" href="glossary.html#gloss:argument">Argument</A> 
of an <A class="gloss" href="glossary.html#gloss:operator">operator</A>.</DD>
<DT><A NAME="gloss:precedence"><STRONG>precedence</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:precedence:1604"></A>The <A class="gloss" href="glossary.html#gloss:priority">priority</A> 
of an <A class="gloss" href="glossary.html#gloss:operator">operator</A>. 
Operator precedence is used to interpret <CODE>a+b*c</CODE> as <CODE>+(a, *(b,c))</CODE>.</DD>
<DT><A NAME="gloss:predicate"><STRONG>predicate</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:predicate:1605"></A>Collection of <A class="gloss" href="glossary.html#gloss:clause">clauses</A> 
with the same <A class="gloss" href="glossary.html#gloss:functor">functor</A> 
(name/<A class="gloss" href="glossary.html#gloss:arity">arity</A>). If a <A class="gloss" href="glossary.html#gloss:goal">goal</A> 
is proved, the system looks for a <A class="gloss" href="glossary.html#gloss:predicate">predicate</A> 
with the same functor, then used <A class="gloss" href="glossary.html#gloss:indexing">indexing</A> 
to select candidate <A class="gloss" href="glossary.html#gloss:clause">clauses</A> 
and then tries these <A class="gloss" href="glossary.html#gloss:clause">clauses</A> 
one-by-one. See also <A class="gloss" href="glossary.html#gloss:backtracking">backtracking</A>.</DD>
<DT><A NAME="gloss:priority"><STRONG>priority</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:priority:1606"></A>In the context of <A class="gloss" href="glossary.html#gloss:operator">operators</A> 
a synonym for <A class="gloss" href="glossary.html#gloss:precedence">precedence</A>.</DD>
<DT><A NAME="gloss:program"><STRONG>program</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:program:1607"></A>Collection of <A class="gloss" href="glossary.html#gloss:predicate">predicates</A>.</DD>
<DT><A NAME="gloss:property"><STRONG>property</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:property:1608"></A>Attribute of an object. SWI-Prolog 
defines various <EM>*_property</EM> predicates to query the status of 
predicates, clauses. etc.</DD>
<DT><A NAME="gloss:prove"><STRONG>prove</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:prove:1609"></A>Process where Prolog attempts to prove a <A class="gloss" href="glossary.html#gloss:query">query</A> 
using the available
<A class="gloss" href="glossary.html#gloss:predicate">predicates</A>.</DD>
<DT><A NAME="gloss:public-list"><STRONG>public list</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:publiclist:1610"></A>List of <A class="gloss" href="glossary.html#gloss:predicate">predicates</A> 
exported from a <A class="gloss" href="glossary.html#gloss:module">module</A>.</DD>
<DT><A NAME="gloss:query"><STRONG>query</STRONG></A></DT>
<DD class="defbody">
See <A class="gloss" href="glossary.html#gloss:goal">goal</A>.</DD>
<DT><A NAME="gloss:retract"><STRONG>retract</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:retract:1611"></A>Remove a <A class="gloss" href="glossary.html#gloss:clause">clause</A> 
from a <A class="gloss" href="glossary.html#gloss:predicate">predicate</A>. 
See also <A class="gloss" href="glossary.html#gloss:dynamic">dynamic</A>,
<A class="gloss" href="glossary.html#gloss:update-view">update view</A> 
and <A class="gloss" href="glossary.html#gloss:assert">assert</A>.</DD>
<DT><A NAME="gloss:shared"><STRONG>shared</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:shared:1612"></A>Two <A class="gloss" href="glossary.html#gloss:variable">variables</A> 
are called <A class="gloss" href="glossary.html#gloss:shared">shared</A> 
after they are <A class="gloss" href="glossary.html#gloss:unify">unified</A>. 
This implies if either of them is <A class="gloss" href="glossary.html#gloss:binding">bound</A>, 
the other is bound to the same value:

<PRE class="code">
?- A = B, A = a.

A = a,
B = a
</PRE>

</DD>
<DT><A NAME="gloss:singleton"><STRONG>singleton [variable]</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:singleton:1613"></A><A class="gloss" href="glossary.html#gloss:variable">Variable</A> 
appearing only one time in a <A class="gloss" href="glossary.html#gloss:clause">clause</A>. 
SWI-Prolog normally warns for this to avoid you making spelling 
mistakes. If a variable appears on purpose only once in a clause, write 
it as <CODE>_</CODE> (see <A class="gloss" href="glossary.html#gloss:anonymou">anonymous</A>). 
Rules for naming a variable and avoiding a warning are given in <A class="sec" href="syntax.html">section 
2.15.1.5</A>.</DD>
<DT><A NAME="gloss:solution"><STRONG>solution</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:solution:1614"></A><A class="gloss" href="glossary.html#gloss:binding">Bindings</A> 
resulting from a successfully <A class="gloss" href="glossary.html#gloss:prove">prove</A>n <A class="gloss" href="glossary.html#gloss:goal">goal</A>.</DD>
<DT><A NAME="gloss:structure"><STRONG>structure</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:structure:1615"></A>Synonym for <A class="gloss" href="glossary.html#gloss:compound">compound</A> 
term.</DD>
<DT><A NAME="gloss:string"><STRONG>string</STRONG></A></DT>
<DD class="defbody">
Used for the following representations of text: a packed array (see <A class="sec" href="strings.html">section 
4.23</A>), SWI-Prolog specific), a list of character codes or a list of 
one-character <A class="gloss" href="glossary.html#gloss:atom">atoms</A>.</DD>
<DT><A NAME="gloss:succeed"><STRONG>succeed</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:succeed:1616"></A>A <A class="gloss" href="glossary.html#gloss:goal">goal</A> 
is said to have <A class="gloss" href="glossary.html#gloss:succeed">succeeded</A> 
if it has been <A class="gloss" href="glossary.html#gloss:prove">proven</A>.</DD>
<DT><A NAME="gloss:term"><STRONG>term</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:term:1617"></A>Value in Prolog. A <A class="gloss" href="glossary.html#gloss:term">term</A> 
is either a <A class="gloss" href="glossary.html#gloss:variable">variable</A>, <A class="gloss" href="glossary.html#gloss:atom">atom</A>, 
integer, float or <A class="gloss" href="glossary.html#gloss:compound">compound</A> 
term. In addition, SWI-Prolog also defines the type <A class="gloss" href="glossary.html#gloss:string">string</A></DD>
<DT><A NAME="gloss:transparent"><STRONG>transparent</STRONG></A></DT>
<DD class="defbody">
See <A class="gloss" href="glossary.html#gloss:module-transparent">module transparent</A>.</DD>
<DT><A NAME="gloss:unify"><STRONG>unify</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:unify:1618"></A>Prolog process to make two terms equal by 
assigning variables in one term to values at the corresponding location 
of the other term. For example:

<PRE class="code">
?- foo(a, B) = foo(A, b).

A = a,
B = b
</PRE>

<P>Unlike assignment (which does not exist in Prolog), unification is 
not directed.</DD>
<DT><A NAME="gloss:update-view"><STRONG>update view</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:updateview:1619"></A><A NAME="idx:viewupdate:1620"></A>How 
Prolog behaves when a <A class="gloss" href="glossary.html#gloss:dynamic">dynamic</A> <A class="gloss" href="glossary.html#gloss:predicate">predicate</A> 
is changed while it is running. There are two models. In most older 
Prolog systems the change becomes immediately visible to the <A class="gloss" href="glossary.html#gloss:goal">goal</A>, 
in modern systems including SWI-Prolog, the running <A class="gloss" href="glossary.html#gloss:goal">goal</A> 
is not affected. Only new <A class="gloss" href="glossary.html#gloss:goal">goals</A> 
`see' the new definition.</DD>
<DT><A NAME="gloss:variable"><STRONG>variable</STRONG></A></DT>
<DD class="defbody">
<A NAME="idx:variable:1621"></A>A Prolog variable is a value that `is 
not yet bound'. After <A class="gloss" href="glossary.html#gloss:binding">binding</A> 
a variable, it cannot be modified. <A class="gloss" href="glossary.html#gloss:backtracking">Backtracking</A> 
to a point in the execution before the variable was bound will turn it 
back into a variable:

<PRE class="code">
?- A = b, A = c.
No
?- (A = b; true; A = c).
A = b ;
A = _G283 ;
A = c ;
No
</PRE>

<P>See also <A class="gloss" href="glossary.html#gloss:unify">unify</A>.

<P></DD>
</DL>

<P></BODY></HTML>