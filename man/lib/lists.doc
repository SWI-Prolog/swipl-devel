\libdoc{lists}{List Manipulation}

This library provides commonly accepted basic predicates for list
manipulation in the Prolog community. Some additional list manipulations
are built-in.  Their description is in \secref{builtinlist}.


\begin{description}
    \predicate{append}{3}{?List1, ?List2, ?List3}
Succeeds when \arg{List3} unifies with the concatenation of \arg{List1}
and \arg{List2}. The predicate can be used with any instantiation
pattern (even three variables).

    \predicate{member}{2}{?Elem, ?List}
Succeeds when \arg{Elem} can be unified with one of the members of \arg{List}. The predicate can be used with any instantiation
pattern.

    \predicate{nextto}{3}{?X, ?Y, ?List}
Succeeds when \arg{Y} follows \arg{X} in \arg{List}.

    \predicate{delete}{3}{+List1, ?Elem, ?List2}
Delete all members of \arg{List1} that simultaneously unify with
\arg{Elem} and unify the result with \arg{List2}.

    \predicate{select}{3}{?Elem, ?List, ?Rest}
Select \arg{Elem} from \arg{List} leaving \arg{Rest}.  It behaves as
member/2, returning the remaining elements in \arg{Rest}.  Note that
besides selecting elements from a list, it can also be used to insert
elements.%
    \bug{Upto SWI-Prolog 3.3.10, the definition of this predicate was
	 not according to the de-facto standard. The first two arguments
	 were in the wrong order.}

    \predicate{nth0}{3}{?Index, ?List, ?Elem}
Succeeds when the \arg{Index}-th element of \arg{List} unifies with
\arg{Elem}. Counting starts at 0.

    \predicate{nth1}{3}{?Index, ?List, ?Elem}
Succeeds when the \arg{Index}-th element of \arg{List} unifies with
\arg{Elem}. Counting starts at 1.

    \predicate{last}{2}{?List, ?Elem}
Succeeds if \arg{Elem} unifies with the last element of \arg{List}. If
\arg{List} is a proper list last/2 is deterministic. If \arg{List} has
an unbound tail, backtracking will cause \arg{List} to grow.%
	\footnote{The argument order of this predicate was changed
		  in 5.1.12 for compatibility reasons.}

    \predicate{reverse}{2}{+List1, -List2}
Reverse the order of the elements in \arg{List1} and unify the result
with the elements of \arg{List2}.

    \predicate{permutation}{2}{?List1, ?List2}
Permuation is true when \arg{List1} is a permutation of \arg{List2}. The
implementation can solve for \arg{List2} given \arg{List1} or
\arg{List1} given \arg{List2}, or even enumerate \arg{List1} and
\arg{List2} together.

    \predicate{flatten}{2}{+List1, -List2}
Transform \arg{List1}, possibly holding lists as elements into a `flat'
list by replacing each list with its elements (recursively). Unify the
resulting flat list with \arg{List2}. Example:
\begin{code}
?- flatten([a, [b, [c, d], e]], X).

X = [a, b, c, d, e]
\end{code}

    \predicate{sumlist}{2}{+List, -Sum}
Unify \arg{Sum} to the result of adding all elements in \arg{List}.
\arg{List} must be a proper list holding numbers.  See number/1 and
is/2. for details on arithmetic.

    \predicate{numlist}{3}{+Low, +High, -List}
If \arg{Low} and \arg{High} are integers with $Low \le High$, unify
\arg{List} to a list [$Low$, $Low+1$, \ldots $High$].  See also
between/3.
\end{description}


\subsection{Set Manipulation}		\label{sec:manipset}

\begin{description}
    \predicate{is_set}{1}{+Set}
Succeeds if \arg{Set} is a list (see is_list/1) without duplicates.

    \predicate{list_to_set}{2}{+List, -Set}
Unifies \arg{Set} with a list holding the same elements as \arg{List} in
the same order.  If \arg{list} contains duplicates, only the first is
retained.  See also sort/2.  Example:
\begin{code}
?- list_to_set([a,b,a], X)

X = [a,b]
\end{code}

    \predicate{intersection}{3}{+Set1, +Set2, -Set3}
Succeeds if \arg{Set3} unifies with the intersection of \arg{Set1} and
\arg{Set2}. \arg{Set1} and \arg{Set2} are lists without duplicates.
They need not be ordered.

    \predicate{subtract}{3}{+Set, +Delete, -Result}
Delete all elements of set `Delete' from `Set' and unify the resulting
set with `Result'.

    \predicate{union}{3}{+Set1, +Set2, -Set3}
Succeeds if \arg{Set3} unifies with the union of \arg{Set1} and
\arg{Set2}. \arg{Set1} and \arg{Set2} are lists without duplicates.
They need not be ordered.

    \predicate{subset}{2}{+Subset, +Set}
Succeeds if all elements of \arg{Subset} are elements of \arg{Set} as well.
\end{description}

