\chapter{Generating Runtime Applications}

This chapter describes the features of SWI-Prolog for delivering
applications that can run without the development version of the
system installed.

A SWI-Prolog built application consists of at least two parts: the
emulator and the compiled application. The latter is in the same format
as a SWI-Prolog boot-file and SWI-Prolog pre-compiled (QLF) file. This
format is fast loadable and abstracted just far enough to be machine
independent. This implies an application delivered in binary format
can run on any computer for which an emulator is available without
modification.

.BD
.C qsave_program 2 +File, +ListOfOptions
Saves the current state of the program to the file `File'.  The result
is an executable shell-script, that will start the emulator. {\em
ListOfOptions} is a list of \mbox{\em Key = Value} pairs.  The available
keys are described in table~\ref{tab:qsave-options}.

\begin{table}
\begin{center}
\begin{tabular}{|l|c|c|l|}
\hline
\bf Key	& \bf Option	& \bf Type	& \bf Description \\
\hline
local	 & \bf -L	& K-bytes	& Size (Limit) of local stack \\
global	 & \bf -G	& K-bytes	& Size (Limit) of global stack \\
trail	 & \bf -T	& K-bytes	& Size (Limit) of trail stack \\
argument & \bf -A	& K-bytes	& Size (Limit) of argument stack \\
goal	 & \bf -g	& atom		& Initialisation goal \\
toplevel & \bf -t	& atom		& Prolog toplevel goal \\
init_file& \bf -f	& atom		& Personal initialisation file \\
\hline
autoload &		& bool		& If true, run autoload/0 first \\
map	 &	        & atom		& File containing info on dump \\
\hline
\end{tabular}
\end{center}

    \caption{Key = Value pairs for qsave_program/2}
    \label{tab:qsave-options}
\end{table}

The {\tt /bin/sh} script contains the following data:

\begin{enumerate}
    \item The {\bf shell script header} starts as:
\begin{code}
#!/bin/sh
#SAVE-VERSION=<num>
#PROLOG-VERSION=<num>
exec ${SWIPL-/path-to-emulator} -x $0 "$@"
\end{code}
    \item The {\bf settings} section contains the default values
	  for the various command line options.
    \item The {\bf predicates} section contains all predicates from
          the currently running system. Clauses of predicates defined as
	  {\em volatile} (see volatile/1) are {\bf not} saved.  Neither
	  are foreign predicates (see also below).
    \item The {\bf record} section contains the database records saved
          with recorda/3 and friends.  The current version saves records
	  using directives.
    \item The {\bf flag} section contains the global flags saved using
          the flag/3 predicate.  Flags are saved as directives.
    \item The {\bf feature} section contains all features that do not
	  originate from the emulator itself.  See set_feature/1.
    \item The {\bf import} section contains the imports as far as they
          are not handled by the auto-import system.  That is, an import
	  is stored if the module is {\tt user} or the module {\tt user}
	  contains a different definition as the one imported in the
	  target module.'
\end{enumerate}

Before writing the data to file, qsave_program/2 will run autoload/0 to
all required autoloading the system can discover.  See autoload/0.

Provided the application does not require any of the Prolog libraries to
be loaded at runtime, the only file from the SWI-Prolog development
environment required is the emulator itself.  The emulator may be built
in two flavours.  The default is the {\em development} emulator.  The 
{\em runtime} emulator is similar, but lacks the tracer. The stand-alone
program \index{chpl} {\tt chpl} may be used to change the default path
to the emulator.
.C qsave_program 1 +File
Equivalent to {\tt qsave_program(File, [])}.
.C autoload 0
Check the current Prolog program for predicates that are refered to, 
are undefined and have a definition in the Prolog library.  Load the
appropriate libraries.

This predicate is used by qsave_program/[1,2] to ensure the saved state
will not depend on one of the libraries. Autoload/0 will find all {\em
direct} references to predicates. It does not find predicates referenced
via meta-predicates. The predicate log/2 is defined in the
library(quintus) to provide a quintus compatible means to compute the
natural logarithm of a number. The following program will behave
correctly if its state is executed in an environment where the
library(quintus) is not available:

\begin{code}
logtable(From, To) :-
	From > To, !.
logtable(From, To) :-
	log(From, Value),
	format('~d~t~8|~2f~n', [From, Value]),
	F is From + 1,
	logtable(F, To).
\end{code}

However, the following implementation refers to log/2 through the
meta-predicate maplist/2.  Autoload will not be able to find the
reference.  This problem may be fixed either by loading the
module libtary(quintus) explicitely or use require/1 to tell the
system that the predicate log/2 is required by this module.

\begin{code}
logtable(From, To) :-
	findall(X, between(From, To, X), Xlist),
	maplist(log, Xlist, SineList),
	write_table(Xlist, SineList).

write_table([], []).
write_table([I|IT], [V|VT]) :-
	format('~d~t~8|~2f~n', [I, V]),
	write_table(IT, VT).
\end{code}
.P volatile +Name/Arity, ...
Declare that the clauses of specified predicates should {\bf not} be
saved to the program.  The volatile declaration is normally used to
avoid that the clauses of dynamic predicates that represent data for
the current session is saved in the state file.
.ED


\section{Limitations of qsave_program}

There are three areas that require special attention when using
qsave_program/[1,2].

\begin{itemize}
\item
If the program is an embedded Prolog application or uses the foreign
language interface, care has to be taken to restore the appropriate
foreign context. See section~\ref{sec:qforeign} for details.

\item
If the program uses directives (\verb$:- goal.$ lines) that perform
other actions then setting predicate attributes (dynamic, volatile,
etc.) or loading files (consult, etc.), the directive may need to be
prefixed with initialization/1.

\item
`Database references as returned by clause/3, recorded/3, etc.
are not preserved and may thus not be part of the database when saved.
\end{itemize}


\section{Runtimes and Foreign Code}

\label{sec:qforeign}
Some applications may need to use the foreign language interface.
Object code is by definition machine-dependent and thus cannot be
part of the saved program file.

To complicate the matter even furtherm there are various ways of
loading foreign code:

\begin{itemize}
    \tick{Using the library(shlib) predicates}
This is the preferred way of dealing with foreign code. It loads quickly
and ensures an acceptable level of indepedence between the versions of
the emulator and the foreign code loaded.  It works on Unix machines
supporting shared libraries and library functions to load them.  Most
modern Unixes satisfy this constraint.%
    \footnote{Linux with the old a.out format does {\bf not}}.
It also works on the Win32 platform: Windows-NT, '95 and Windows 3.1
running win32s.
    \tick{Static linking}
This mechanism works on all machines, but generally requires the same
C-compiler and linker to be used for the external code as is used to
build SWI-Prolog itself.  This mechanism is the preferred way if shared
libraries are not supported.
    \tick{Using load_foreign/2,5]}
Basically only works on Unix system supporting the a.out format
executables.  This mechanism is slow and non-portable.  It should be
avoided whenever possible.
\end{itemize}

To make a runtime executable that can run on multiple platforms one
must make runtime checks to find the correct way of linking.  Suppose
we have a source-file {\tt myextension} defining the installation
function {\tt install}.

If this file is compiled to a shared library, load_foreign_library/1
will load this library and call the installation function to initialise
the foreign code. If it is loaded as a static extension, define
install() as the predicate install/0:

\begin{boxed}\begin{code}
static foreign_t
pl_install()
{ install();

  PL_succeed;
}

PL_extension PL_extensions [] =
{
/*{ "name",	arity,  function,	PL_FA_<flags> },*/

  { "install",	0,	pl_install,	0 },
  { NULL,	0, 	NULL,		0 }	/* terminating line */
};
\end{code}\end{boxed}

Now, use the following Prolog code to load the foreign library:

\begin{boxed}\begin{code}
load_foreign_extensions :-
	current_predicate(install, install), !, % static loaded
	install.
load_foreign_extensions :-		        % shared library
	load_foreign_library(foreign(myextension)).

:- initialization load_foreign_extensions.
\end{code}\end{boxed}

The path alias {\tt foreign} is defined by file_search_path/2.  By
default it searches the directories $<$home$>$/lib/$<$arch$>$ and
$<$home$>$/lib.  The application can specify additional rules for
file_search_path/2.


\section{Finding Application files}

If your application uses files that are not part of the saved program
such as database files, configuration files, etc., the runtime version
has to be able to locate these files. The file_search_path/2 mechanism
in combination with the {\tt -p} command-line argument is the preferred
way to locate runtime files. The first step is to define an alias for
the toplevel directory of your application. We will call this directory
{\tt gnatdir} in our examples.

A good place for storing data associated with SWI-Prolog runtime systems
is below the emulator's home-directory.  {\tt swi} is a predefined alias
for this directory.  The following is a useful default definition for
the search path.

\begin{code}
user:file_search_path(gnatdir, swi(gnat)).
\end{code}

The application should locate all files using absolute_file_name.
Suppose gnatdir contains a file {\tt config.pl} to define local
configuration.  Then use the code below to load this file:

\begin{code}
configure_gnat :-
	(   absolute_file_name(gnatdir('config.pl'), ConfigFile)
	->  consult(ConfigFile)
	;   format(user_error, 'gnat: Cannot locate config.pl~n'),
	    halt(1)
	).
\end{code}

\section{Using chpl for Configuration Information}

\subsection{Changing the emulator of a runtime application}

The program chpl, may be used to manipulate the header of a SWI-Prolog
bootfile or state created with qsave_program/[1,2].

It will be used most commonly by the installer of a SWI-Prolog runtime
application to specify the path to the emulator. If the end-user decided
to install the SWI-Prolog runtime environment in

\begin{code}
/usr/local/lib/rt-pl-2.1.4
\end{code}

the gnat application can be told to use this emulator using:

\begin{code}
% /usr/local/lib/rtpl-2.1.4/bin/chpl -e /usr/local/lib/rt-pl-2.1.4/bin/pl gnat
\end{code}

Now, {\tt gnat} may be installed in any public or private directory for
binaries.


\subsection{Passing a path to the application}

Suppose the system administrator has installed the SWI-Prolog runtime
environment in {\tt /usr/local/lib/rt-pl-2.1.4}. A user wants to install
{\tt gnat}, but gnat will look for its configuration in {\tt
/usr/local/lib/rt-pl-2.1.4/gnat} where the user cannot write.

The user decides to install the gnat runtime files in
{\tt /users/bob/lib/gnat}.  For one-time usage, the user may decide
to start gnat using the command:

\begin{code}
% gnat -p gnatdir=/users/bob/lib/gnat
\end{code}

For a more widely used executable, this is not very comfortable.  The
user may decide to edit the shell-script part of gnat.  Upto the line
holding

\begin{code}
# End Header
\end{code}

gnat is a simple {\tt /bin/sh} script.  After this line, the file is
binary and may contain long lines.  Most editors are not capable of
editing such files.%
    \footnote{If you use GNU-Emacs, make sure {\tt
    require-final-newline} is set to {\tt nil}}
Instead of editing the file directly, the program {\tt chpl} may be
used to extract and replace the header of {\tt gnat}.  The following
editing sequence will work with any editor capable of editing ascii
files.

\begin{code}
% chpl -x gnat > gnat.hdr
% emacs gnat.hdr
% chpl -h gnat.hdr gnat
\end{code}

The header may be changed to the following to install gnat properly:

\begin{boxed}\begin{code}
#!/bin/sh
# SWI-Prolog version: 2.1.4
# SWI-Prolog save-version: 25
exec ${SWIPL-/usr/local/lib/rt-pl-2.1.4/bin/pl} -x $0 \
     -p gnatdir=/users/bob/lib/gnat "$@"
\end{code}\end{boxed}


\section{The Runtime Environment}

\subsection{The Runtime Emulator}

The sources may be used to built two versions of the emulator. By
default, the {\em development} emulator is built. This emulator contains
all features for interactive development of Prolog applications. If the
system is configured using {\tt --enable-runtime}, {\tt make} will
create a {\em runtime} version of the emulator. This emulator is
equivalent to the development version, except for the following
features:

\begin{itemize}
    \tick{No input editing}
The GNU library -lreadline that provides {\sc EMACS} compatible editing
of input lines will never be linked to the system.
    \tick{No tracer}
The tracer and all its options are removed, making the system a little
bit faster too.
    \tick{No profiler}
profile/3 and friends are not supported.  This saves some space and
provides a bit better performance.
    \tick{No interrupt}
Keyboard interrupt (Control-C normally) is not rebound and will normally
terminate the application.
    \tick{feature(runtime, true) succeeds}
This may be used to verify your application is running in the runtime
environment rather than the development environment.
    \tick{clause/[2,3] do not work on static predicates}
This feature inhibits listing your program.  It is only a very limited
protection however.
\end{itemize}

The following fragment is an example for building the runtime
environment in \verb|$HOME/lib/rt-pl-2.1.4|. If possible, the
shared-library interface should be configured to ensure it can serve a
large number of applications.

\begin{code}
% cd pl-2.1.4
% mkdir runtime
% cd runtime
% ../src/configure --enable-runtime --prefix=$HOME
% make
% make rt-install
\end{code}

The runtime directory contains the components listed below. This
directory may be tar'ed and shipped with your application.

\begin{center}
\begin{tabular}{|l|l|}
\hline
\tt README.RT		& Info on the runtime environment \\
\hline
\tt bin/pl		& The emulator itself \\
\tt bin/chpl		& The utility to change the runtime \\
\hline
\tt man/chpl.1		& Manual page for chpl \\
\tt man/pl.1		& Manual page for pl \\
\hline
\tt swipl		& pointer to the home directory (.) \\
\hline
\tt lib/		& directory for shared libraries \\
\verb$lib/<arch>/$	& machine-specific shared libraries \\
\hline
\end{tabular}
\end{center}
