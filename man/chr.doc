\chapter{CHR: Constraint Handling Rules} 		\label{sec:chr}

This chapter is written by Tom Schrijvers, K.U. Leuven, and adjustments by
Jan Wielemaker.

The CHR system of SWI-Prolog is the {\em K.U.Leuven CHR system}. The runtime
environment is written by Christian Holzbaur and Tom Schrijvers while the
compiler is written by Tom Schrijvers. Both are integrated with SWI-Prolog
and licensed under compatible conditions with permission from the authors.

The main reference for the K.U.Leuven CHR system is:
\begin{itemize}
\item T. Schrijvers, and B. Demoen, {\em The K.U.Leuven CHR System: Implementation
and Application}, First Workshop on Constraint Handling Rules: Selected
Contributions (Fr\"uhwirth, T. and Meister, M., eds.), pp. 1--5, 2004.
\end{itemize}

On the K.U.Leuven CHR website (\url{http://www.cs.kuleuven.be/\~{}toms/CHR/})
you can find more related papers, references and example programs. 

\section{Introduction}			\label{sec:chrintro}
%=====================

Constraint Handling Rules (CHR) is a committed-choice rule-based language
embedded in Prolog. It is designed for writing constraint solvers and is
particularly useful for providing application-specific constraints.
It has been used in many kinds of applications, like scheduling,
model checking, abduction, type checking among many others.

CHR has previously been implemented in other Prolog systems (SICStus,
Eclipse, Yap), Haskell and Java. This CHR system is based on the
compilation scheme and runtime environment of CHR in SICStus.

In this documentation we restrict ourselves to giving a short overview
of CHR in general and mainly focus on elements specific to this
implementation. For a more thorough review of CHR we refer the reader to
\cite{Freuhwirth:98}. More background on CHR can be found at
\cite{chrSite}.

In \secref{SyntaxAndSemantics} we present the syntax of CHR in Prolog and
explain informally its operational semantics. Next, \secref{practical}
deals with practical issues of writing and compiling Prolog programs
containing CHR. \Secref{debugging} explains the currently primitive CHR
debugging facilities. \Secref{predicates} provides a few useful predicates
to inspect the constraint store and \secref{examples} illustrates CHR with
two example programs. In \secref{sicstus-chr} some compatibility issues with
older versions of this system and SICStus' CHR system. Finally, \secref{guidelines} concludes with a few
practical guidelines for using CHR.


\section{Syntax and Semantics} 		\label{sec:SyntaxAndSemantics}
%=============================

\subsection{Syntax}
%-----------------

The syntax of CHR rules is the following:

\begin{code}
rules --> rule, rules.
rules --> [].

rule --> name, actual_rule, pragma, [atom('.')].

name --> atom, [atom('@')].
name --> [].

actual_rule --> simplification_rule.
actual_rule --> propagation_rule.
actual_rule --> simpagation_rule.

simplification_rule --> head, [atom('<=>')], guard, body.
propagation_rule --> head, [atom('==>')], guard, body.
simpagation_rule --> head, [atom('\')], head, [atom('<=>')], 
                     guard, body.

head --> constraints.

constraints --> constraint, constraint_id.
constraints --> constraint, constraint_id, [atom(',')], constraints.

constraint --> compound_term.

constraint_id --> [].
constraint_id --> [atom('#')], variable.
constraint_id --> [atom('#')], [atom('passive')] .

guard --> [].
guard --> goal, [atom('|')].

body --> goal.

pragma --> [].
pragma --> [atom('pragma')], actual_pragmas.

actual_pragmas --> actual_pragma.
actual_pragmas --> actual_pragma, [atom(',')], actual_pragmas.

actual_pragma --> [atom('passive(')], variable, [atom(')')].

\end{code}

Note that the guard of a rule may not contain any goal that binds a variable
in the head of the rule with a non-variable or with another variable in the
head of the rule. It may however bind variables that do not appear in the
head of the rule, e.g. an auxiliary variable introduced in the guard.

\subsection{Semantics}
%--------------------

In this subsection the operational semantics of CHR in Prolog are presented
informally. They do not differ essentially from other CHR systems.

When a constraint is called, it is considered an active constraint and
the system will try to apply the rules to it. Rules are tried and executed
sequentially in the order they are written. 

A rule is conceptually tried for an active constraint in the following
way. The active constraint is matched with a constraint in the head of
the rule. If more constraints appear in the head they are looked for
among the suspended constraints, which are called passive constraints in
this context. If the necessary passive constraints can be found and all
match with the head of the rule and the guard of the rule succeeds, then
the rule is committed and the body of the rule executed. If not all the
necessary passive constraint can be found, the matching fails or the
guard fails, then the body is not executed and the process of trying and
executing simply continues with the following rules. If for a rule,
there are multiple constraints in the head, the active constraint will
try the rule sequentially multiple times, each time trying to match with
another constraint.

This process ends either when the active constraint disappears, i.e.\ it
is removed by some rule, or after the last rule has been processed. In
the latter case the active constraint becomes suspended.

A suspended constraint is eligible as a passive constraint for an active
constraint. The other way it may interact again with the rules, is when
a variable appearing in the constraint becomes bound to either a non-variable
or another variable involved in one or more constraints. In that case the
constraint is triggered, i.e.\ it becomes an active constraint and all
the rules are tried.

\paragraph{Rule Types}
%- - - - - - - - - - 

There are three different kinds of rules, each with their specific semantics:

\begin{itemlist}
    \item [simplification]
The simplification rule removes the constraints in its head and calls its body.

    \item [propagation]
The propagation rule calls its body exactly once for the constraints in
its head.

    \item [simpagation]
The simpagation rule removes the constraints in its head after the
$\backslash$ and then calls its body. It is an optimization of
simplification rules of the form: \[constraints_1, constraints_2 <=>
constraints_1, body \] Namely, in the simpagation form: \[ constraints_1
\backslash constraints_2 <=> body \] The $\mathit{constraints}_1$
constraints are not called in the body.
\end{itemlist}

\paragraph{Rule Names}
%- - - - - - - - - - 
Naming a rule is optional and has no semantical meaning. It only functions
as documentation for the programmer.

\paragraph{Pragmas}
%- - - - - - - - -
The semantics of the pragmas are:

\begin{description}
    \termitem{passive}{Identifier}
The constraint in the head of a rule \arg{Identifier} can only match a
passive constraint in that rule.
There is an abbreviated syntax for this pragma. Instead of:
\begin{code}
                ..., c # Id, ... <=> ... pragma passive(Id)
\end{code}
you can also write 
\begin{code}
                ..., c # passive, ... <=> ...
\end{code}
\end{description}

Additional pragmas may be released in the future.


\paragraph{Options}
%- - - - - - - - -
It is possible to specify options that apply to all the CHR rules in the module.
Options are specified with the \texttt{chr_option/2} declaration:

\begin{code}
                :- chr_option(Option,Value).
\end{code}

and may appear in the file anywhere after the first constraints declaration.

Available options are:
\begin{description}
        \termitem{check_guard_bindings}{}
This option controls whether guards should be checked for (illegal) variable
bindings or not. Possible values for this option are \texttt{on}, to enable
the checks, and \texttt{off}, to disable the checks. If this option is on,
any guard fails when it binds a variable that appears in the head of the rule.
When the option is off (default), the behavior of a binding in the guard is undefined.

        \termitem{optimize}{}
This option controls the degree of optimization.
Possible values are \texttt{full}, to enable all available
optimizations, and \texttt{off} (default), to disable all optimizations.  
The default is derived from the SWI-Prolog flag \const{optimise}, where
\const{true} is mapped to \const{full}.  Therefore the command-line
option \cmdlineoption{-O} provides full CHR optimization.
If optimization is enabled, debugging must be disabled.

	\termitem{debug}{}
This options enables or disables the possibility to debug the CHR code.
Possible values are \texttt{on} (default) and \texttt{off}. See
\secref{debugging} for more details on debugging.  The default is
derived from the prolog flag \const{generate_debug_info}, which
is \const{true} by default.  See \cmdlineoption{-nodebug}.
If debugging is enabled, optimization must be disabled.

\end{description}
 
% The above mode, type_declaration and type_definition options are deprecated. 
% The new syntax is described below.

\section{CHR in SWI-Prolog Programs}		\label{sec:practical}
%===========================


\subsection{Embedding in Prolog Programs}

The CHR constraints defined in a \fileext{pl} file are
associated with a module. The default module is \const{user}. One should
never load different \fileext{pl} files with the same CHR module name.

\subsection{Constraint declaration}

Every constraint used in CHR rules has to be declared with a
chr_constraint/1 declaration by the {\em constraint
specifier}. For convenience multiple constraints may be declared at once with
the same \predref{chr_constraint}{1} declaration followed by a comma-separated
list of constraint specifiers.

A constraint specifier is, in its compact form, \texttt{$F$/$A$} where $F$ and $A$ are respectively
the functor name and arity of the constraint, e.g.: 

\begin{code}
:- chr_constraint foo/1.
:- chr_constraint bar/2, baz/3.
\end{code}

In its extended form, a constraint specifier is \texttt{$c$($A_1$,\ldots,$A_n$)}
where $c$ is the constraint's functor, $n$ its arity and the $A_i$ are argument
specifiers. An argument specifier is a mode, optionally followed by a type. E.g.
\begin{code}
:- chr_constraint get_value(+,?).
:- chr_constraint domain(?int,+list(int)), 
                   alldifferent(?list(int)).
\end{code}

\paragraph{Modes}

A mode is one of:
	\begin{description}
	\termitem{-}{} The corresponding argument of every occurrence
	of the constraint is always unbound.
	\termitem{+}{} The corresponding argument of every occurrence
	of the constraint is always ground.
	\termitem{?}{} The corresponding argument of every occurrence
	of the constraint can have any instantiation, which may change
	over time. This is the default value.
	\end{description}

\paragraph{Types}

A type can be a user-defined type or one of the built-in types. A type
comprises a (possibly infinite) set of values. The type declaration for a
constraint argument means that for every instance of that constraint the
corresponding argument is only ever bound to values in that set. It does not
state that the argument necessarily has to be bound to a value. 

The built-in types are:
	\begin{description}
	\termitem{int}{} The corresponding argument of every occurrence
	of the constraint is an integer number.
	\termitem{dense_int}{} The corresponding argument of every occurrence
	of the constraint is an integer that can be used as an array index.
	Note that if this argument takes values in $[0,n]$, the array takes
	$O(n)$ space.
	\termitem{float}{} \ldots a floating point number.
	\termitem{number}{} \ldots a number.
	\termitem{natural}{} \ldots a positive integer.
	\termitem{any}{} The corresponding argument of every occurrence
	of the constraint can have any type. This is the default value.
	\end{description}

User-defined types are algebraic data types, similar to those in Haskell
or the discriminated unions in Mercury.  An algebraic data type is defined using
\begin{code}
:- chr_type type ---> body. 
\end{code}
If the type term is a functor of arity zero
(i.e. one having zero arguments), it names a monomorphic type. Otherwise, it
names a polymorphic type; the arguments of the functor must be distinct type
variables. The body term is defined as a sequence of constructor definitions
separated by semi-colons.

Each constructor definition must be a functor whose arguments (if
any) are types. Discriminated union definitions must be transparent:
all type variables occurring in the body must also occur in the type.

Here are some examples of algebraic data type definitions:
\begin{code}
:- chr_type color ---> red ; blue ; yellow ; green.

:- chr_type tree --->  empty ; leaf(int) ; branch(tree, tree).

:- chr_type list(T) --->    [] ; [T | list(T)].

:- chr_type pair(T1, T2) ---> (T1 - T2).
\end{code}

Each algebraic data type definition introduces a distinct type. 
Two algebraic data types that have the same bodies are considered to be
distinct types (name equivalence). 

Constructors may be overloaded among different types: there may be any number
of constructors with a given name and arity, so long as they all have different
types. 

Aliases can be defined using ==. For example, if your program uses lists
of lists of integers, you can define an alias as follows:
\begin{code}
:- chr_type lli == list(list(int)).
\end{code}

\paragraph{Type Checking}

Currently two complementary forms of type checking are performed: 
\begin{enumerate}
\item Static type checking is always performed by the compiler. It is
      limited to CHR rule heads and CHR constraint calls in rule bodies.       

      Two kinds of type error are detected. The first is where a variable
      has to belong to two types. For example, in the program:
\begin{code}
:-chr_type foo ---> foo.
:-chr_type bar ---> bar.

:-chr_constraint abc(?foo).
:-chr_constraint def(?bar).

foobar @ abc(X) <=> def(X).
\end{code}
      the variable \texttt{X} has to be of both type \texttt{foo} and \texttt{bar}.
      This is reported by the type clash error:
      \begin{code}
CHR compiler ERROR:
    `--> Type clash for variable _G5398 in rule foobar:
                expected type foo in body goal def(_G5398, _G5448)
                expected type bar in head def(_G5448, _G5398)
\end{code}

      The second kind of error is where a functor is used that does not belong
      to the declared type. For example in: 
\begin{code}
:-chr_type foo ---> foo.
:-chr_type bar ---> bar.

:-chr_constraint abc(?foo).

foo @ abc(bar) <=> true.
\end{code}
in the head of the rule \texttt{bar} appears where something of type \texttt{foo}
is expected. This is reported as:
\begin{code}
CHR compiler ERROR:
    `--> Invalid functor in head abc(bar) of rule foo:
                found `bar',
                expected type `foo'!
\end{code}


      No runtime overhead is incurred in static type checking. 

\item Dynamic type checking checks at runtime, during program execution, 
      whether the arguments of CHR constraints respect their declared types.
      The \predref{when}{2} co-routining library is used to delay dynamic type
      checks until variables are instantiated.

      The kind of error detected by dynamic type checking is where a functor
      is used that does not belong to the declared type. E.g. for the program:
\begin{code}	
:-chr_type foo ---> foo.

:-chr_constraint abc(?foo).
\end{code}
      we get the following error in an erroneous query:
\begin{code}
?- abc(bar).
ERROR: Type error: `foo' expected, found `bar' (CHR Runtime Type Error)
\end{code}

      Dynamic type checking is weaker than static type checking in the sense
      that it only checks the particular program execution at hand rather than
      all possible executions. It is stronger in the sense that it tracks types
      throughout the whole program. 
	
      Note that it is enabled only in debug mode, as it incurs some (minor)
      runtime overhead.
\end{enumerate}

\subsection{Compilation}
%--------------------

The SWI-Prolog CHR compiler exploits term_expansion/2 rules to
translate the constraint handling rules to plain Prolog. These rules are
loaded from the library \pllib{chr}. They are activated if the compiled
file has the \fileext{chr} extension or after finding a declaration of
the format below.

\begin{code}
:- chr_constraint ...
\end{code}

It is advised to define CHR rules in a module file, where the module
declaration is immediately followed by including the library(chr) library
as exemplified below:

\begin{code}
:- module(zebra, [ zebra/0 ]).
:- use_module(library(chr)).

:- chr_constraint ...
\end{code}

Using this style CHR rules can be defined in ordinary Prolog .pl files and
the operator definitions required by CHR do not leak into modules where they
might cause conflicts.

\section{Debugging}			\label{sec:debugging}
%=================

The CHR debugging facilities are currently rather limited. Only tracing
is currently available. To use the CHR debugging facilities for a CHR
file it must be compiled for debugging. Generating debug info is
controlled by the CHR option \const{debug}, whose default is derived
from the SWI-Prolog flag \const{generate_debug_info}.  Therefore debug
info is provided unless the \cmdlineoption{-nodebug} is used.


\subsection{Ports}				\label{sec:chrports}
%===============

For CHR constraints the four standard ports are defined:

\begin{itemlist}
	\termitem{call}{}
A new constraint is called and becomes active.
	\termitem{exit}{}
An active constraint exits: it has either been inserted in the store after
trying all rules or has been removed from the constraint store.
	\termitem{fail}{}
An active constraint fails.
	\termitem{redo}{}
An active constraint starts looking for an alternative solution.
\end{itemlist}

In addition to the above ports, CHR constraints have five additional
ports:

\begin{itemlist}
	\termitem{wake}{}
A suspended constraint is woken and becomes active.
	\termitem{insert}{}
An active constraint has tried all rules and is suspended in
the constraint store.
	\termitem{remove}{}
An active or passive constraint is removed from the constraint
store.
\termitem{try}{}
	An active constraints tries a rule with possibly
	some passive constraints. The try port is entered
	just before committing to the rule.
\termitem{apply}{}
	An active constraints commits to a rule with possibly
	some passive constraints. The apply port is entered
	just after committing to the rule.
\end{itemlist}

\subsection{Tracing}
%=================

Tracing is enabled with the chr_trace/0 predicate
and disabled with the chr_notrace/0 predicate.

When enabled the tracer will step through the \const{call},
\const{exit}, \const{fail}, \const{wake} and \const{apply} ports,
accepting debug commands, and simply write out the other ports.

The following debug commands are currently supported:

\begin{verbatim}
        CHR debug options:

                <cr>    creep           c       creep
		s	skip
		g	ancestors
                n       nodebug
		b	break
                a       abort
                f       fail
                ?       help            h       help
\end{verbatim}

Their meaning is:

\begin{itemlist}
	\termitem{creep}{}
Step to the next port.
	\termitem{skip}{}
Skip to exit port of this call or wake port.
	\termitem{ancestors}{}
Print list of ancestor call and wake ports.
	\termitem{nodebug}{}
Disable the tracer.
	\termitem{break}{}
Enter a recursive Prolog top-level.  See break/0.
	\termitem{abort}{}
Exit to the top-level.  See abort/0.
	\termitem{fail}{}
Insert failure in execution.
	\termitem{help}{}
Print the above available debug options.
\end{itemlist}

\subsection{CHR Debugging Predicates} 		\label{sec:predicates}
%====================================

The \pllib{chr} module contains several predicates that allow
inspecting and printing the content of the constraint store.

\begin{description}
    \predicate{chr_trace}{0}{}
Activate the CHR tracer.  By default the CHR tracer is activated and
deactivated automatically by the Prolog predicates trace/0 and
notrace/0.

    \predicate{chr_notrace}{0}{}
De-activate the CHR tracer.  By default the CHR tracer is activated and
deactivated automatically by the Prolog predicates trace/0 and
notrace/0.
    
    \predicate{chr_leash}{1}{+Spec}
Define the set of CHR ports on which the CHR tracer asks for user
intervention (i.e.\ stops). \arg{Spec} is either a list of ports as
defined in \secref{chrports} or a predefined `alias'. Defined aliases
are: \const{full} to stop at all ports, \const{none} or \const{off} to
never stop, and \const{default} to stop at the \const{call},
\const{exit}, \const{fail}, \const{wake} and \const{apply} ports.
See also leash/1.

    \predicate{chr_show_store}{1}{+Mod}
Prints all suspended constraints of module \arg{Mod} to the standard
output. This predicate is automatically called by the SWI-Prolog top-level at
the end of each query for every CHR module currently loaded.  The prolog-flag
\const{chr_toplevel_show_store} controls whether the top-level shows the
constraint stores. The value \const{true} enables it.  Any other value
disables it.


\end{description}


\section{Examples}			\label{sec:examples}
%================

Here are two example constraint solvers written in CHR.

\begin{itemize}
    \item
The program below defines a solver with one constraint, 
leq/2, which is a less-than-or-equal constraint, also known as
a partial order constraint.

\begin{code}
:- module(leq,[leq/2]).
:- use_module(library(chr)).

:- chr_constraint leq/2.
reflexivity  @ leq(X,X) <=> true.
antisymmetry @ leq(X,Y), leq(Y,X) <=> X = Y.
idempotence  @ leq(X,Y) \ leq(X,Y) <=> true.
transitivity @ leq(X,Y), leq(Y,Z) ==> leq(X,Z).
\end{code}

When the above program is saved in a file and loaded in SWI-Prolog, you can
call the leq/2 constraints in a query, e.g.:
\begin{code}
?- leq(X,Y), leq(Y,Z).
leq(_G23837, _G23841)
leq(_G23838, _G23841)
leq(_G23837, _G23838)

X = _G23837{leq = ...}
Y = _G23838{leq = ...}
Z = _G23841{leq = ...}

Yes
\end{code}
When the query succeeds, the SWI-Prolog top-level prints the content of the
CHR constraint store and displays the bindings generate during the query. Some of the query variables may have been bound to
attributed variables, as you see in the above example.

    \item
The program below implements a simple finite domain
constraint solver.

\begin{code}
:- module(dom,[dom/2]).
:- use_module(library(chr)).

:- chr_constraint dom(?int,+list(int)). 
:- chr_type list(T) ---> [] ; [T|list(T)].

dom(X,[]) <=> fail.
dom(X,[Y]) <=> X = Y.
dom(X,L) <=> nonvar(X) | memberchk(X,L).
dom(X,L1), dom(X,L2) <=> intersection(L1,L2,L3), dom(X,L3).
\end{code}

When the above program is saved in a file and loaded in SWI-Prolog, you can
call the dom/2 constraints in a query, e.g.:

\begin{code}	
?- dom(A,[1,2,3]), dom(A,[3,4,5]).

A = 3

Yes
\end{code}
	
\end{itemize}

\section{Backwards Compatibility} 		\label{sec:sicstus-chr}
%==================

There are small differences between the current K.U.Leuven CHR system
in SWI-Prolog, older versions of the same system and SICStus' CHR system.

The current system maps old syntactic elements onto new ones and ignores a
number of no longer required elements. However, for each a {\em deprecated}
warning is issued. You are strongly urged to replace or remove deprecated
features.

Besides differences in available options and pragmas, the following differences
should be noted:

\begin{itemlist}
        \item [The constraints/1 declaration]
This declaration is deprecated. It has been replaced with the
chr_constraint/1 declaration.

        \item [The option/2 declaration]
This declaration is deprecated. It has been replaced with the
chr_option/2 declaration.

        \item [The handler/1 declaration]
In SICStus every CHR module requires a handler/1
declaration declaring a unique handler name. This declaration is valid
syntax in SWI-Prolog, but will have no effect. A warning will be given
during compilation.

        \item [The rules/1 declaration]
In SICStus, for every CHR module it is possible to only enable a subset
of the available rules through the rules/1 declaration. The
declaration is valid syntax in SWI-Prolog, but has no effect. A
warning is given during compilation.

	\item [Guard bindings]
The \texttt{check_guard_bindings} option only turns invalid calls to
unification into failure. In SICStus this option does more: it intercepts
instantiation errors from Prolog built-ins such as is/2 and
turns them into failure. In SWI-Prolog, we do not go this far, as we like
to separate concerns more. The CHR compiler is aware of the CHR code, the Prolog
system and programmer should be aware of the appropriate meaning of the
Prolog goals used in guards and bodies of CHR rules.
\end{itemlist}


\section{Programming Tips and Tricks} 			\label{sec:guidelines}
%==================

In this section we cover several guidelines on how to use CHR to write
constraint solvers and how to do so efficiently.

\begin{itemlist}

   \item [Check guard bindings yourself]
It is considered bad practice to write guards that bind variables of 
the head and to rely on the system to detect this at runtime. It is
inefficient and obscures the working of the program.

    \item [Set semantics]
The CHR system allows the presence of identical constraints, i.e.
multiple constraints with the same functor, arity and arguments. For
most constraint solvers, this is not desirable: it affects efficiency
and possibly termination. Hence appropriate simpagation rules should be
added of the form: \[ constraint \backslash constraint <=> true \]

    \item [Multi-headed rules]
Multi-headed rules are executed more efficiently when the constraints
share one or more variables.

    \item [Mode and type declarations]
Provide mode and type declarations to get more efficient program execution.
Make sure to disable debug (-nodebug) and enable optimization (-O).

    \item [Compile once, run many times]
Does consulting your CHR program take a long time in SWI-Prolog? Probably
it takes the CHR compiler a long time to compile the CHR rules into Prolog
code. When you disable optimizations the CHR compiler will be a lot quicker,
but you may loose performance. Alternatively, you can just use SWI-Prolog's
qcompile/1 to generate a \fileext{qlf} file once from your
\fileext{pl} file. This \fileext{qlf} contains the generated code of the
CHR compiler (be it in a binary format). When you consult the \fileext{qlf}
file, the CHR compiler is not invoked and consultation is much faster.
\end{itemlist}

\section{Compiler Errors and Warnings} 			\label{sec:errors}
%==================

In this section we summarize the most important error and warning messages
of the CHR compiler.

\subsection{CHR Compiler Errors}

\begin{description}
\item[Type clash] for variable ... in rule ...

	This error indicates an inconsistency between declared types;
	a variable should belong to two types. See static type checking.

\item[Invalid functor] in head ... of rule ...

	This error indicates an inconsistency between a declared type
	and the use of a functor in a rule. See static type checking.

\item[Cyclic alias] definition: ... == ...

	You have defined a type alias in terms of itself, either
	directly or indirectly.

\item[Ambiguous type aliases]

	You have defined two overlapping type aliases.

\item[Multiple definitions] for type

	You have defined the same type multiple times.

\item[Non-ground type] in constraint definition: ...

	You have declared a non-ground type for a constraint argument.

\item[Could not find type definition] for ...

	You have used an undefined type in a type declaration.

\item[Illegal mode/type declaration]

	You have used invalid syntax in a constraint declaration.	

\item[Constraint multiply defined]

	There is more than one declaration for the same constraint.

\item[Undeclared constraint] ... in head of ...

	You have used an undeclared constraint in the head of a rule.
	This often indicates a misspelled constrained name or wrong
	number of arguments.

\item[Invalid pragma] ... in ... Pragma should not be a variable.

	You have used a variable as a pragma in a rule. This is not
	allowed.

\item[Invalid identifier] ... in pragma passive in ...

	You have used an identifier in a passive pragma that
	does not correspond to an identifier in the head of the rule.
	Likely the identifier name is misspelled.

\item[Unknown pragma] ... in ...

	You have used an unknown pragma in a rule. Likely the
	pragma is misspelled or not supported.

\item[Something unexpected] happened in the CHR compiler

	You have most likely bumped into a bug in the CHR compiler.
	Please contact Tom Schrijvers to notify him of this error.

\end{description}
