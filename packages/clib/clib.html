<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog C-library</TITLE><STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white"> 

<P>
<DIV class="title">SWI-Prolog C-library</DIV>
<DIV class="author">Jan Wielemaker <BR>
HCS, <BR>
University of Amsterdam <BR>
The Netherlands <BR>
E-mail: <A class="url" href="mailto:wielemak@science.uva.nl">wielemak@science.uva.nl</A></DIV>
<DIV class="abstract">
<DIV class="abstract-title">Abstract</DIV> This document describes 
commonly used foreign language extensions to
<A class="url" href="http://www.swi-prolog.org">SWI-Prolog</A> 
distributed as a package known under the name <EM>clib</EM>. The package 
defines a number of Prolog libraries with accompagnying foreign 
libraries.

<P>On Windows systems, the <CODE>library(unix)</CODE> library can only 
be used if the whole SWI-Prolog suite is compiled using
<A class="url" href="http://www.cygwin.com">Cywin</A>. The <CODE>library(crypt)</CODE> 
library does not support DES encryption. The other libraries have been 
ported to native Windows.
</DIV>

<H1><A NAME="document-contents">Table of Contents</A></H1>

<DIV class="toc">
<DIV class="toc-h2"><A class="sec" href="#sec:1"><SPAN class="sec-nr">1</SPAN> <SPAN class="sec-title">Introduction</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:2"><SPAN class="sec-nr">2</SPAN> <SPAN class="sec-title">Unix 
Process manipulation library</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:3"><SPAN class="sec-nr">3</SPAN> <SPAN class="sec-title">File 
manipulation library</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:4"><SPAN class="sec-nr">4</SPAN> <SPAN class="sec-title">Socket 
library</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.1"><SPAN class="sec-nr">4.1</SPAN> <SPAN class="sec-title">Server 
applications</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.2"><SPAN class="sec-nr">4.2</SPAN> <SPAN class="sec-title">Client 
applications</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.3"><SPAN class="sec-nr">4.3</SPAN> <SPAN class="sec-title">The 
stream_pool library</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.4"><SPAN class="sec-nr">4.4</SPAN> <SPAN class="sec-title">UDP 
protocol support</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:5"><SPAN class="sec-nr">5</SPAN> <SPAN class="sec-title">CGI 
Support library</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:5.1"><SPAN class="sec-nr">5.1</SPAN> <SPAN class="sec-title">Some 
considerations</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:6"><SPAN class="sec-nr">6</SPAN> <SPAN class="sec-title">MIME 
decoding library</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:7"><SPAN class="sec-nr">7</SPAN> <SPAN class="sec-title">Password 
encryption library</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:8"><SPAN class="sec-nr">8</SPAN> <SPAN class="sec-title">SHA1 
and SHA2 Secure Hash Algorithms</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:8.1"><SPAN class="sec-nr">8.1</SPAN> <SPAN class="sec-title">License 
terms</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:9"><SPAN class="sec-nr">9</SPAN> <SPAN class="sec-title">Memory 
files</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:10"><SPAN class="sec-nr">10</SPAN> <SPAN class="sec-title">Time 
and alarm library</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:11"><SPAN class="sec-nr">11</SPAN> <SPAN class="sec-title">Limiting 
process resources</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:12"><SPAN class="sec-nr">12</SPAN> <SPAN class="sec-title">Installation</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:12.1"><SPAN class="sec-nr">12.1</SPAN> <SPAN class="sec-title">Unix 
systems</SPAN></A></DIV>
</DIV>

<P>

<H2><A NAME="sec:1"><SPAN class="sec-nr">1</SPAN> <SPAN class="sec-title">Introduction</SPAN></A></H2>

<P>Many useful facilities offered by one or more of the operating 
systems supported by SWI-Prolog are not supported by the SWI-Prolog 
kernel distribution. Including these would enlarge the <EM>footprint</EM> 
and complicate portability matters while supporting only a limited part 
of the user-community.

<P>This document describes <CODE>library(unix)</CODE> to deal with the 
Unix process API,
<CODE>library(socket)</CODE> to deal with inet-domain TCP and UDP 
sockets, <CODE>library(cgi)</CODE> to deal with getting CGI form-data if 
SWI-Prolog is used as a CGI scripting language, <CODE>library(crypt)</CODE> 
to provide password encryption and verification, <CODE>library(sha)</CODE> 
providing cryptographic hash functions and
<CODE>library(memfile)</CODE> providing in-memorty pseudo files.

<H2><A NAME="sec:2"><SPAN class="sec-nr">2</SPAN> <SPAN class="sec-title">Unix 
Process manipulation library</SPAN></A></H2>

<P>The <CODE>library(unix)</CODE> library provides the commonly used 
Unix primitives to deal with process management. These primitives are 
useful for many tasks, including server management, parallel 
computation, exploiting and controlling other processes, etc.

<P>The predicates are modelled closely after their native Unix 
counterparts. Higher-level primitives, especially to make this library 
portable to non-Unix systems are desirable. Using these primitives and 
considering that process manipulation is not a very time-critical 
operation we anticipate these libraries to be developed in Prolog.

<DL>
<DT class="pubdef"><A NAME="fork/1"><STRONG>fork</STRONG>(<VAR>-Pid</VAR>)</A></DT>
<DD class="defbody">
Clone the current process into two branches. In the child, <VAR>Pid</VAR> 
is unified to <CODE>child</CODE>. In the original process, <VAR>Pid</VAR> 
is unified to the process identifier of the created child. Both parent 
and child are fully functional Prolog processes running the same 
program. The processes share open I/O streams that refer to Unix native 
streams, such as files, sockets and pipes. Data is not shared, though on 
most Unix systems data is initially shared and duplicated only if one of 
the programs attempts to modify the data.

<P>Unix <B>fork()</B> is the only way to create new processes and <A NAME="idx:fork2:1"></A><SPAN class="pred-ext">fork/2</SPAN> 
is a simple direct interface to it.</DD>
<DT class="pubdef"><A NAME="exec/1"><STRONG>exec</STRONG>(<VAR>+Command(...Args...)</VAR>)</A></DT>
<DD class="defbody">
Replace the running program by starting <VAR>Command</VAR> using the 
given commandline arguments. Each command-line argument must be atomic 
and is converted to a string before passed to the Unix call <B>execvp()</B>.

<P>Unix <B>exec()</B> is the only way to start an executable file 
executing. It is commonly used together with <A NAME="idx:fork1:2"></A><A class="pred" href="#fork/1">fork/1</A>. 
For example to start <B>netscape</B> on an URL in the background, do:

<PRE class="code">
run_netscape(URL) :-
        (    fork(child),
             exec(netscape(URL))
        ;    true
        ).
</PRE>

<P>Using this code, netscape remains part of the process-group of the 
invoking Prolog process and Prolog does not wait for netscape to 
terminate. The predicate <A NAME="idx:wait2:3"></A><A class="pred" href="#wait/2">wait/2</A> 
allows waiting for a child, while
<A NAME="idx:detachIO0:4"></A><A class="pred" href="#detach_IO/0">detach_IO/0</A> 
disconnects the child as a deamon process.</DD>
<DT class="pubdef"><A NAME="wait/2"><STRONG>wait</STRONG>(<VAR>-Pid, 
-Status</VAR>)</A></DT>
<DD class="defbody">
Wait for a child to change status. Then report the child that changed 
status as well as the reason. <VAR>Status</VAR> is unified with
<CODE>exited(ExitCode)</CODE> if the child with pid <VAR>Pid</VAR> was 
terminated by calling <B>exit()</B> (Prolog <A NAME="idx:halt01:5"></A><SPAN class="pred-ext">halt/[0,1]</SPAN>). <VAR>ExitCode</VAR> 
is the return=status. <VAR>Status</VAR> is unified with <CODE>signaled(Signal)</CODE> 
if the child died due to a software interrupt (see <A NAME="idx:kill2:6"></A><A class="pred" href="#kill/2">kill/2</A>). <VAR>Signal</VAR> 
contains the signal number. Finally, if the process suspended execution 
due to a signal, <VAR>Status</VAR> is unified with <CODE>stopped(Signal)</CODE>.</DD>
<DT class="pubdef"><A NAME="kill/2"><STRONG>kill</STRONG>(<VAR>+Pid, 
+Signal</VAR>)</A></DT>
<DD class="defbody">
Deliver a software interrupt to the process with identifier <VAR>Pid</VAR> 
using software-interrupt number <VAR>Signal</VAR>. See also <A NAME="idx:onsignal2:7"></A><SPAN class="pred-ext">on_signal/2</SPAN>. 
The meaning of the signal numbers can be found in the Unix manual.<SUP class="fn">1<SPAN class="fn-text">kill/2 
should support interrupt-names as well</SPAN></SUP>.</DD>
<DT class="pubdef"><A NAME="pipe/2"><STRONG>pipe</STRONG>(<VAR>-InSream, 
-OutStream</VAR>)</A></DT>
<DD class="defbody">
Create a communication-pipe. This is normally used to make a child 
communicate to its parent. After <A NAME="idx:pipe2:8"></A><A class="pred" href="#pipe/2">pipe/2</A>, 
the process is cloned and, depending on the desired direction, both 
processes close the end of the pipe they do not use. Then they use the 
remaining stream to communicate. Here is a simple example:

<PRE class="code">
:- use_module(library(unix)).

fork_demo(Result) :-
        pipe(Read, Write),
        fork(Pid),
        (   Pid == child
        -&gt;  close(Read),
            format(Write, '~q.~n',
                   [hello(world)]),
            flush_output(Write),
            halt
        ;   close(Write),
            read(Read, Result),
            close(Read)
        ).
</PRE>

</DD>
<DT class="pubdef"><A NAME="dup/2"><STRONG>dup</STRONG>(<VAR>+FromStream, 
+ToStream</VAR>)</A></DT>
<DD class="defbody">
Interface to Unix dup2(), copying the underlying filedescriptor and thus 
making both streams point to the same underlying object. This is 
normally used together with <A NAME="idx:fork1:9"></A><A class="pred" href="#fork/1">fork/1</A> 
and <A NAME="idx:pipe2:10"></A><A class="pred" href="#pipe/2">pipe/2</A> 
to talk to an external program that is designed to communicate using 
standard I/O.

<P>Both <VAR>FromStream</VAR> and <VAR>ToStream</VAR> either refer to a 
Prolog stream or an integer descriptor number to refer directly to OS 
descriptors. See also <CODE>demo/pipe.pl</CODE> in the 
source-distribution of this package.</DD>
<DT class="pubdef"><A NAME="detach_IO/0"><STRONG>detach_IO</STRONG></A></DT>
<DD class="defbody">
This predicate is intended to create Unix deamon-processes. It preforms 
two actions. First of all, the I/O streams <CODE>user_input</CODE>,
<CODE>user_output</CODE> and <CODE>user_error</CODE> are closed and 
rebound to a Prolog stream that returns end-of-file on any attempt to 
read and starts writing to a file named <CODE>/tmp/pl-out.pid</CODE> 
(where &lt;<VAR>pid</VAR>&gt; is the process-id of the calling Prolog) 
on any attempt to write. This file is opened only if there is data 
available. This is intended for debugging purposes.<SUP class="fn">2<SPAN class="fn-text">More 
subtle handling of I/O, especially for debugging is required: 
communicate with the syslog deamon and optionally start a debugging 
dialog on a newly created (X-)terminal should be considered.</SPAN></SUP> 
Finally, the process is detached from the current process-group and its 
controlling terminal.
</DD>
</DL>

<H2><A NAME="sec:3"><SPAN class="sec-nr">3</SPAN> <SPAN class="sec-title">File 
manipulation library</SPAN></A></H2>

<P>The <CODE>library(files)</CODE> library provides additional 
operations on files from SWI-Prolog. It is currently very incomplete.

<DL>
<DT class="pubdef"><A NAME="set_time_file/3"><STRONG>set_time_file</STRONG>(<VAR>+File, 
-OldTimes, +NewTimes</VAR>)</A></DT>
<DD class="defbody">
Query and set POSIX time attributes of a file. Both <VAR>OldTimes</VAR> 
and <VAR>NewTimes</VAR> are lists of option-terms. Times are represented 
in SWI-Prolog's standard floating point numbers. New times may be 
specified as <CODE>now</CODE> to indicate the current time. Defined 
options are:

<DL>
<DT><STRONG>access</STRONG>(<VAR>Time</VAR>)</DT>
<DD class="defbody">
Describes the time of last access of the file. This value can be read 
and written.</DD>
<DT><STRONG>modified</STRONG>(<VAR>Time</VAR>)</DT>
<DD class="defbody">
Describes the time the contents of the file was last modified. This 
value can be read and written.</DD>
<DT><STRONG>changed</STRONG>(<VAR>Time</VAR>)</DT>
<DD class="defbody">
Describes the time the file-structure itself was changed by adding 
(link()) or removing (unlink()) names.
</DD>
</DL>

<P>Here are some example queries. The first retrieves the access-time, 
while the second sets the last-modified time to the current time.

<PRE class="code">
?- set_time_file(foo, [acess(Access)], []).
?- set_time_file(foo, [], [modified(now)]).
</PRE>

<P></DD>
</DL>

<H2><A NAME="sec:4"><SPAN class="sec-nr">4</SPAN> <SPAN class="sec-title">Socket 
library</SPAN></A></H2>

<P>The <CODE>library(socket)</CODE> library provides TCP and UDP 
inet-domain sockets from SWI-Prolog, both client and server-side 
communication. The interface of this library is very close to the Unix 
socket interface, also supported by the MS-Windows <EM>winsock</EM> API. 
SWI-Prolog applications that wish to communicate with multiple sources 
have three options:

<P><OL>
<LI>Use I/O multiplexing based on <A NAME="idx:waitforinput3:11"></A><SPAN class="pred-ext">wait_for_input/3</SPAN>. 
On Windows systems this can only be used for sockets, not for general 
(device-) file handles.
<LI>Use multiple threads, handling either a single blocking socket or a 
pool using I/O multiplexing as above.
<LI>Using XPCE's class <B>socket</B> which synchronises socket events in 
the GUI event-loop.
</OL>

<DL>
<DT class="pubdef"><A NAME="tcp_socket/1"><STRONG>tcp_socket</STRONG>(<VAR>-SocketId</VAR>)</A></DT>
<DD class="defbody">
Creates an <CODE>INET</CODE>-domain stream-socket and unifies an 
identifier to it with <VAR>SocketId</VAR>. On MS-Windows, if the socket 
library is not yet initialised, this will also initialise the library.</DD>
<DT class="pubdef"><A NAME="tcp_close_socket/1"><STRONG>tcp_close_socket</STRONG>(<VAR>+SocketId</VAR>)</A></DT>
<DD class="defbody">
Closes the indicated socket, making <VAR>SocketId</VAR> invalid. 
Normally, sockets are closed by closing both stream handles returned by
<A NAME="idx:opensocket3:12"></A><SPAN class="pred-ext">open_socket/3</SPAN>. 
There are two cases where <A NAME="idx:tcpclosesocket1:13"></A><A class="pred" href="#tcp_close_socket/1">tcp_close_socket/1</A> 
is used because there are no stream-handles:

<P>
<UL>
<LI>After <A NAME="idx:tcpaccept3:14"></A><A class="pred" href="#tcp_accept/3">tcp_accept/3</A>, 
the server does a <A NAME="idx:fork1:15"></A><A class="pred" href="#fork/1">fork/1</A> 
to handle the client in a sub-process. In this case the accepted socket 
is not longer needed from the main server and must be discarded using <A NAME="idx:tcpclosesocket1:16"></A><A class="pred" href="#tcp_close_socket/1">tcp_close_socket/1</A>.
<LI>If, after discovering the connecting client with <A NAME="idx:tcpaccept3:17"></A><A class="pred" href="#tcp_accept/3">tcp_accept/3</A>, 
the server does not want to accept the connection, it should discard the 
accepted socket immediately using <A NAME="idx:tcpclosesocket1:18"></A><A class="pred" href="#tcp_close_socket/1">tcp_close_socket/1</A>.
</UL>
</DD>
<DT class="pubdef"><A NAME="tcp_open_socket/3"><STRONG>tcp_open_socket</STRONG>(<VAR>+SocketId, 
-InStream, -OutStream</VAR>)</A></DT>
<DD class="defbody">
Open two SWI-Prolog I/O-streams, one to deal with input from the socket 
and one with output to the socket. If <A NAME="idx:tcpbind2:19"></A><A class="pred" href="#tcp_bind/2">tcp_bind/2</A> 
has been called on the socket. <VAR>OutSream</VAR> is useless and will 
not be created. After closing both <VAR>InStream</VAR> and <VAR>OutSream</VAR>, 
the socket itself is discarded.</DD>
<DT class="pubdef"><A NAME="tcp_bind/2"><STRONG>tcp_bind</STRONG>(<VAR>+Socket, 
?Port</VAR>)</A></DT>
<DD class="defbody">
Bind the socket to <VAR>Port</VAR> on the current machine. This 
operation, together with <A NAME="idx:tcplisten2:20"></A><A class="pred" href="#tcp_listen/2">tcp_listen/2</A> 
and <A NAME="idx:tcpaccept3:21"></A><A class="pred" href="#tcp_accept/3">tcp_accept/3</A> 
implement the <EM>server</EM>-side of the socket interface. If <VAR>Port</VAR> 
is unbound, the system picks an arbitrary free port and unifies <VAR>Port</VAR> 
with the selected port number.</DD>
<DT class="pubdef"><A NAME="tcp_listen/2"><STRONG>tcp_listen</STRONG>(<VAR>+Socket, 
+Backlog</VAR>)</A></DT>
<DD class="defbody">
Tells, after <A NAME="idx:tcpbind2:22"></A><A class="pred" href="#tcp_bind/2">tcp_bind/2</A>, 
the socket to listen for incoming requests for connections. <VAR>Backlog</VAR> 
indicates how many pending connection requests are allowed. Pending 
requests are requests that are not yet acknowledged using <A NAME="idx:tcpaccept3:23"></A><A class="pred" href="#tcp_accept/3">tcp_accept/3</A>. 
If the indicated number is exceeded, the requesting client will be 
signalled that the service is currently not available. A suggested 
default value is 5.</DD>
<DT class="pubdef"><A NAME="tcp_accept/3"><STRONG>tcp_accept</STRONG>(<VAR>+Socket, 
-Slave, -Peer</VAR>)</A></DT>
<DD class="defbody">
This predicate waits on a server socket for a connection request by a 
client. On success, it creates a new socket for the client and binds the 
identifier to <VAR>Slave</VAR>. <VAR>Peer</VAR> is bound to the 
IP-address of the client.</DD>
<DT class="pubdef"><A NAME="tcp_connect/2"><STRONG>tcp_connect</STRONG>(<VAR>+Socket, 
+Host:+Port</VAR>)</A></DT>
<DD class="defbody">
Client-interface to connect a socket to a given <VAR>Port</VAR> on a 
given
<VAR>Host</VAR>. After successful completion, <A NAME="idx:tcpopensocket3:24"></A><A class="pred" href="#tcp_open_socket/3">tcp_open_socket/3</A> 
can be used to create I/O-Streams to the remote socket.</DD>
<DT class="pubdef"><A NAME="tcp_setopt/2"><STRONG>tcp_setopt</STRONG>(<VAR>+Socket, 
+Option</VAR>)</A></DT>
<DD class="defbody">
Set options on the socket. Defined options are:

<DL>
<DT><STRONG>reuseaddr</STRONG></DT>
<DD class="defbody">
Allow servers to reuse a port without the system being completely sure 
the port is no longer in use.</DD>
<DT><STRONG>broadcast</STRONG></DT>
<DD class="defbody">
UDP sockets only: broadcast the package to all addresses matching the 
address. The address is normally the address of the local subnet (i.e. 
192.168.1.255). See <A NAME="idx:udpsend4:25"></A><A class="pred" href="#udp_send/4">udp_send/4</A>.</DD>
<DT><STRONG>dispatch</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
In GUI environments (using XPCE or the Windows plwin.exe executable) 
this flags defines whether or not any events are dispatched on behalf of 
the user interface. Default is <CODE>true</CODE>. Only very specific 
situations require setting this to <CODE>false</CODE>.
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="tcp_fcntl/3"><STRONG>tcp_fcntl</STRONG>(<VAR>+Stream, 
+Action, ?Argument</VAR>)</A></DT>
<DD class="defbody">
Interface to the Unix <B>fcntl()</B> call. Currently only suitable to 
deal switch stream to non-blocking mode using:

<PRE class="code">
        ...
        tcp_fcntl(Stream, setfl. nonblock),
        ...
</PRE>

<P>As of SWI-Prolog 3.2.4, handling of non-blocking stream is supported. 
An attempt to read from a non-blocking stream returns -1 (or
<CODE>end_of_file</CODE> for <A NAME="idx:read1:26"></A><SPAN class="pred-ext">read/1</SPAN>), 
but <A NAME="idx:atendofstream1:27"></A><SPAN class="pred-ext">at_end_of_stream/1</SPAN> 
fails. On actual end-of-input, <A NAME="idx:atendofstream1:28"></A><SPAN class="pred-ext">at_end_of_stream/1</SPAN> 
succeeds.</DD>
<DT class="pubdef"><A NAME="tcp_host_to_address/2"><STRONG>tcp_host_to_address</STRONG>(<VAR>?HostName, 
?Address</VAR>)</A></DT>
<DD class="defbody">
Translate between a machines host-name and it's (IP-)address. If
<VAR>HostName</VAR> is an atom, it is resolved using
<B>gethostbyname()</B> and the IP-number is unified to <VAR>Address</VAR> 
using a term of the format <CODE>ip(Byte1, Byte2, Byte3, Byte4)</CODE>. 
Otherwise, if <VAR>Address</VAR> is bound to a ip/4 term, it is resolved 
by <B>gethostbyaddr()</B> and the canonical hostname is unified with <VAR>HostName</VAR>.</DD>
<DT class="pubdef"><A NAME="gethostname/1"><STRONG>gethostname</STRONG>(<VAR>-Hostname</VAR>)</A></DT>
<DD class="defbody">
Return the official fully qualified name of this host. This is achieved 
by calling gethostname() followed by gethostbyname() and return the 
official name of the host (<CODE>h_name</CODE>) of the structure 
returned by the latter function.
</DD>
</DL>

<H3><A NAME="sec:4.1"><SPAN class="sec-nr">4.1</SPAN> <SPAN class="sec-title">Server 
applications</SPAN></A></H3>

<P>The typical sequence for generating a server application is defined 
below:

<PRE class="code">
create_server(Port) :-
        tcp_socket(Socket),
        tcp_bind(Socket, Port),
        tcp_listen(Socket, 5),
        tcp_open_socket(Socket, AcceptFd, _),
        &lt;dispatch&gt;
</PRE>

<P>There are various options for &lt;<VAR>dispatch</VAR>&gt;. One is to 
keep track of active clients and server-sockets using <A NAME="idx:waitforinput3:29"></A><SPAN class="pred-ext">wait_for_input/3</SPAN>. 
If input arrives at a server socket, use <A NAME="idx:tcpaccept3:30"></A><A class="pred" href="#tcp_accept/3">tcp_accept/3</A> 
and add the new connection to the active clients. Otherwise deal with 
the input from the client. Another is to use (Unix) <A NAME="idx:fork1:31"></A><A class="pred" href="#fork/1">fork/1</A> 
to deal with the client in a separate process.

<P>Using <A NAME="idx:fork1:32"></A><A class="pred" href="#fork/1">fork/1</A>, &lt;<VAR>dispatch</VAR>&gt; 
may be implemented as:

<PRE class="code">
dispatch(AcceptFd) :-
        tcp_accept(AcceptFd, Socket, _Peer),
        fork(Pid)
        (   Pid == child
        -&gt;  tcp_open_socket(Socket, In, Out),
            handle_service(In, Out),
            close(In),
            close(Out),
            halt
        ;   tcp_close_socket(Socket)
        ),
        dispatch(AcceptFd).
</PRE>

<H3><A NAME="sec:4.2"><SPAN class="sec-nr">4.2</SPAN> <SPAN class="sec-title">Client 
applications</SPAN></A></H3>

<P>The skeleton for client-communication is given below.

<PRE class="code">
create_client(Host, Port) :-
        tcp_socket(Socket),
        tcp_connect(Socket, Host:Port),
        tcp_open_socket(Socket, ReadFd, WriteFd),
        &lt;handle I/O using the two streams&gt;
        close(ReadFd),
        close(WriteFd).
</PRE>

<P>To deal with timeouts and multiple connections, <A NAME="idx:waitforinput3:33"></A><SPAN class="pred-ext">wait_for_input/3</SPAN> 
and/or non-blocking streams (see <A NAME="idx:tcpfcntl3:34"></A><A class="pred" href="#tcp_fcntl/3">tcp_fcntl/3</A>) 
can be used.

<H3><A NAME="sec:4.3"><SPAN class="sec-nr">4.3</SPAN> <SPAN class="sec-title">The 
stream_pool library</SPAN></A></H3>

<P>The <CODE>library(streampool)</CODE> library dispatches input from 
multiple streams based on <A NAME="idx:waitforinput3:35"></A><SPAN class="pred-ext">wait_for_input/3</SPAN>. 
It is part of the clib package as it is used most of the time together 
with the <CODE>library(socket)</CODE> library. On non-Unix systems it 
often can only be used with socket streams.

<P>With SWI-Prolog 5.1.x, multi-threading often provides a good 
alternative to using this library. In this schema one thread watches the 
listening socket waiting for connections and either creates a thread per 
connection or processes the accepted connections with a pool of
<EM>worker threads</EM>. The library <CODE>library(http/thread_httpd)</CODE> 
provides an example realising a mult-threaded HTTP server.

<DL>
<DT class="pubdef"><A NAME="add_stream_to_pool/2"><STRONG>add_stream_to_pool</STRONG>(<VAR>+Stream, 
:Goal</VAR>)</A></DT>
<DD class="defbody">
Add <VAR>Stream</VAR>, which must be an input stream and ---on non-unix 
systems--- connected to a socket to the pool. If input is available on <VAR>Stream</VAR>, <VAR>Goal</VAR> 
is called.</DD>
<DT class="pubdef"><A NAME="delete_stream_from_pool/1"><STRONG>delete_stream_from_pool</STRONG>(<VAR>+Stream</VAR>)</A></DT>
<DD class="defbody">
Delete the given stream from the pool. Succeeds, even if <VAR>Stream</VAR> 
is no member of the pool. If <VAR>Stream</VAR> is unbound the entire 
pool is emtied but unlike <A NAME="idx:closestreampool0:36"></A><A class="pred" href="#close_stream_pool/0">close_stream_pool/0</A> 
the streams are not closed.</DD>
<DT class="pubdef"><A NAME="close_stream_pool/0"><STRONG>close_stream_pool</STRONG></A></DT>
<DD class="defbody">
Empty the pool, closing all streams that are part of it.</DD>
<DT class="pubdef"><A NAME="dispatch_stream_pool/1"><STRONG>dispatch_stream_pool</STRONG>(<VAR>+TimeOut</VAR>)</A></DT>
<DD class="defbody">
Wait for maximum of <VAR>TimeOut</VAR> for input on any of the streams 
in the pool. If there is input, call the <VAR>Goal</VAR> associated with
<A NAME="idx:addstreamtopool2:37"></A><A class="pred" href="#add_stream_to_pool/2">add_stream_to_pool/2</A>. 
If <VAR>Goal</VAR> fails or raises an exception a message is printed. <VAR>TimeOut</VAR> 
is described with <A NAME="idx:waitforinput3:38"></A><SPAN class="pred-ext">wait_for_input/3</SPAN>.

<P>If <VAR>Goal</VAR> is called, there is <EM>some</EM> input on the 
associated stream. <VAR>Goal</VAR> must be careful not to block as this 
will block the entire pool.<SUP class="fn">3<SPAN class="fn-text">This 
is hard to achieve at the moment as none of the Prolog read-commands 
provide for a timeout.</SPAN></SUP></DD>
<DT class="pubdef"><A NAME="stream_pool_main_loop/0"><STRONG>stream_pool_main_loop</STRONG></A></DT>
<DD class="defbody">
Calls <A NAME="idx:dispatchstreampool1:39"></A><A class="pred" href="#dispatch_stream_pool/1">dispatch_stream_pool/1</A> 
in a loop until the pool is empty.
</DD>
</DL>

<P>Below is a very simple example that reads the first line of input and 
echos it back.

<PRE class="code">
:- use_module(library(streampool)).

server(Port) :-
        tcp_socket(Socket),
        tcp_bind(Socket, Port),
        tcp_listen(Socket, 5),
        tcp_open_socket(Socket, In, _Out),
        add_stream_to_pool(In, accept(Socket)),
        stream_pool_main_loop.

accept(Socket) :-
        tcp_accept(Socket, Slave, Peer),
        tcp_open_socket(Slave, In, Out),
        add_stream_to_pool(In, client(In, Out, Peer)).

client(In, Out, _Peer) :-
        read_line_to_codes(In, Command),
        close(In),
        format(Out, 'Please to meet you: ~s~n', [Command]),
        close(Out),
        delete_stream_from_pool(In).
</PRE>

<H3><A NAME="sec:4.4"><SPAN class="sec-nr">4.4</SPAN> <SPAN class="sec-title">UDP 
protocol support</SPAN></A></H3>

<P>The current library provides limited support for UDP packets. The UDP 
protocol is a <EM>connection-less</EM> and <EM>unreliable</EM> datagram 
based protocol. That means that messages sent may or may not arrive at 
the client side and may arrive in a different order as they are sent. 
UDP messages are often used for streaming media or for service discovery 
using the broadcasting mechanism.

<DL>
<DT class="pubdef"><A NAME="udp_socket/1"><STRONG>udp_socket</STRONG>(<VAR>-Socket</VAR>)</A></DT>
<DD class="defbody">
Similar to <A NAME="idx:tcpsocket1:40"></A><A class="pred" href="#tcp_socket/1">tcp_socket/1</A>, 
but create a socket using the <CODE>SOCK_DGRAM</CODE> protocol, ready 
for UDP connections.</DD>
<DT class="pubdef"><A NAME="udp_receive/4"><STRONG>udp_receive</STRONG>(<VAR>+Socket, 
-Data, -From, +Options</VAR>)</A></DT>
<DD class="defbody">
Wait for and return the next datagram. The data is returned as a Prolog 
string object (see <A NAME="idx:stringtolist2:41"></A><SPAN class="pred-ext">string_to_list/2</SPAN>). <VAR>From</VAR> 
is a term of the format ip(<VAR>A</VAR>,<VAR>B</VAR>,<VAR>C</VAR>,<VAR>D</VAR>):<VAR>Port</VAR> 
indicating the sender of the message. <VAR>Options</VAR> is currently 
unused.
<VAR>Socket</VAR> can be waited for using <A NAME="idx:waitforinput3:42"></A><SPAN class="pred-ext">wait_for_input/3</SPAN>.</DD>
<DT class="pubdef"><A NAME="udp_send/4"><STRONG>udp_send</STRONG>(<VAR>+Socket, 
+Data, +To, +Options</VAR>)</A></DT>
<DD class="defbody">
Send a UDP message. Data is a string, atom or code-list providing the 
data. <VAR>To</VAR> is an address of the form <VAR>Host</VAR>:<VAR>Port</VAR> 
where Host is either the hostname or a term <A NAME="idx:ip4:43"></A><SPAN class="pred-ext">ip/4</SPAN>. <VAR>Options</VAR> 
is currently unused.

<P>A broadcast is achieved by using <CODE>tcp_setopt(Socket, broadcast)</CODE> 
prior to sending the datagram and using the local network broadcast 
address as a <A NAME="idx:ip4:44"></A><SPAN class="pred-ext">ip/4</SPAN> 
term.
</DD>
</DL>

<H2><A NAME="sec:5"><SPAN class="sec-nr">5</SPAN> <SPAN class="sec-title">CGI 
Support library</SPAN></A></H2>

<P>This is currently a very simple library, providing support for 
obtaining the form-data for a CGI script:

<DL>
<DT class="pubdef"><A NAME="cgi_get_form/1"><STRONG>cgi_get_form</STRONG>(<VAR>-Form</VAR>)</A></DT>
<DD class="defbody">
Decodes standard input and the environment variables to obtain a list of 
arguments passed to the CGI script. This predicate both deals with the 
CGI <B>GET</B> method as well as the <B>POST</B> method. If the data 
cannot be obtained, an <CODE>existence_error</CODE> exception is raised.
</DD>
</DL>

<P>Below is a very simple CGI script that prints the passed parameters. 
To test it, compile this program using the command below, copy it to 
your cgi-bin directory (or make it otherwise known as a CGI-script) and 
make the query <CODE>http://myhost.mydomain/cgi-bin/cgidemo?hello=world</CODE>

<PRE class="code">
% pl -o cgidemo --goal=main --toplevel=halt -c cgidemo.pl
</PRE>

<PRE class="code">
:- use_module(library(cgi)).

main :-
        set_stream(current_output, encoding(utf8)),
        cgi_get_form(Arguments),
        format('Content-type: text/html; charset=UTF-8~n~n', []),
        format('&lt;HTML&gt;~n', []),
        format('&lt;HEAD&gt;~n', []),
        format('&lt;TITLE&gt;Simple SWI-Prolog CGI script&lt;/TITLE&gt;~n', []),
        format('&lt;/HEAD&gt;~n~n', []),
        format('&lt;BODY&gt;~n', []),
        format('&lt;P&gt;', []),
        print_args(Arguments),
        format('&lt;/BODY&gt;~n&lt;/HTML&gt;~n', []).

print_args([]).
print_args([A0|T]) :-
        A0 =.. [Name, Value],
        format('&lt;B&gt;~w&lt;/B&gt;=&lt;EM&gt;~w&lt;/EM&gt;&lt;BR&gt;~n', [Name, Value]),
        print_args(T).
</PRE>

<H3><A NAME="sec:5.1"><SPAN class="sec-nr">5.1</SPAN> <SPAN class="sec-title">Some 
considerations</SPAN></A></H3>

<P>Printing an HTML document using <A NAME="idx:format2:45"></A><SPAN class="pred-ext">format/2</SPAN> 
is not really a neat way of producing HTML. A high-level alternative is 
provided by
<CODE>library(http/html_write)</CODE> from the HTTP library.

<P>The CGI standard is very unclear about handling Unicode data. The 
above two declarations ensure the CGI script will send all data in UTF-8 
and thus provide full support of Unicode. It is assumed that browsers 
generally send form-data using the same encoding as the page in which 
the form appears, UTF-8 or ISO Latin-1. The current version of
<A NAME="idx:cgigetform2:46"></A><SPAN class="pred-ext">cgi_get_form/2</SPAN> 
assumes the CGI data is in UTF-8.

<H2><A NAME="sec:6"><SPAN class="sec-nr">6</SPAN> <SPAN class="sec-title">MIME 
decoding library</SPAN></A></H2>

<P>MIME (Multipurpose Internet Mail Extensions) is a format for 
serializing multiple typed data objects. It was designed for E-mail, but 
it is also used for other applications such packaging multiple values 
using the HTTP POST request on web-servers. Double Precision, Inc. has 
produced the C-libraries rfc822 (mail) and rfc2045 (MIME) for decoding 
and manipulating MIME messages. The <CODE>library(mime)</CODE> library 
is a Prolog wrapper around the rfc2045 library for decoding MIME 
messages.

<P>The general name `mime' is used for this library as it is anticipated 
to add MIME-creation functionality to this library.

<P>Currently the mime library defines one predicate:

<DL>
<DT class="pubdef"><A NAME="mime_parse/2"><STRONG>mime_parse</STRONG>(<VAR>Data, 
Parsed</VAR>)</A></DT>
<DD class="defbody">
Parse <VAR>Data</VAR> and unify the result to <VAR>Parsed</VAR>. <VAR>Data</VAR> 
is one of:

<DL>
<DT><STRONG>stream</STRONG>(<VAR>Stream</VAR>)</DT>
<DD class="defbody">
Parse the data from <VAR>Stream</VAR> upto the end-of-file.
</DD>
<DT><STRONG>stream</STRONG>(<VAR>Stream, Length</VAR>)</DT>
<DD class="defbody">
Parse a maximum of <VAR>Length</VAR> characters from <VAR>Stream</VAR> 
or upto the end-of-file, whichever comes first.
</DD>
<DT><STRONG><VAR>Text</VAR></STRONG></DT>
<DD class="defbody">
Atoms, strings, code- and character lists are treated as valid sources 
of data.
</DD>
</DL>

<P><VAR>Parsed</VAR> is a tree structure of <CODE>mime(Attributes, Data, 
PartList)</CODE> terms. Currently either <VAR>Data</VAR> is the empty 
atom or <VAR>PartList</VAR> is an empty list.<SUP class="fn">4<SPAN class="fn-text">It 
is unclear to me whether a MIME note can contain a mixture of content 
and parts, but I believe the answer is `no'.</SPAN></SUP>
<VAR>Data</VAR> is an atom holding the message data. The library 
automatically decodes <EM>base64</EM> and <EM>quoted-printable</EM> 
messages. See also the <CODE>transfer_encoding</CODE> attribute below.

<P><VAR>PartList</VAR> is a list of mime/3 terms. <VAR>Attributes</VAR> 
is a list holding a subset of the following arguments. For details 
please consult the RFC2045 document.

<DL>
<DT><STRONG>type</STRONG>(<VAR>Atom</VAR>)</DT>
<DD class="defbody">
Denotes the Content-Type, how the <VAR>Data</VAR> should be interpreted.
</DD>
<DT><STRONG>transfer_encoding</STRONG>(<VAR>Atom</VAR>)</DT>
<DD class="defbody">
How the <VAR>Data</VAR> was encoded. This is not very interesting as the 
library decodes the content of the message.
</DD>
<DT><STRONG>character_set</STRONG>(<VAR>Atom</VAR>)</DT>
<DD class="defbody">
The character set used for text data. Note that SWI-Prolog's 
capabilities for character-set handling are limited.
</DD>
<DT><STRONG>language</STRONG>(<VAR>Atom</VAR>)</DT>
<DD class="defbody">
Language in which the text-data is written.
</DD>
<DT><STRONG>id</STRONG>(<VAR>Atom</VAR>)</DT>
<DD class="defbody">
Identifier of the message-part.
</DD>
<DT><STRONG>description</STRONG>(<VAR>Atom</VAR>)</DT>
<DD class="defbody">
Descrptive text for the <VAR>Data</VAR>.
</DD>
<DT><STRONG>disposition</STRONG>(<VAR>Atom</VAR>)</DT>
<DD class="defbody">
Where the data comes from. The current library only deals with `inline' 
data.
</DD>
<DT><STRONG>name</STRONG>(<VAR>Atom</VAR>)</DT>
<DD class="defbody">
Name of the part.
</DD>
<DT><STRONG>filename</STRONG>(<VAR>Atom</VAR>)</DT>
<DD class="defbody">
Name of the file the data should be stored in.
</DD>
</DL>

</DD>
</DL>

<H2><A NAME="sec:7"><SPAN class="sec-nr">7</SPAN> <SPAN class="sec-title">Password 
encryption library</SPAN></A></H2>

<A NAME="sec:crypt"></A>

<P>The <CODE>library(crypt)</CODE> library defines <A NAME="idx:crypt2:47"></A><A class="pred" href="#crypt/2">crypt/2</A> 
for encrypting and testing passwords. The clib package also provides 
crytographic hashes as described in <A class="sec" href="#sec:8">section 
8</A>

<DL>
<DT class="pubdef"><A NAME="crypt/2"><STRONG>crypt</STRONG>(<VAR>+Plain, 
?Encrypted</VAR>)</A></DT>
<DD class="defbody">
This predicate can be used in three modes. To test whether a password 
matches an encrypted version thereof, simply run with both arguments 
fully instantiated. To generate a default encrypted version of
<VAR>Plain</VAR>, run with unbound <VAR>Encrypted</VAR> and this 
argument is unified to a list of character codes holding an encrypted 
version.

<P>The library supports two encryption formats: traditional Unix DES 
hashes (Unix only) and FreeBSD compatible MD5 hashes (all platforms). 
MD5 hashes start with the magic sequence <CODE>$1$</CODE>, followed by 
an up to 8 character <EM>salt</EM>. DES hashes start with a 2 character
<EM>salt</EM>. Note that a DES hash considers only the first 8 
characters. The MD5 considers the whole string.

<P>Salt and algorithm can be forced by instantiating the start of
<VAR>Encrypted</VAR> with it. This is typically used to force MD5 
hashes:

<PRE class="code">
?- append("$1$", _, E),
   crypt("My password", E),
   format('~s~n', [E]).

$1$qdaDeDZn$ZUxSQEESEHIDCHPNc3fxZ1
</PRE>

<P><VAR>Encrypted</VAR> is always an ASCII string. <VAR>Plain</VAR> only 
supports ISO-Latin-1 passwords in the current implementation.

<P><VAR>Plain</VAR> is either an atom, SWI-Prolog string, list of 
characters or list of character-codes. It is not advised to use atoms, 
as this implies the password will be available from the Prolog heap as a 
defined atom.
</DD>
</DL>

<H2><A NAME="sec:8"><SPAN class="sec-nr">8</SPAN> <SPAN class="sec-title">SHA1 
and SHA2 Secure Hash Algorithms</SPAN></A></H2>

<A NAME="sec:sha"></A>

<P>The library <CODE>library(sha)</CODE> provides <EM>Secure Hash 
Algorihms</EM> approved by FIPS (<EM>Federal Information Processing 
Standard</EM>). Quoting
<A class="url" href="http://en.wikipedia.org/wiki/SHA-1">Wikipedia</A>: <I>``The 
SHA (Secure Hash Algorithm) hash functions refer to five FIPS-approved 
algorithms for computing a condensed digital representation (known as a 
message digest) that is, to a high degree of probability, unique for a 
given input data sequence (the message). These algorithms are called ‚ Ä 
úsecure ‚ Ä ù because (in the words of the standard), ‚ Ä úfor a given 
algorithm, it is computationally infeasible 1) to find a message that 
corresponds to a given message digest, or 2) to find two different 
messages that produce the same message digest. Any change to a message 
will, with a very high probability, result in a different message 
digest. ‚ Ä ù''</I>

<P>The current library supports all 5 approved algorithms, both 
computing the hash-key from data and the <EM>hash Message Authentication 
Code</EM> (HMAC).

<P>Input is text, represented as an atom, packed string object or 
code-list. Note that these functions operate on byte-sequences and 
therefore are not meaningful on Unicode text. The result is returned as 
a list of byte-values. This is the most general format that is 
comfortable supported by standard Prolog and can easily be transformed 
in other formats. Commonly used text formats are ASCII created by 
encoding each byte as two hexadecimal digits and ASCII created using
<EM>base64</EM> encoding. Representation as a large integer can be 
desirable for computational processing.

<DL>
<DT class="pubdef"><A NAME="sha_hash/3"><STRONG>sha_hash</STRONG>(<VAR>+Data, 
-Hash, +Options</VAR>)</A></DT>
<DD class="defbody">
Hash is the SHA hash of Data. <VAR>Data</VAR> is either an atom, packed 
string or list of character codes. <VAR>Hash</VAR> is unified with a 
list of integers representing the hash. The conversion is controlled by 
Options:

<DL>
<DT><STRONG>algorithm</STRONG>(<VAR>+Algorithm</VAR>)</DT>
<DD class="defbody">
One of <CODE>sha1</CODE> (default), <CODE>sha224</CODE>, <CODE>sha256</CODE>,
<CODE>sha384</CODE> or <CODE>sha512</CODE>
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="hmac_sha/4"><STRONG>hmac_sha</STRONG>(<VAR>+Key, 
+Data, -HMAC, +Options</VAR>)</A></DT>
<DD class="defbody">
Quoting <A class="url" href="http://en.wikipedia.org/wiki/HMAC">Wikipedia</A>: <I>``A 
keyed-hash message authentication code, or HMAC, is a type of message 
authentication code (MAC) calculated using a cryptographic hash function 
in combination with a secret key. As with any MAC, it may be used to 
simultaneously verify both the data integrity and the authenticity of a 
message. Any iterative cryptographic hash function, such as MD5 or 
SHA-1, may be used in the calculation of an HMAC; the resulting MAC 
algorithm is termed HMAC-MD5 or HMAC-SHA-1 accordingly. The 
cryptographic strength of the HMAC depends upon the cryptographic 
strength of the underlying hash function, on the size and quality of the 
key and the size of the hash output length in bits.''</I>

<P><VAR>Key</VAR> and <VAR>Data</VAR> are either an atom, packed string 
or list of character codes. <VAR>HMAC</VAR> is unified with a list of 
integers representing the authentication code. <VAR>Options</VAR> is the 
same as for
<A NAME="idx:shahash3:48"></A><A class="pred" href="#sha_hash/3">sha_hash/3</A>, 
but currently only <CODE>sha1</CODE> and <CODE>sha256</CODE> are 
supported.
</DD>
</DL>

<H3><A NAME="sec:8.1"><SPAN class="sec-nr">8.1</SPAN> <SPAN class="sec-title">License 
terms</SPAN></A></H3>

<P>The underlying SHA-2 library is an unmodified copy created by Dr 
Brian Gladman, Worcester, UK. It is distributed under the license 
conditions below.

<P>The free distribution and use of this software in both source and 
binary form is allowed (with or without changes) provided that:

<P><OL>
<LI>distributions of this source code include the above copyright 
notice, this list of conditions and the following disclaimer;

<P>
<LI>distributions in binary form include the above copyright notice, 
this list of conditions and the following disclaimer in the 
documentation and/or other associated materials;

<P>
<LI>the copyright holder's name is not used to endorse products built 
using this software without specific written permission.
</OL>

<P>ALTERNATIVELY, provided that this notice is retained in full, this 
product may be distributed under the terms of the GNU General Public 
License (GPL), in which case the provisions of the GPL apply INSTEAD OF 
those given above.

<H2><A NAME="sec:9"><SPAN class="sec-nr">9</SPAN> <SPAN class="sec-title">Memory 
files</SPAN></A></H2>

<P>The <CODE>library(memfile)</CODE> provides an alternative to 
temporary files, intended for temporary buffering of data. Memory files 
in general are faster than temporary files and do not suffer from 
security riscs or naming conflicts associated with temporary-file 
management. They do assume proper memory management by the hosting OS 
and cannot be used to pass data to external processes using a file-name.

<P>There is no limit to the number of memory streams, nor the size of 
them. However, memory-streams cannot have multiple streams at the same 
time (i.e. cannot be opened for reading and writing at the same time).

<P>These predicates are first of all intended for building higher-level 
primitives. See also <A NAME="idx:sformat3:49"></A><SPAN class="pred-ext">sformat/3</SPAN>, <A NAME="idx:atomtoterm3:50"></A><SPAN class="pred-ext">atom_to_term/3</SPAN>, <A NAME="idx:termtoatom2:51"></A><SPAN class="pred-ext">term_to_atom/2</SPAN> 
and the XPCE primitive <A NAME="idx:pceopen3:52"></A><SPAN class="pred-ext">pce_open/3</SPAN>.

<DL>
<DT class="pubdef"><A NAME="new_memory_file/1"><STRONG>new_memory_file</STRONG>(<VAR>-Handle</VAR>)</A></DT>
<DD class="defbody">
Create a new memory file and return a unique opaque handle to it.</DD>
<DT class="pubdef"><A NAME="free_memory_file/1"><STRONG>free_memory_file</STRONG>(<VAR>+Handle</VAR>)</A></DT>
<DD class="defbody">
Discard the memory file and its contents. If the file is open it is 
first closed.</DD>
<DT class="pubdef"><A NAME="open_memory_file/3"><STRONG>open_memory_file</STRONG>(<VAR>+Handle, 
+Mode, -Stream</VAR>)</A></DT>
<DD class="defbody">
Open the memory-file. <VAR>Mode</VAR> is currently one of <CODE>read</CODE> 
or <CODE>write</CODE>. The resulting <VAR>Stream</VAR> must be closed 
using <A NAME="idx:close1:53"></A><SPAN class="pred-ext">close/1</SPAN>.</DD>
<DT class="pubdef"><A NAME="open_memory_file/4"><STRONG>open_memory_file</STRONG>(<VAR>+Handle, 
+Mode, -Stream, +Options</VAR>)</A></DT>
<DD class="defbody">
Open a memory-file as <A NAME="idx:openmemoryfile3:54"></A><A class="pred" href="#open_memory_file/3">open_memory_file/3</A>. 
Options:

<DL>
<DT><STRONG>encoding</STRONG>(<VAR>+Encoding</VAR>)</DT>
<DD class="defbody">
Set the encoding for a memory file and the created stream. Encoding 
names are the same as used with <A NAME="idx:open4:55"></A><SPAN class="pred-ext">open/4</SPAN>. 
By default, memoryfiles represent UTF-8 streams, making them capable of 
storing arbitrary Unicode text. In practice the only alternative is <CODE>octet</CODE>, 
turning the memoryfile into binary mode. Please study SWI-Prolog Unicode 
and encoding issues before using this option.
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="size_memory_file/2"><STRONG>size_memory_file</STRONG>(<VAR>+Handle, 
-Bytes</VAR>)</A></DT>
<DD class="defbody">
Return the content-length of the memory-file it <VAR>Bytes</VAR>. The 
file should be closed and contain data.</DD>
<DT class="pubdef"><A NAME="atom_to_memory_file/2"><STRONG>atom_to_memory_file</STRONG>(<VAR>+Atom, 
-Handle</VAR>)</A></DT>
<DD class="defbody">
Turn an atom into a read-only memory-file containing the (shared) 
characters of the atom. Opening this memory-file in mode <CODE>write</CODE> 
yields a permission error.</DD>
<DT class="pubdef"><A NAME="memory_file_to_atom/2"><STRONG>memory_file_to_atom</STRONG>(<VAR>+Handle, 
-Atom</VAR>)</A></DT>
<DD class="defbody">
Return the content of the memory-file in <VAR>Atom</VAR>.</DD>
<DT class="pubdef"><A NAME="memory_file_to_codes/2"><STRONG>memory_file_to_codes</STRONG>(<VAR>+Handle, 
-Codes</VAR>)</A></DT>
<DD class="defbody">
Return the content of the memory-file as a list of character-codes in <VAR>Codes</VAR>.
</DD>
</DL>

<H2><A NAME="sec:10"><SPAN class="sec-nr">10</SPAN> <SPAN class="sec-title">Time 
and alarm library</SPAN></A></H2>

<P>The <CODE>library(time)</CODE> provides timing and alarm functions.

<DL>
<DT class="pubdef"><A NAME="alarm/4"><STRONG>alarm</STRONG>(<VAR>+Time, 
:Callable, -Id, +Options</VAR>)</A></DT>
<DD class="defbody">
Schedule <VAR>Callable</VAR> to be called <VAR>Time</VAR> seconds from 
now.
<VAR>Time</VAR> is a number (integer or float). <VAR>Callable</VAR> is 
called on the next pass through a call- or redo-port of the Prolog 
engine, or a call to the PL_handle_signals() routine from SWI-Prolog. <VAR>Id</VAR> 
is unified with a reference to the timer.

<P>The resolution of the alarm depends on the underlying implementation. 
On Unix systems it is based on setitimer(), on Windows on timeSetEvent() 
using a resolution specified at 50 milliseconds.<SUP class="fn">bug<SPAN class="fn-text">The 
maximum time for timeSetEvent() used by the Windows application is 1000 
seconds. Calling with a higher time value raises a <CODE>resource_error</CODE> 
exception.</SPAN></SUP> Long-running foreign predicates that do not call 
PL_handle_signals() may further delay the alarm.

<P><VAR>Options</VAR> is a list of <CODE><VAR>Name</VAR>(Value)</CODE> 
terms. Defined options are:

<DL>
<DT><STRONG>remove</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
If <CODE>true</CODE> (default <CODE>false</CODE>), the timer is removed 
automatically after fireing. Otherwise it must be destroyed explicitly 
using <A NAME="idx:removealarm1:56"></A><A class="pred" href="#remove_alarm/1">remove_alarm/1</A>.
</DD>
<DT><STRONG>install</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
If <CODE>false</CODE> (default <CODE>true</CODE>), the timer is 
allocated but not scheduled for execution. It must be started later 
using <A NAME="idx:installalarm1:57"></A><A class="pred" href="#install_alarm/1">install_alarm/1</A>.
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="alarm/3"><STRONG>alarm</STRONG>(<VAR>+Time, 
:Callable, -Id</VAR>)</A></DT>
<DD class="defbody">
Same as <CODE>alarm(Time, Callable, Id,[])</CODE>.</DD>
<DT class="pubdef"><A NAME="install_alarm/1"><STRONG>install_alarm</STRONG>(<VAR>+Id</VAR>)</A></DT>
<DD class="defbody">
Activate an alarm allocated usign <A NAME="idx:alarm4:58"></A><A class="pred" href="#alarm/4">alarm/4</A> 
with the option
<CODE>install(false)</CODE>. This is intended to reclaim alarms reliably 
using <A NAME="idx:callcleanup2:59"></A><SPAN class="pred-ext">call_cleanup/2</SPAN>. 
See the implementation of <A NAME="idx:callwithtimelimit2:60"></A><A class="pred" href="#call_with_time_limit/2">call_with_time_limit/2</A>.</DD>
<DT class="pubdef"><A NAME="remove_alarm/1"><STRONG>remove_alarm</STRONG>(<VAR>+Id</VAR>)</A></DT>
<DD class="defbody">
Remove an alarm. If it is not yet fired, it will not be fired any more.</DD>
<DT class="pubdef"><A NAME="current_alarm/4"><STRONG>current_alarm</STRONG>(<VAR>?At, 
?:Callable, ?Id, ?Status</VAR>)</A></DT>
<DD class="defbody">
Enumerate the not-yet-removed alarms. <VAR>Status</VAR> is one of
<CODE>done</CODE> if the alarm has been called, <CODE>next</CODE> if it 
is the next to be fired and <VAR>scheduled</VAR> otherwise.</DD>
<DT class="pubdef"><A NAME="call_with_time_limit/2"><STRONG>call_with_time_limit</STRONG>(<VAR>+Time, 
:Goal</VAR>)</A></DT>
<DD class="defbody">
True if <VAR>Goal</VAR> completes within <VAR>Time</VAR> seconds. <VAR>Goal</VAR> 
is executed as in <A NAME="idx:once1:61"></A><SPAN class="pred-ext">once/1</SPAN>. 
If <VAR>Goal</VAR> doesn't complete within <VAR>Time</VAR> seconds (wall 
time), exit using the exception
<CODE>time_limit_exceeded</CODE>. See <A NAME="idx:catch3:62"></A><SPAN class="pred-ext">catch/3</SPAN>.

<P>Please note that this predicate uses <A NAME="idx:alarm4:63"></A><A class="pred" href="#alarm/4">alarm/4</A> 
and therefore is <EM>not</EM> capable to break out of long running goals 
such as <A NAME="idx:sleep1:64"></A><SPAN class="pred-ext">sleep/1</SPAN>, 
blocking I/O or other long-running (foreign) predicates. Blocking I/O 
can be handled using the timeout option of <A NAME="idx:readterm3:65"></A><SPAN class="pred-ext">read_term/3</SPAN>.
</DD>
</DL>

<H2><A NAME="sec:11"><SPAN class="sec-nr">11</SPAN> <SPAN class="sec-title">Limiting 
process resources</SPAN></A></H2>

<P>The <CODE>library(rlimit)</CODE> library provides an interface to the 
POSIX getrlimit()/setrlimit() API that control the maximum 
resource-usage of a process or group of processes. This call is 
especially useful for server such as CGI scripts and inetd-controlled 
servers to avoid an uncontrolled script claiming too much resources.

<DL>
<DT class="pubdef"><A NAME="rlimit/3"><STRONG>rlimit</STRONG>(<VAR>+Resource, 
-Old, +New</VAR>)</A></DT>
<DD class="defbody">
Query and/or set the limit for <VAR>Resource</VAR>. Time-values are in 
seconds and size-values are counted in bytes. The following values are 
supported by this library. Please note that not all resources may be 
available and accessible on all platforms. This predicate can throw a 
variety of exceptions. In portable code this should be guarded with <A NAME="idx:catch3:66"></A><SPAN class="pred-ext">catch/3</SPAN>. 
The defined resources are:
<BLOCKQUOTE>
<TABLE BORDER=0 FRAME=void RULES=groups>
<TR VALIGN=top><TD><CODE>cpu</CODE> </TD><TD>CPU time in seconds </TD></TR>
<TR VALIGN=top><TD><CODE>fsize</CODE> </TD><TD>Maximum filesize </TD></TR>
<TR VALIGN=top><TD><CODE>data</CODE> </TD><TD>max data size </TD></TR>
<TR VALIGN=top><TD><CODE>stack</CODE> </TD><TD>max stack size </TD></TR>
<TR VALIGN=top><TD><CODE>core</CODE> </TD><TD>max core file size </TD></TR>
<TR VALIGN=top><TD><CODE>rss</CODE> </TD><TD>max resident set size </TD></TR>
<TR VALIGN=top><TD><CODE>nproc</CODE> </TD><TD>max number of processes </TD></TR>
<TR VALIGN=top><TD><CODE>nofile</CODE> </TD><TD>max number of open files </TD></TR>
<TR VALIGN=top><TD><CODE>memlock</CODE> </TD><TD>max locked-in-memory 
address </TD></TR>
</TABLE>

</BLOCKQUOTE>

<P>When the process hits a limit POSIX systems normally send the process 
a signal that terminates it. These signals may be catched using 
SWI-Prolog's <A NAME="idx:onsignal3:67"></A><SPAN class="pred-ext">on_signal/3</SPAN> 
primitive. The code below illustrates this behaviour. Please note that 
asynchronous signal handling is dangerous, especially when using 
threads. 100% fail-safe operation cannot be guaranteed, but this 
procedure will inform the user properly `most of the time'.

<PRE class="code">
rlimit_demo :-
        rlimit(cpu, _, 2),
        on_signal(xcpu, _, cpu_exceeded),
        ( repeat, fail ).

cpu_exceeded(_Sig) :-
        format(user_error, 'CPU time exceeded~n', []),
        halt(1).
</PRE>

<P></DD>
</DL>

<H2><A NAME="sec:12"><SPAN class="sec-nr">12</SPAN> <SPAN class="sec-title">Installation</SPAN></A></H2>

<H3><A NAME="sec:12.1"><SPAN class="sec-nr">12.1</SPAN> <SPAN class="sec-title">Unix 
systems</SPAN></A></H3>

<P>Installation on Unix system uses the commonly found <EM>configure</EM>,
<EM>make</EM> and <EM>make install</EM> sequence. SWI-Prolog should be 
installed before building this package. If SWI-Prolog is not installed 
as <B>pl</B>, the environment variable <CODE>PL</CODE> must be set to 
the name of the SWI-Prolog executable. Installation is now accomplished 
using:

<PRE class="code">
% ./configure
% make
% make install
</PRE>

<P>This installs the foreign libraries in <CODE>$PLBASE/lib/$PLARCH</CODE> 
and the Prolog library files in <CODE>$PLBASE/library</CODE>, where
<CODE>$PLBASE</CODE> refers to the SWI-Prolog `home-directory'.

<H1><A NAME="document-index">Index</A></H1>

<DL>
<DT><STRONG>A</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#add_stream_to_pool/2">add_stream_to_pool/2</A></DT>
<DD>
<A class="idx" href="#idx:addstreamtopool2:37">4.3</A></DD>
<DT><A class="idx" href="#alarm/3">alarm/3</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#alarm/4">alarm/4</A></DT>
<DD>
<A class="idx" href="#idx:alarm4:58">10</A> <A class="idx" href="#idx:alarm4:63">10</A></DD>
<DT>at_end_of_stream/1</DT>
<DD>
<A class="idx" href="#idx:atendofstream1:27">4</A> <A class="idx" href="#idx:atendofstream1:28">4</A></DD>
<DT><A class="idx" href="#atom_to_memory_file/2">atom_to_memory_file/2</A></DT>
<DD>
</DD>
<DT>atom_to_term/3</DT>
<DD>
<A class="idx" href="#idx:atomtoterm3:50">9</A></DD>
<DT><STRONG>C</STRONG></DT>
<DD>
</DD>
<DT>call_cleanup/2</DT>
<DD>
<A class="idx" href="#idx:callcleanup2:59">10</A></DD>
<DT><A class="idx" href="#call_with_time_limit/2">call_with_time_limit/2</A></DT>
<DD>
<A class="idx" href="#idx:callwithtimelimit2:60">10</A></DD>
<DT>catch/3</DT>
<DD>
<A class="idx" href="#idx:catch3:62">10</A> <A class="idx" href="#idx:catch3:66">11</A></DD>
<DT><A class="idx" href="#cgi_get_form/1">cgi_get_form/1</A></DT>
<DD>
</DD>
<DT>cgi_get_form/2</DT>
<DD>
<A class="idx" href="#idx:cgigetform2:46">5.1</A></DD>
<DT>close/1</DT>
<DD>
<A class="idx" href="#idx:close1:53">9</A></DD>
<DT><A class="idx" href="#close_stream_pool/0">close_stream_pool/0</A></DT>
<DD>
<A class="idx" href="#idx:closestreampool0:36">4.3</A></DD>
<DT><A class="idx" href="#crypt/2">crypt/2</A></DT>
<DD>
<A class="idx" href="#idx:crypt2:47">7</A></DD>
<DT><A class="idx" href="#current_alarm/4">current_alarm/4</A></DT>
<DD>
</DD>
<DT><STRONG>D</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#delete_stream_from_pool/1">delete_stream_from_pool/1</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#detach_IO/0">detach_IO/0</A></DT>
<DD>
<A class="idx" href="#idx:detachIO0:4">2</A></DD>
<DT><A class="idx" href="#dispatch_stream_pool/1">dispatch_stream_pool/1</A></DT>
<DD>
<A class="idx" href="#idx:dispatchstreampool1:39">4.3</A></DD>
<DT><A class="idx" href="#dup/2">dup/2</A></DT>
<DD>
</DD>
<DT><STRONG>E</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#exec/1">exec/1</A></DT>
<DD>
</DD>
<DT><STRONG>F</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#fork/1">fork/1</A></DT>
<DD>
<A class="idx" href="#idx:fork1:2">2</A> <A class="idx" href="#idx:fork1:9">2</A> <A class="idx" href="#idx:fork1:15">4</A> <A class="idx" href="#idx:fork1:31">4.1</A> <A class="idx" href="#idx:fork1:32">4.1</A></DD>
<DT>fork/2</DT>
<DD>
<A class="idx" href="#idx:fork2:1">2</A></DD>
<DT>format/2</DT>
<DD>
<A class="idx" href="#idx:format2:45">5.1</A></DD>
<DT><A class="idx" href="#free_memory_file/1">free_memory_file/1</A></DT>
<DD>
</DD>
<DT><STRONG>G</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#gethostname/1">gethostname/1</A></DT>
<DD>
</DD>
<DT><STRONG>H</STRONG></DT>
<DD>
</DD>
<DT>halt/[0,1]</DT>
<DD>
<A class="idx" href="#idx:halt01:5">2</A></DD>
<DT><A class="idx" href="#hmac_sha/4">hmac_sha/4</A></DT>
<DD>
</DD>
<DT><STRONG>I</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#install_alarm/1">install_alarm/1</A></DT>
<DD>
<A class="idx" href="#idx:installalarm1:57">10</A></DD>
<DT>ip/4</DT>
<DD>
<A class="idx" href="#idx:ip4:43">4.4</A> <A class="idx" href="#idx:ip4:44">4.4</A></DD>
<DT><STRONG>K</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#kill/2">kill/2</A></DT>
<DD>
<A class="idx" href="#idx:kill2:6">2</A></DD>
<DT><STRONG>M</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#memory_file_to_atom/2">memory_file_to_atom/2</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#memory_file_to_codes/2">memory_file_to_codes/2</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#mime_parse/2">mime_parse/2</A></DT>
<DD>
</DD>
<DT><STRONG>N</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#new_memory_file/1">new_memory_file/1</A></DT>
<DD>
</DD>
<DT><STRONG>O</STRONG></DT>
<DD>
</DD>
<DT>once/1</DT>
<DD>
<A class="idx" href="#idx:once1:61">10</A></DD>
<DT>on_signal/2</DT>
<DD>
<A class="idx" href="#idx:onsignal2:7">2</A></DD>
<DT>on_signal/3</DT>
<DD>
<A class="idx" href="#idx:onsignal3:67">11</A></DD>
<DT>open/4</DT>
<DD>
<A class="idx" href="#idx:open4:55">9</A></DD>
<DT><A class="idx" href="#open_memory_file/3">open_memory_file/3</A></DT>
<DD>
<A class="idx" href="#idx:openmemoryfile3:54">9</A></DD>
<DT><A class="idx" href="#open_memory_file/4">open_memory_file/4</A></DT>
<DD>
</DD>
<DT>open_socket/3</DT>
<DD>
<A class="idx" href="#idx:opensocket3:12">4</A></DD>
<DT><STRONG>P</STRONG></DT>
<DD>
</DD>
<DT>pce_open/3</DT>
<DD>
<A class="idx" href="#idx:pceopen3:52">9</A></DD>
<DT><A class="idx" href="#pipe/2">pipe/2</A></DT>
<DD>
<A class="idx" href="#idx:pipe2:8">2</A> <A class="idx" href="#idx:pipe2:10">2</A></DD>
<DT><STRONG>R</STRONG></DT>
<DD>
</DD>
<DT>read/1</DT>
<DD>
<A class="idx" href="#idx:read1:26">4</A></DD>
<DT>read_term/3</DT>
<DD>
<A class="idx" href="#idx:readterm3:65">10</A></DD>
<DT><A class="idx" href="#remove_alarm/1">remove_alarm/1</A></DT>
<DD>
<A class="idx" href="#idx:removealarm1:56">10</A></DD>
<DT><A class="idx" href="#rlimit/3">rlimit/3</A></DT>
<DD>
</DD>
<DT><STRONG>S</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#set_time_file/3">set_time_file/3</A></DT>
<DD>
</DD>
<DT>sformat/3</DT>
<DD>
<A class="idx" href="#idx:sformat3:49">9</A></DD>
<DT><A class="idx" href="#sha_hash/3">sha_hash/3</A></DT>
<DD>
<A class="idx" href="#idx:shahash3:48">8</A></DD>
<DT><A class="idx" href="#size_memory_file/2">size_memory_file/2</A></DT>
<DD>
</DD>
<DT>sleep/1</DT>
<DD>
<A class="idx" href="#idx:sleep1:64">10</A></DD>
<DT>socket</DT>
<DD>
<A class="sec" href="#sec:4">4</A></DD>
<DT><A class="idx" href="#stream_pool_main_loop/0">stream_pool_main_loop/0</A></DT>
<DD>
</DD>
<DT>string_to_list/2</DT>
<DD>
<A class="idx" href="#idx:stringtolist2:41">4.4</A></DD>
<DT><STRONG>T</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#tcp_accept/3">tcp_accept/3</A></DT>
<DD>
<A class="idx" href="#idx:tcpaccept3:14">4</A> <A class="idx" href="#idx:tcpaccept3:17">4</A> <A class="idx" href="#idx:tcpaccept3:21">4</A> <A class="idx" href="#idx:tcpaccept3:23">4</A> <A class="idx" href="#idx:tcpaccept3:30">4.1</A></DD>
<DT><A class="idx" href="#tcp_bind/2">tcp_bind/2</A></DT>
<DD>
<A class="idx" href="#idx:tcpbind2:19">4</A> <A class="idx" href="#idx:tcpbind2:22">4</A></DD>
<DT><A class="idx" href="#tcp_close_socket/1">tcp_close_socket/1</A></DT>
<DD>
<A class="idx" href="#idx:tcpclosesocket1:13">4</A> <A class="idx" href="#idx:tcpclosesocket1:16">4</A> <A class="idx" href="#idx:tcpclosesocket1:18">4</A></DD>
<DT><A class="idx" href="#tcp_connect/2">tcp_connect/2</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#tcp_fcntl/3">tcp_fcntl/3</A></DT>
<DD>
<A class="idx" href="#idx:tcpfcntl3:34">4.2</A></DD>
<DT><A class="idx" href="#tcp_host_to_address/2">tcp_host_to_address/2</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#tcp_listen/2">tcp_listen/2</A></DT>
<DD>
<A class="idx" href="#idx:tcplisten2:20">4</A></DD>
<DT><A class="idx" href="#tcp_open_socket/3">tcp_open_socket/3</A></DT>
<DD>
<A class="idx" href="#idx:tcpopensocket3:24">4</A></DD>
<DT><A class="idx" href="#tcp_setopt/2">tcp_setopt/2</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#tcp_socket/1">tcp_socket/1</A></DT>
<DD>
<A class="idx" href="#idx:tcpsocket1:40">4.4</A></DD>
<DT>term_to_atom/2</DT>
<DD>
<A class="idx" href="#idx:termtoatom2:51">9</A></DD>
<DT><STRONG>U</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#udp_receive/4">udp_receive/4</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#udp_send/4">udp_send/4</A></DT>
<DD>
<A class="idx" href="#idx:udpsend4:25">4</A></DD>
<DT><A class="idx" href="#udp_socket/1">udp_socket/1</A></DT>
<DD>
</DD>
<DT><STRONG>W</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#wait/2">wait/2</A></DT>
<DD>
<A class="idx" href="#idx:wait2:3">2</A></DD>
<DT>wait_for_input/3</DT>
<DD>
<A class="idx" href="#idx:waitforinput3:11">4</A> <A class="idx" href="#idx:waitforinput3:29">4.1</A> <A class="idx" href="#idx:waitforinput3:33">4.2</A> <A class="idx" href="#idx:waitforinput3:35">4.3</A> <A class="idx" href="#idx:waitforinput3:38">4.3</A> <A class="idx" href="#idx:waitforinput3:42">4.4</A></DD>
</DL>

</BODY></HTML>