\chapter{The relation between PCE and Prolog} \label{sec:pceprolog}

PCE and Prolog are very different systems based on a very different
programming paradigm.  PCE objects have global state and use
destructive assignment.  PCE programming constructs use both
procedures (code objects and send-methods) and functions (function
objects and get-methods).  PCE has no notion of non-determinism as
Prolog has.

The hybrid PCE/Prolog environment allows the user to express
functionality both in Prolog and in PCE.  This chapter discusses
representation of data and dealing with object-references in
PCE/Prolog.


\section{PCE is not Prolog!}		\label{sec:notprolog}

Data managed by Prolog consists of logical variables, atoms, integers,
floats and compound terms (including lists).  PCE has natural
counterparts for atoms (a \class{name} object), integers (a PCE int) and
floating point numbers (a \class{real} object).  Prolog logical variables and
compound terms however have no direct counterpart in the PCE
environment.  PCE has variables (class \class{var}), but these obey
totally different scoping and binding rules.

Where Prolog uses a compound term to represent data that belongs
together (e.g.\ person(Name, Age, Address)), PCE uses objects for this
purpose:%
    \footnote{This example uses PCE user-defined classes.  The details
	      of this mechanism do not matter for the argument in this
	      section. User-defined classes are described in
	      \chapref{udc}.}

\begin{code}
:- pce_begin_class(person(name, age, address), object).

variable(name,		name,	both, "Name of the person").
variable(age,		int,	both, "Age in years").
variable(address,	string,	both, "Full address").

initialise(P, Name:name, Age:int, Address:string) :->
	"Create from name, age and address"::
	send(P, name, Name),
	send(P, age, Age),
	send(P, address, Address).

:- pce_end_class.

1 ?- new(P, person(fred, 30, 'Long Street 45')).
P = @3664437/person
\end{code}

These two representations have very different properties:

\begin{itemize}
    \tick{Equality}
Prolog cannot distinguish between `{\tt person('Fred', 30, 'Long Street
45')}' and a second instance of the same term. In PCE two instances of
the same class having the same state are different entities.
    \tick{Attributes}
Whereas an attribute (argument) of a Prolog term is either a logical
variable or instantiated to a Prolog data object, an attribute of
an object may be assigned to.  The assignment is destructive.
    \tick{Types}
PCE is a partially dynamically typed language and PCE object attributes
may have types. Prolog is untyped.
\end{itemize}

Because there is no straight-forward translation from Prolog data
structures into PCE objects it is not possible to pass Prolog data
through PCE control structures.  We will illustrate this using the
code object declared below:

\begin{code}
1 ?- new(@m, and(message(@prolog, write, @arg1),
		 message(@prolog, nl))).
\end{code}

This code object will print the provided argument in the Prolog window
followed by a newline:

\begin{code}
2 ?- send(@m, forward, hello).
hello
\end{code}

From this example one might expect that PCE is transparent to
Prolog data.  This is true for integers, floats and atoms as these
have a natural representation in both languages.  However:

\begin{code}
3 ?- send(@m, forward, chain(hello)).
@774516
4 ?- send(@m, forward, 3 + 4).
7
5 ?- send(@m, forward, [hello, world]).
[PCE warning: new: Unknown class: .
        in: new(.(world, [])) ]
\end{code}

In all these examples the argument is a Prolog compound term which
---according to the definition of send/3--- is translated into a PCE
instance of the class of the principal functor.  In 3) this is an
instance of class \class{chain}.  In 4) this is an instance of class
\class{+}.  Class \class{+} however is a subclass of the PCE class
\class{function} and \idx{function} objects are evaluated when given
to a method that does not accept a function-type argument.  In 5) this
Prolog list actually is the term .(hello,.(world,[])) (see the
Prolog predicate display/2).  As PCE does not define a class `.'
an error message results.

Below is a very realistic example of this misconception.

\begin{pcecode}
?- new(D, dialog('Bug')),
   send(D, append, button(verbose,
			  message(@prolog, assert,
				  verbose(on)))),
   send(D, open).
[PCE warning: new: Unknown class: verbose
        in: new(verbose(on)) ]
\end{pcecode}

A correct solution for this task is.

\begin{pcecode}
make_verbose_dialog :-
	new(D, dialog('Correct')),
	send(D, append,
	     button(verbose,
		    message(@prolog, set_verbose, on))),
	send(D, open).

set_verbose(Value) :-
	retractall(verbose(_)),
	assert(verbose(Value)).
\end{pcecode}

\mbox{}
