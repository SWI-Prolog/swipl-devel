\section{Playing WEB (HTTP) server}		\label{sec:httpd}

Web presentation has attractive features. It is well accepted,
standardised (if you stick to the basics) and network-transparent. Many
people think you need a web-server like
\url[Apache]{http://www.apache.org} with some sort of server-scripting
(\idx{CGI}) to realise a server.  This is not true.  Any application
capable of elementary TCP/IP communication can easily act as a
web-server.

Using \product{} for this task may be attractive for a number of
reasons.

\begin{itemlist}
    \item [Prototyping]
As the \productpl{} running on your desktop is the server you can use
the full debugging capabilities of Prolog to debug your server
application.

    \item [Including graphics]
\product{} can generate GIF and JPEG images for your web-pages on the
fly.  You can include \product{} \class{graphical} objects directly
in the output and have the server library handle the required
transformations.

    \item [Remote presentation]
\product{} can be used as \idx{groupware} server, presenting state of
the applications and allowing remote users to interact using their
web-browser%
	\footnote{Using the Unix/X11 version \product{} can manage
		  windows on multiple desktops.  For MS-Windows users
		  this is not supported.}

    \item [Report generation]
Applications may to use HTML as framework for report generation.  Though
rather weak in its expressiveness, the advantage is the wide support on
presentation and distribution applications.
\end{itemlist}

We start with a small demo, illustrating frames and text.

\postscriptfig[width=0.9\linewidth]{httpd}{Mozilla showing \product{}
					   regerated figure}

\input{httpd-ex}

\subsection{Class \class{httpd}}

The library \pllib{http/httpd} defines the class \class{httpd}. This
subclass of \class{socket} deals with most of the HTTP protocol details,
breaking down HTTP requests and encapsulating responses with the proper
headers. The class itself is an \jargon{abstract} class, a subclass
needs to be created and some of the \jargon{virtual methods} needs to be
refined to arrive at a useful application.

\begin{description}
    \sendmethod{httpd}{initialise}{Port:[int]}
Create a server and bind it to \arg{Port}. If \arg{Port} is omitted a
free port is choosen. With a specified port, 8080 is a commonly used
alternative to the standard 80 used by web-servers.  If you have a
web-server running on the same machine you may can generate a page
on your website redirecting a page to this server.  The URI of this
server is \mbox{\tt http://<host>/<Port>}.

    \sendmethod{httpd}{accepted}{}
This is sent after a connection has been accepted.  The system
implementation logs the new connection if debugging is enabled.  You
can refine or redefine this method, asking for the `socket<-peer_name'
and sending ->free to the socket if you want to restrict access.

    \sendmethod{httpd}{request}{Data:sheet}
This is sent from ->input after a complete request-header is received.
->input decodes the header-fields, places them in \arg{Data} and then
calls ->request.  The attribute-names in the sheet are downcase versions
of the case-insensitive request fields of the HTTP header.  In addition,
the following fields are defined:

\begin{center}
\begin{tabular}{|l|p{0.7\linewidth}|}
\hline
\multicolumn{2}{|c|}{\bf Fields that are always present} \\
\hline
request		& \const{GET}, \const{POST}, etc.  I.e.\ the first word
		  of the request-header.  In most cases this will be
		  \const{GET}. \\
path		& The `path' part of the request.  This is normally used
		  to decide on the response.  If the path contains a ?
		  (question mark) this and the remaining data are removed
		  and decoded to the `form' attribute. \\
form		& If the request is a \const{GET} request with form-data,
		  the form attribute contains another sheet holding the
		  decoded form-data.  Otherwise <-form holds @nil. \\
http_version    & Version of the HTTP protocol used by the client. Normally
		  \const{1.0} or \const{1.1}. \\
\hline
\multicolumn{2}{|c|}{\bf Other fields} \\
\hline
user		& If authorization data is present, this contains the
		  user-name.  If this field is present, the password
		  field is present too. \\
password	& Contains the decoded password supplied by the user. \\
\hline
\end{tabular}
\end{center}

After decoding the request, the user should compose a response and use
->reply or ->reply_html to return the response to the client.

    \sendmethod{httpd}{reply}{%
      Data:string|source_sink|pixmap,
      Type:[name],
      Status:[name],
      Header:[sheet]}
Send a reply.  This method or ->reply_html is normally activated at the
end of the user's ->request implementation.  Data is one of:

\begin{itemlist}
    \item[A string or source_sink]
If the reply is a \class{string}, \class{text_buffer}, \class{resource}
or \class{file}, the data in this object will be returned.  Unless otherwise
specified ->reply assumes the data has \idx{mime-type} \const{text/plain}.

    \item[A pixmap]
If the reply is a \class{pixmap} (or can be converted automatically, for
example any \class{graphical}), this image is encoded as GIF or JPEG and
sent with the corresponding \idx{image/gif} or \idx{image/jpeg} mime-type.
For more information on image save-types, see `image->save_in'.
\end{itemlist}

\arg{Type} is the mimi-type returned and tells the browser what to do with
the data.  This should correspond with the content of \arg{Data}.  For
example, you can return a PNG picture from a file using

\begin{code}
	send(HTTPD, reply, file('pict.png'), 'image/png'),
\end{code}

\arg{Status} is used to tell the client in a formal way how the request
was processed.  The default is \const{200 OK}.  See the methods below
for returning other values.

\arg{Header} is a \class{sheet} holding additional name-value pairs.
If present, they are simply added to the end of the reply-header.  For
example if you want to prevent the browser caching the result you can use

\begin{code}
	send(HTTPD, reply, ...,
	     sheet(attribute('Cache-Control', 'no-cache'))),
\end{code}

    \sendmethod{httpd}{reply_html}{%
	Term:prolog,
        Status:[name],
	Header:[sheet]}
Uses the \pllib{http/html_write} library to translate \arg{Term} into
HTML text using DCG rules and then invokes ->reply using the \arg{Type}
\const{text/html}.  \arg{Status} and \arg{Header} are passed unmodified
to ->reply.
\end{description}

In addition to the principal methods above, a number of methods are
defined for dealing with abnormal replies such as denying permission,
etc.

\begin{description}
    \sendmethod{httpd}{forbidden}{What:[name]}
Replies with a \const{403 Forbidden} message.  \arg{What} may be provided
to indicate what is forbidden.  Default is the path from the current
<-request.

    \sendmethod{httpd}{authorization_required}{%
	 Method:[\{Basic\}], Realm:[name]}
Challenges the user to provide a name and password. The only method
provided is \const{Basic}. \arg{Realm} tells the user for which service
permission is requested. On all subsequence contacts from this client to
this server the ->request data contains the \const{user} and
\const{password} fields.  The demo implementation of ->request in
\class{httpd} contains the following example code:

\begin{pcecode}
request(S, Header:sheet) :->
	"Process a request.  The argument is the header"::
	(   get(Header, path, '/no')
	->  send(S, forbidden, '/no')
	;   get(Header, path, '/maybe')
	->  (   get(Header, value, user, jan),
	        get(Header, value, password, test)
	    ->	send(S, reply, 'You hacked me')
	    ;	send(S, authorization_required)
	    )
	;   send(S, reply, 'Nice try')
	).
\end{pcecode}

    \sendmethod{httpd}{not_found}{What:[char_array]}
Reply with a \const{404 Not Found} message, using the request-path as
default for \arg{What}.

    \sendmethod{httpd}{moved}{Where:char_array}
Reply with a \const{301 Moved Permanently}.  Normally the client will
retry the request using the URL returned in \arg{Where}.

    \sendmethod{httpd}{server_error}{What:[char_array]}
Reply with a \const{500 Internal Server} using `\arg{What} as additional
information to the user.  This is the default reply if ->request fails
or raised an exception.
\end{description}


\subsection{The ``http/html_write'' library}	\label{sec:htmlwrite}

\newcommand{\DCG}[3]{\predicate{#1}{#2}{#3}}
\newcommand{\elem}[1]{\const{#1}}
\newcommand{\bsl}{$\tt\backslash$}
 

Producing output for the web in the form of an HTML document is a
requirement for many Prolog programs. Just using format/2 is
satisfactory as it leads to poorly readable programs generating poor
HTML. This library is based on using DCG rules.

The \pllib{pl/html_write} is intended to structure the generation of
HTML from a program. It is an extensible library, providing a
\jargon{DCG} framework for generation of legal HTML under (Prolog)
program control. It is especially useful for the generation of
structured pages (tables) from Prolog data structures.

The normal way to use this library is through the DCG html/1. This
grammar-rule provides the central translation from a structured term
with embedded calls to additional translation rules to a list of atoms
that can then be printed using print_html/[1,2].

\begin{description}
    \DCG{html}{1}{:Spec}
The DCG rule html/1 is the main predicate of this library. It translates
the specification for an HTML page into a list of atoms that can be
written to a stream using print_html/[1,2]. The expansion rules of this
predicate may be extended by defining the multifile DCG
html_write:expand/1. \arg{Spec} is either a single specification or a
list of single specifications. Using nested lists is not allowed to
avoid ambiguity caused by the atom \const{[]}

\begin{itemlist}
    \item [Atomic data]
Atomic data is quoted using the html_quoted/1 DCG.

    \item [\arg{Fmt} - \arg{Args}]
\arg{Fmt} and \arg{Args} are used as format-specification and argument
list to sformat/3. The result is quoted and added to the output list.

    \item [\bsl\arg{List}]
Escape sequence to add atoms directly to the output list.  This can be
used to embed external HTML code.

    \item [\bsl\arg{Term}]
Invoke the grammar rule \arg{Term} in the calling module.  This is the
common mechanism to realise abstraction and modularisation in generating
HTML.

    \item [\arg{Module}:\arg{Term}]
Invoke the grammar rule <Module>:<Term>. This is similar to
\bsl\arg{Term} but allows for invoking grammar rules in external
packages.

    \item [\&(Entity)]
Emit {\tt\&<Entity>;}.

    \item [\term{Tag}{Content}]
Emit HTML element \arg{Tag} using \arg{Content} and no attributes.
\arg{Content} is handled to html/1. See \secref{htmllayout} for details
on the automatically generated layout.

    \item [\term{Tag}{Attributes, Content}]
Emit HTML element \arg{Tag} using \arg{Attributes} and \arg{Content}.
\arg{Attributes} is either a single attribute of a list of attributes.
Each attributes is of the format \term{Name}{Value} or
\term{Name}{Value}.
\end{itemlist}

    \DCG{page}{2}{:HeadContent, :BodyContent}
The DCG rule page/2 generated a complete page, including the SGML
\const{DOCTYPE} declaration. \arg{HeadContent} are elements to be placed
in the \elem{head} element and \arg{BodyContent} are elements to be
placed in the \elem{body} element.

To achieve common style (background, page header and footer), it is
possible to define DCG rules head/1 and/or body/1. The page/1 rule
checks for the definition of these DCG rules in the module it is called
from as well as in the \const{user} module. If no definition is found, it
creates a head with only the \arg{HeadContent} (note that the
\elem{title} is obligatory) and a \elem{body} with \const{bgcolor} set
to \const{white} and the provided \arg{BodyContent}.

Note that further customisation is easily achieved using html/1 directly
as page/2 is (besides handling the hooks) defined as:

\begin{code}
page(Head, Body) -->
	html([ \['<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">\n'],
	       html([ head(Head),
		      body(bgcolor(white), Body)
		    ])
	     ]).
\end{code}

    \DCG{page}{1}{:Contents}
This version of the page/[1,2] only gives you the SGML \const{DOCTYPE}
and the \elem{HTML} element. \arg{Contents} is used to generate both the
head and body of the page.

    \DCG{html_begin}{1}{+Begin}
Just open the given element.  \arg{Begin} is either an atom or a
compound term,  In the latter case the arguments are used as arguments
to the begin-tag.  Some examples:

\begin{code}
	html_begin(table)
	html_begin(table(border(2), align(center)))
\end{code}

This predicate provides an alternative to using the
\bsl\arg{Command} syntax in the html/1 specification. The
following two fragments are the same. The preferred solution depends on
your preferences as well as whether the specification is generated or
entered by the programmer.

\begin{code}
table(Rows) -->
	html(table([border(1), align(center), width('80%')],
		   [ \table_header,
		     \table_rows(Rows)
		   ])).

% or

table(Rows) -->
	html_begin(table(border(1), align(center), width('80%'))),
	table_header,
	table_rows,
	html_end(table).
\end{code}

    \DCG{html_end}{+End}
End an element.  See html_begin/1 for details.
\end{description}


\subsubsection{Emitting HTML documents}

The html/1 grammar rules translates a specification into a list of atoms
and layout instructions. Currently the layout instructions are terms of
the format \term{nl}{N}, requesting at least \arg{N} newlines. Multiple
consequtive \term{nl}{1} terms are combined to an atom containing the
maximum of the requested number of newline characters.

To simplify handing the data to a client or storing it into a file,
the following predicates are available from this library:

\begin{description}
    \predicate{print_html}{1}{+List}
Print the token list to the Prolog current output stream.
    \predicate{print_html}{2}{+Stream, +List}
Print the token list to the specified output stream
    \predicate{html_print_length}{2}{+List, -Length}
When calling html_print/[1,2] on \arg{List}, \arg{Length}
characters will be produced.  Knowing the length is needed to
provide the \const{Content-length} field of an HTTP reply-header.
\end{description}


\subsubsection{Adding rules for html/1}

In some cases it is practical to extend the translations imposed by
html/1. When using \product{} for example, it is comfortable to be able
defining default translation to HTML for objects. We also used this
technique to define translation rules for the output of the SWI-Prolog
\pllib{sgml} package.

The html/1 rule first calls the multifile ruleset html_write:expand/1.
The other predicates contain commonly rules for defining new rules.

\begin{description}
    \DCG{html_write:expand}{1}{+Spec} Hook to add additional
translationrules for html/1. \DCG{html_quoted}{1}{+Atom} Emit the text
in \arg{Atom}, inserting entity-references for the SGML special
characters \verb$<&>$. \DCG{html_quoted_attribute}{1}{+Atom} Emit the
text in \arg{Atom} suitable for use as an SGML attribute, inserting
entity-references for the SGML special characters \verb$<&>'"$.
\end{description}


\subsubsection{Generating layout}		\label{sec:htmllayout}

Though not strictly necessary, the library attempts to generate
reasonable layout in SGML output. It does this only by inserting
newlines before and after tags. It does this on the basis of the
multifile predicate html_write:layout/3

\begin{description}
    \predicate{html_write:layout}{3}{+Tag, -Open, -Close}
Specify the layout conventions for the element \arg{Tag}, which is a
lowercase atom. \arg{Open} is a term \arg{Pre}-\arg{Post}. It defines
that the element should have at least \arg{Pre} newline characters
before and \arg{Post} after the tag. The \arg{Close} specification is
similar, but in addition allows for the atom \const{-}, requesting the
output generator to omit the close-tag altogether or \const{empty},
telling the library that the element has declared empty content. In this
case the close-tag is not emitted either, but in addition html/1
interprets \arg{Arg} in \term{Tag}{Arg} as a list of attributes rather
than the content.

A tag that does not appear in this table is emitted without additional
layout. See also print_html/[1,2]. Please consult the
library source for examples.
\end{description}


\subsubsection{Examples}

In the following example we will generate a table of Prolog predicates
we find from the SWI-Prolog help system based on a keyword. The primary
database is defined by the predicate predicate/5 We will make hyperlinks
for the predicates pointing to their documentation.

\begin{code}
html_apropos(Kwd) :-
	findall(Pred, apropos_predicate(Kwd, Pred), Matches),
	phrase(apropos_page(Kwd, Matches), Tokens),
	print_html(Tokens).

%	emit page with title, header and table of matches

apropos_page(Kwd, Matches) -->
	page([ title(['Predicates for ', Kwd])
	     ],
	     [ h2(align(center),
		  ['Predicates for ', Kwd]),
	       table([ align(center),
		       border(1),
		       width('80%')
		     ],
		     [ tr([ th('Predicate'),
			    th('Summary')
			  ])
		     | \apropos_rows(Matches)
		     ])
	     ]).

%	emit the rows for the body of the table.

apropos_rows([]) -->
	[].
apropos_rows([pred(Name, Arity, Summary)|T]) -->
	html([ tr([ td(\predref(Name/Arity)),
		    td(em(Summary))
		  ])
	     ]),
	apropos_rows(T).

%	predref(Name/Arity)
%
%	Emit Name/Arity as a hyperlink to
%
%		/cgi-bin/plman?name=Name&arity=Arity
%
%	we must do form-encoding for the name as it may contain illegal
%	characters.  www_form_encode/2 is defined in library(url).

predref(Name/Arity) -->
	{ www_form_encode(Name, Encoded),
	  sformat(Href, '/cgi-bin/plman?name=~w&arity=~w',
		  [Encoded, Arity])
	},
	html(a(href(Href), [Name, /, Arity])).

%	Find predicates from a keyword. '$apropos_match' is an internal
%	undocumented predicate.

apropos_predicate(Pattern, pred(Name, Arity, Summary)) :-
	predicate(Name, Arity, Summary, _, _),
	(   '$apropos_match'(Pattern, Name)
	->  true
	;   '$apropos_match'(Pattern, Summary)
	).
\end{code}



\subsubsection{Final remarks}

This library is the result of various attempts to reach at a more
satisfactory and Prolog-minded way to produce HTML text from a program.
We have been using Prolog for the generation of web pages in a number of
projects. Just using format/2 never was a real
option, generating error-prone HTML from clumsy syntax.  We started
with a layour on top of format, keeping track of the current nesting
and thus always capable of properly closing the environment.

DCG based translation however naturally exploits Prologs term-rewriting
primitives.  If generation fails for whatever reason it is easy to
produce an alternative document (for example holding an error message).

The approach presented in this library has been used in combination with
\pllib{http/httpd} in three projects: viewing RDF in a browser,
selecting fragments from an analysed document and presenting parts of
the \product{} documentation using a browser. It has proven to be able to deal
with generating pages quickly and comfortably.

In a future version we will probably define a goal_expansion/2 to do
compile-time optimisation of the library. Quotation of known text and
invokation of sub-rules using the \bsl\arg{RuleSet} and
<Module>:<RuleSet> operators are costly operations in the analysis
that can be done at compile-time.
