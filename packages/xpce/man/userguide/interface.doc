\chapter{Interface predicate definition} \label{sec:interface}

This appendix provides a description of the Prolog predicates
to communicate with PCE.  Most of these predicates have been
introduced informally in the previous sections.  Predicates only supporting
the definition of user-defined classes are described in \cite{PCE:udc}.

\section{Basic predicates}

This section describes the basic interface predicates.  These
predicates reside in the library module `pce', which is loaded when
Prolog is started with PCE loaded on top of it.

\begin{description}
    \predicate{new}{2}{?Reference, +TermDescription}
Create a PCE object from \arg{TermDescription} and either unify an
integer reference (e.g.\ @2535252) with \arg{Reference} or give the
new object the provided atomic reference (e.g. @my_diagram).  The
argument \arg{TermDescription} is a complex term of the form
\mbox{Functor(...InitArg...)}.  \arg{Functor} denotes the class from
which to create an object and \arg{InitArg} are the initialisation
arguments for the object creation.  Each \arg{InitArg} is translated
to a PCE data object and may be an integer, atom (translated into
a PCE name object), object reference (e.g.\ @2535252 or @pce) or
complex term.  When the latter is encountered, it is transformed
into a PCE object just as \arg{TermDescription}.  Finally, an argument
may be of the form \mbox{new(+TermDescription)} or
\mbox{new(?Reference, +TermDescription)}.  The first forces an
atom to be translated into an instance of the named class instead of a
PCE name object.  The latter provides access to the reference of the
object provided as an argument.  The following sequences illustrate
this.  Each of them provides the same object structure in PCE.

\begin{code}
1 ?- new(@icon_viewer, dialog('Icon Viewer 1')),
     new(P, picture),
     send(P, below, @icon_viewer),
     new(TI, text_item(name, '',
		       and(message(P, display, @arg1),
			   message(@arg1, recogniser,
				   new(move_gesture))))),
     send(TI, type, bitmap),
     send(@icon_viewer, append, TI),
     send(@icon_viewer, open).

2 ?- D = @icon_viewer,
     new(D, dialog('Icon Viewer 1')),
     send(new(P, picture), below, D),
     send(D, append,
	  new(TI, text_item(name, '',
		            and(message(P, display, @arg1),
			        message(@arg1, recogniser,
				        new(move_gesture)))))),
     send(TI, type, bitmap),
     send(D, open).
\end{code}

Using new/2 with a variable reference argument is equivalent to
invoking `Class <-instance: InitArgs ...'.  The arguments needed 
to instantiate a class are defined by the ->initialise method
of this class.  See also section~\ref{sec:classbrowser}.

    \predicate{send}{2-12}{+Receiver, +Selector, +Argument...}
Invoke a send-method on the \arg{Receiver}.  \arg{Receiver} is
processed as the \arg{InitArgs} described with new/2.  This implies
that a complex term is translated into an object before the method is
invoked.  An atom is translated into an PCE name object.
\arg{Selector} is a Prolog atom which is translated into a PCE name
object.  The \arg{Argument}s are processed as the \arg{InitArgs}
described with new/2.

The predicate send/[2-12] fails with an error message if one of the
arguments cannot be translated or there is a type-error or an
argument-error.  The method itself may also produce error messages.
This predicate only succeeds if the requested method was executed
successfully.

    \predicate{get}{[3-13]}{+Receiver, +Selector, +Argument..., -Result}
Invoke a get-method on \arg{Receiver}.  \arg{Receiver}, \arg{Selector}
and \arg{Argument...} are processed as with send/[2-12].  If the method
fails, this predicate fails too.  Otherwise the PCE result of invoking
the method is unified with \arg{Result}.

If the return value is a PCE integer, real object or name object, it
is unified with a Prolog integer, float or atom.  Otherwise if the
Prolog return argument is a variable or a term @/1 it is unified with
the object reference.  Otherwise the Prolog argument should be a
compound term.  Its functor will be compared with the class-name of
the PCE return value.  The arguments will be unified in the same
manner with the term-description arguments as declared with the class.
Examples:

\begin{code}
1 ?- get(@pce, user, User).
User = fred
2 ?- get(@display, size, Size).
Size = @474573
3 ?- get(@display, size, size(W, H)).
W = 1152, H = 900
\end{code}

It is not advised to use the latter construct for other objects than
elementary objects such as point, area, size, string, etc..

    \predicate{free}{1}{+Reference}
Send ->free to {\em Reference} if it is a valid reference.  Defined as
\begin{code}
free(Ref) :- object(Ref), !, send(Ref, free).
free(_).
\end{code}
This definition implies free/1 only fails if the object may not be
freed (see `object ->protect').
    \predicate{object}{1}{+Reference}
Succeeds if \arg{Reference} is a term of the form @/1 and the argument
is a valid object reference.  Fails silently otherwise.  Note that the
form @Integer is only save to test whether or not an object has
already been freed as a side-effect of freeing another object.
Consider the following example:
\begin{code}
1 ?- new(P, point(100,100)).
P = @235636/point
2 ?- send(@235636, free).
3 ?- object(@235636).		---> fail
4 ?- new(S, size(50,50)).
S = @235636/size
\end{code}
If ->free is invoked on an object that has no references, its memory
will be reclaimed immediately.  As long as the memory has not been
reused object/1 is guaranteed to fail.  If the memory is reused for
storing a new object object/1 will succeed, but point to another
object than expected.  Finally, the memory may be reused by a
non-object data structure.  In this case object/1 only applies
heuristics to detect whether the memory holds an object.
See also section~\ref{sec:debugging} and \ref{sec:global}
    \predicate{object}{2}{+Reference, -TermDescription}
Unify object description with the argument.  Normally only used for
debugging purposes.  Equivalent to:
\begin{code}
object(Ref, Term) :-
	object(Ref),
	get_object(Ref, self, Term).
\end{code}

    \directive{pce_global}{2}{+Reference, +Create}
Define exception handler for undefined global (named) reference.
When PCE refers to a non-existing named reference an exception is
raised.  The standard handler for this exception will scan the
pce_global/2 database and execute the \arg{Create} action.
\arg{Create} is either a term of the form new(+TermDescription) or
another term.  In the first case \arg{TermDescription} is transformed
into a PCE object as the second argument of new/2.  In the latter
case, \arg{Reference} is appended to the list of arguments
of the term and the term is called as a Prolog goal:

\begin{code}
:- pce_global(@succeed, new(and)).
:- pce_global(@event_receiver, new(@event?receiver)).
:- pce_global(@select_recogniser, make_select_recogniser).

make_select_recogniser(R) :-
	new(G, handler_group),
	send_list(G, append,
	  [ click_gesture(left, '', single,
			  message(@event_receiver?device,
				  selection, @event_receiver))
	  , click_gesture(left, s, single,
			  message(@event_receiver,
				  toggle_selected))
	  ]).
\end{code}

See section~\ref{sec:pceprolog} for more examples.

\predicate{pce_catch_error}{2}{+ErrorIds, +Goal}
This predicates allows the application to handle errors occuring while
\arg{Goal} is called.  \arg{ErrorIds} is either an atom representing
the id of PCE error or a chain of such id's.  If one of the given
errors occurrs the goal will silently fail and `@pce <-last_error'
holds the id of the trapped error.  Any other error that occurs during
the execution of \arg{Goal} will be handled by PCE's normal error
handling mechanism.  See section~\ref{sec:errors}.
\end{description}


\section{Library predicates}

\index{library (PCE/Prolog-)}\index{autoloading}%
This section describes the predicates available from the PCE/Prolog
library.  Users of SWI-Prolog can activate these predicates without
importing them explicitely as they will be autoloaded.  Users of
SICStus Prolog should declare these predicates using the require/1
directive \cite{SICStus:manual}.


\subsection{Library ``pce_util''}

The predicates in this section used to be PCE principal predicates.
Changes to PCE, the interface and our current understanding about
programming the PCE/Prolog environment have made these predicates less
important.


\begin{description}
    \predicate{send_list}{2,3}{+Receiver, +Selector [, +Argument]}
Invoke send-behaviour as send/[2-12].  Each of the arguments is
either as accepted by send/[2-12] or a list of such arguments.
The definition of send_list/2 is below.

\begin{code}
send_list([], _) :- !.
send_list(_, []) :- !.
send_list([Object|Objects], Selectors) :- !, 
	send_list(Object, Selectors), 
	send_list(Objects, Selectors).
send_list(Object, [Selector|Selectors]) :- !, 
	send_list(Object, Selector), 
	send_list(Object, Selectors).
send_list(Object, Selector) :-
	send(Object, Selector).
\end{code}

    \predicate{get_object}{[3-13]}{+Receiver, +Selector, +Argument..., -Result}
Equivalent to get/[3-13], but instead of unifying a variable with a
reference the variable is unified with the term-description.  The
arguments are unified as in get/[3-13].  Normally only used from the 
Prolog toplevel for debugging purposes.

    \predicate{chain_list}{2}{+Chain, -List}
Translates a PCE chain into a Prolog list.  This may be useful to
exploit Prolog's list-processing primitives.  Note however that PCE
chains define various operations that may be exploited to avoid the
translation.  Suppose `Pict' is a picture and `Pos' is a point object.
We want to determine the topmost graphical object overlapping with
`Pos'.  The following two programs are identical:
\begin{code}
topmost_graphical(Pict, Pos, Gr) :-
	get(Pict, graphicals, Grs0),
	chain_list(Grs0, Grs1),
	topmost(Grs1, Pos, @nil, Gr),
	Gr \== @nil.

topmost([], _, Gr, Gr).
topmost([H|T], Pos, _, Gr) :-
	send(H, overlap, Pos), !,
	topmost(T, Pos, H, Gr).
topmost([_|T], Pos, Gr0, Gr) :-
	topmost(T, Pos, Gr0, Gr).
\end{code}
Or, using PCE's list processing:
\begin{code}
topmost_graphical(Dev, Pos, Gr) :-
	get(Dev, graphicals, Grs),
	get(Grs, find_all, message(@arg1, overlap, Pos), O),
	get(O, tail, Gr),
	send(O, done).
\end{code}
The second implementation is not only shorter, it also requires far less
data conversions between Prolog and PCE and is therefore much faster.

    \predicate{get_chain}{3}{+Receiver, +Selector, -List}
Utility predicate implemented as:
\begin{code}
get_chain(Receiver, Selector, List) :-
	get(Receiver, Selector, Chain),
	chain_list(Chain, List).
\end{code}
See comments with chain_list/2.
\end{description}

\subsection{Library ``pce_debug''}

The predicates in this section provide shorthands for common
commands for debugging PCE programs.

\begin{description}
\noargpredicate{debugpce}
Switch PCE into `debugging' mode.  This includes some additional
runtime checks and makes PCE sensitive `debug_subjects' (see
debugpce/1).  Invokes `@pce ->debugging: @on'.
\noargpredicate{nodebugpce}
Switches debugging off.
\predicate{debugpce}{1}{+Subject}
Enable printing of debugging messages on indicated \arg{Subject}.  Invokes
`@pce ->debug_subject: Subject'.  See the description of this method in
the online manual for available subjects.
\predicate{nodebugpce}{1}{+Subject}
Disable debugging messages on \arg{Subject}.
\noargpredicate{tracepce}
Start tracing PCE's virtual machine instructions.  Equivalent to
send(class(vmi), trace, @on).
\noargpredicate{notracepce}
Switch the interactive tracer off.  Equivalent to send(@pce, trace, never).
\predicate{tracepce}{1}{+Class \verb$<-|->$ Selector}
Find send- (\verb$->$) or get- (\verb$<-$) method and invokes
`Method ->trace: @on' on this method.  Prints the method on which it has
set the trace-point.

Syntax note:  (\verb$->$) is a standard Prolog operator with
$priority > 1000$.  Therefore many Prolog systems require additional
brackets:
\line{?- tracepce((graphical ->selected))}
In SWI-Prolog this is not necessary.  To be able to trace get-methods
with this predicate (\verb$<-$) must be declared as an infix operator.
\predicate{notracepce}{1}{+Class \verb$<-|->$ Selector}
Disables trace-point set with tracepce/1.
\noargpredicate{checkpce}
Collect all global (named-) objects and run `object ->_check' on them.
This performs various consistency checks on the objects and prints
diagnostic messages if something is wrong.  `object ->_check' checks
all objects it can (recursively) find through slot-references, chains,
vectors and hash-tables and deals properly with loops in the
data-structure.
\predicate{show_slots}{1}{+Reference}
Prints the values of all instance variables of \arg{Reference}:

\begin{code}
1 ?- new(@move_gesture, move_gesture).
2 ?- show_slots(@move_gesture).
@move_gesture/move_gesture
        active                @on/bool
        button                middle
        modifier              @810918/modifier
        condition             @nil/constant
        status                inactive
        cursor                @default/constant
        offset                @548249/point
\end{code}

A graphical tool for inspecting instance variables is described in
section~\ref{sec:inspector}.
\end{description}

\subsection{Library ``find_file''}

\index{file,prompting for}
This library file describes the class \class{finder}, representing
a modal dialog window for entering a filename.  This class defines
the method `finder <-file':

\begin{description}
    \getmethod{finder}{file}{Exists:[bool], Ext:[name],
			     Dir:[directory], Def:[file]}{name}
Process events util the user specified a file or pressed the cancel
button.  In the latter case this method fails. The normal way to use
this predicate is: 

\begin{code}
:- pce_autoload(finder, library(find_file)).
:- pce_global(@finder, new(finder)).

	...,
	get(@finder, file, @on, '.pl', PlFile),
	...,
\end{code}
\end{description}


\subsection{Library ``stayup_popup''}

\index{screendump,popup in}\index{popup,in screendump}
This library redefines the method `popup ->close'.  A popup menu may be
activated normally.  When the user holds the control-key depressed while
releasing the mouse-button the popup will remain on the display.
This enables the inclusion of (multiple) popup menus in a screendump.  See
also postscript/2 and the PceDraw `Edit' option `Import Frame'.

\subsection{Miscellaneous library predicates}

\begin{description}
\predicate{manpce}{[0-1]}{[+ClassName]}
Starts the online manual tools.  With an \arg{ClassName} argument,
the ``Class Browser'' tool is started on the specified class.
\noargpredicate{pcedemo}
Open demo-starter window.
\predicate{pcedraw}{1}{[+FileName]}
Open the drawing tool PceDraw.  With a given filename, load this file.
The `.pd' extension may be omitted.
\predicate{postscript}{2}{+Reference, +File}
Generate PostScript from the given object.  Defined as:

\begin{code}
postscript(Obj, File) :-
	extension(File, '.ps', FileName),
	new(F, file(FileName)),
	send(F, open, write),
	send(F, append, Obj?postscript),
	send(F, format, 'showpage\n'),
	send(F, close),
	get(F, size, Size),
	format('PostScript written to ~w, ~D bytes~n',
	       [FileName,Size]).
\end{code}
\predicate{show_key_bindings}{1}{+ViewOrEditor}
Show the key-bindings for view or editor object.  May be used as part
of a help-system.
\end{description}
