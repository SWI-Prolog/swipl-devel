\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\usepackage{verbatim}
\sloppy
\makeindex

\onefile
\htmloutput{.}			% Output directory
\htmlmainfile{semweb}		% Main document file
\bodycolor{white}		% Page colour

\renewcommand{\runningtitle}{SWI-Prolog/XPCE Semantic Web Library}

\newcommand{\elem}[1]{{\tt\string<#1\string>}}

\begin{document}

\title{SWI-Prolog/XPCE Semantic Web Library}
\author{Jan Wielemaker \\
	SWI, \\
	University of Amsterdam \\
	The Netherlands \\
	E-mail: \email{jan@swi.psy.uva.nl}}

\maketitle

\begin{abstract}
This document describes a library for dealing with standards from the
\url[W3C]{http://www.w3c.org/} standard for the \emph{Semantic Web}.
Like the standards themselves (RDF, RDFS and OWL) this infrastructure
is modular.  It consists of Prolog packages for reading, querying and
storing semantic web documents as well as XPCE libraries that provide
visualisation and editing.  The Prolog libraries can be used without
the XPCE GUI modules.  The library can handle upto about 2 million
\emph{RDF triples} on current commonly used hardware (256MB memory,
Pentium 1.5Ghz).
\end{abstract}

\vfill
\pagebreak
\tableofcontents

\newpage


\section{Introduction}

SWI-Prolog has started support for web-documents with the development of
a small and fast SGML/XML parser, followed by an RDF parser (early
2000). With the \file{semweb} library we provide more high level support
for manipulating semantic web documents.  The semantic web is the likely
point of orientation for knowledge representation in the future, making
a library designed in its spirit promising.


\section{Modules}

Central to this library is the module \file{rdf_db.pl}, providing
storage and basic querying for RDF triples. This triple store is filled
using the RDF parser realised by \file{rdf.pl}. The storage module can
quickly save and load (partial) databases. The modules \file{rdfs.pl}
and \file{owl.pl} add querying in terms of the more powerful RDFS and
OWL languages. Module \file{rdf_edit.pl} adds editing, undo, journaling
and change-forwarding. Finally, a variety of XPCE modules visualise and
edit the database. Figure \figref{modules} summarised the modular
design.

\postscriptfig[width=0.8\linewidth]{modules}
	{Modules for the Semantic Web library}


		 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		 %	      RDF_DB		%
		 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Module rdf_db}

The central module is called \file{rdf_db}.  It provides storage and
indexed querying of RDF triples.  Triples are stored as a quintuple.
The first three elements denote the RDF triple. \arg{File} and
\arg{Line} provide information about the origin of the triple.

\begin{quote}
\{\arg{Subject} \arg{Predicate} \arg{Object} \arg{File} \arg{Line}\}
\end{quote}

The actual storage is provided by the \jargon{foreign language (C)}
module \file{rdf_db.c}.  Using a dedicated C-based implementation we
can reduced memory usage and improve indexing capabilities.%
	\footnote{The orginal implementation was in Prolog.  This
		  version was implemented in 3 hours, where the C-based
		  implementation costed a full week.  The C-based
		  implementation requires about half the memory and
		  provides about twice the performance.}
Currently the following indexing is provided.

\begin{itemize}
    \item Any of the 3 fields of the triple
    \item \arg{Subject} + \arg{Predicate} and \arg{Predicate} + \arg{Object}
    \item \arg{Predicates} are indexed on the \jargon{highest property}.  In
          other words, if predicates are related through
	  \const{subPropertyOf} predicates indexing happens on the most
	  abstract predicate. This makes calls to rdf_has/4 very
	  efficient.
    \item String literal \arg{Objects} are indexed case-insensitive to make
          case-insensitive queries fully indexed. See rdf/3.
\end{itemize}

\subsection{Query the RDF database}

\begin{description}
    \predicate{rdf}{3}{?Subject, ?Predicate, ?Object}
Elementary query for triples. \arg{Subject} and \arg{Predicate} are
atoms representing the fully qualified URL of the resource. \arg{Object}
is either an atom representing a resource or \term{literal}{Value} if
the object is a literal value. If a value of the form
\infixterm{:}{NameSpaceID}{LocalName} is provided it is expanded to a
ground atom using expand_goal/2. This implies you can use this construct
in compiled code without paying a preformance penalty. See also
\secref{rdfns}.  Literal values take one of the following forms:

\begin{description}
    \termitem{Atom}{}
If the value is a simple atom it is the textual representation of
a string literal without explicit type or language (\const{xml:lang})
qualifier.

    \termitem{lang}{LangID, Atom}
\arg{Atom} represents the text of a string literal qualified with
the given language.

    \termitem{type}{TypeID, Value}
Used for attributes qualified using the \const{rdf:dataType}
\arg{TypeID}. The \arg{Value} is either the textual representation
or a natural Prolog representation.  See the option
\term{convert_typed_literal}{:Convertor} of the parser.  The storage
layer provides efficient handling of atoms, integers and floats.  All
other data is represented as a Prolog record.
\end{description}

For string querying purposes, \arg{Object} can be of the form
\term{literal}{+Query, -Value}, where \arg{Query} is one of

    \begin{description}
	\termitem{exact}{+Text}
    	    Perform exact, but case-insensitive match.  This query is
	    fully indexed.
	\termitem{substring}{+Text}
	    Match any literal that contains \arg{Text} as a case-insensitive
	    substring.  The query is not indexed on \arg{Object}.
	\termitem{word}{+Text}
	    Match any literal that contains \arg{Text} delimited by
	    a non alpha-numeric character, the start or end of the
	    string.  The query is not indexed on \arg{Object}.
	\termitem{prefix}{+Text}
	    Match any literal that starts with \arg{Text}.  This call
	    is intended for \jargon{completion}.  The query is not
	    indexed on \arg{Object}.
	\termitem{like}{+Pattern}
	    Match any literal that matches \arg{Pattern} case
	    insensitively, where the `*' character in \arg{Pattern}
	    matches zero or more characters.
    \end{description}

Backtracking never returns duplicate triples. Duplicates can be
retrieved using rdf/4.

    \predicate{rdf}{4}{?Subject, ?Predicate, ?Object, ?Source}
As rdf/3 but in addition return the source-location of the triple.  The
source is either a plain atom or a term of the format
\infixterm{:}{Atom}{Integer} where \arg{Atom} is intended to be used as
filename or URL and \arg{Integer} for representing the line-number.
Unlike rdf/3, this predicate does not remove duplicates from the result
set.

    \predicate{rdf_has}{4}{?Subject, ?Predicate, ?Object, -TriplePred}
This query exploits the RDFS \const{subPropertyOf} relation.  It 
returns any triple whose stored predicate equals \arg{Predicate} or
can reach this by following the recursive \arg{subPropertyOf} relation.
The actual stored predicate is returned in \arg{TriplePred}. The example
below gets all subclasses of an RDFS (or OWL) class, even if the
relation used is not \const{rdfs:subClassOf}, but a user-defined
sub-property thereof.%
	\footnote{This predicate realises semantics defined in
		  RDF-Schema rather than RDF.  It is part of the
		  \pllib{rdf_db} module because the indexing of
		  this module incorporates the  \const{rdfs:subClassOf}
		  predicate.}

\begin{code}
subclasses(Class, SubClasses) :-
	findall(S, rdf_has(S, rdfs:subClassOf, Class), SubClasses).
\end{code}

Note that rdf_has/4 and rdf_has/3 can return duplicate answers if
they use a different \arg{TriplePred}.

    \predicate{rdf_has}{3}{?Subject, ?Predicate, ?Object}
Same as \term{rdf_has}{Subject, Predicate, Object, _}.

    \predicate{rdf_reachable}{3}{?Subject, +Predicate, ?Object}
Is true if \arg{Object} can be reached from \arg{Subject} following
the transitive predicate \arg{Predicate} or a sub-property thereof.
When used with either \arg{Subject} or \arg{Object} unbound, it first
returns the origin, followed by the reachable nodes in breath-first
search-order.  It never generates the same node twice and is robust
against cycles in the transitive relation. With all arguments
instantiated it succeeds deterministically of the relation if a
path can be found from \arg{Subject} to \arg{Object}.  Searching
starts at \arg{Subject}, assuming the branching factor is normally
lower.  A call with both \arg{Subject} and \arg{Object} unbound
raises an instantiation error.  The following example generates
all subclasses of \const{rdfs:Resource}:

\begin{code}
?- rdf_reachable(X, rdfs:subClassOf, rdfs:'Resource').

X = 'http://www.w3.org/2000/01/rdf-schema#Resource' ;

X = 'http://www.w3.org/2000/01/rdf-schema#Class' ;

X = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#Property' ;

...
\end{code}

    \predicate{rdf_subject}{1}{?Subject}
Enumerate resources appearing as a subject in a triple.  The main reason
for this predicate is to generate the known subjects \emph{without
duplicates} as one gets using \term{rdf}{Subject, _, _}.
\end{description}


\subsection{Predicate properties}		\label{sec:predproperty}

The predicates below form an experimental interface to provide more
reasoning inside the kernel of the rdb_db engine. Note that
\const{symetric}, \const{inverse_of} and \const{transitive} are not yet
supported by the rest of the engine.

\begin{description}
    \predicate{rdf_set_predicate}{2}{+Predicate, +Property}
Define a property of the predicate.  Defined properties are listed
with rdf_predicate_property/2.

    \predicate{rdf_predicate_property}{2}{+Predicate, -Property}
Query properties of a defined predicate.  Currently defined properties
are given below.

    \begin{description}
	\termitem{symmetric}{Bool}
True if the predicate is defined to be symetric.  I.e.\ 
\mbox{\{A\} P \{B\}} implies \mbox{\{B\} P \{A\}}.

	\termitem{inverse_of}{Inverse}
True if this predicate is the inverse of \arg{Inverse}.

	\termitem{transitive}{Bool}
True if this predicate is transitive.

	\termitem{triples}{Triples}
Unify \arg{Triples} with the number of existing triples using
this predicate as second argument.  Reporting the number of 
triples is intended to support query optimization.

	\termitem{rdf_subject_branch_factor}{-Float}
Unify \arg{Float} with the average number of triples associated with
each unique value for the subject-side of this relation.  If there
are no triples the value 0.0 is returned.  This value is cached with
the predicate and recomputed only after substantial changes to the
triple set associated to this relation.  This property is indented
for path optimalisation when solving conjunctions of rdf/3 goals.

	\termitem{rdf_object_branch_factor}{-Float}
Unify \arg{Float} with the average number of triples associated with
each unique value for the object-side of this relation.  In addition
to the comments with the subject_branch_factor property, uniqueness
of the object value is computed from the hash key rather than the
actual values.

	\termitem{rdfs_subject_branch_factor}{-Float}
Same as \functor{rdf_subject_branch_factor}{1}, but also considering
triples of `subPropertyOf' this relation.  See also rdf_has/3.

	\termitem{rdfs_object_branch_factor}{-Float}
Same as \functor{rdf_object_branch_factor}{1}, but also considering
triples of `subPropertyOf' this relation. See also rdf_has/3.
    \end{description}
\end{description}


\subsection{Modifying the database}		\label{sec:rdfmodify}

As depicted in \figref{modules}, there are two levels of modification.
The \file{rdf_db} module simply modifies, where the \file{rdf_edit}
library provides transactions and undo on top of this.  Applications
that wish to use the \file{rdf_edit} layer must \emph{never} use the
predicates from this section directly.

\subsection{Modifying predicates}		\label{sec:modpreds}

\begin{description}
    \predicate{rdf_assert}{3}{+Subject, +Predicate, +Object}
Assert a new triple into the database. This is equivalent to
rdf_assert/4 using \arg{SourceRef} \const{user}. \arg{Subject} and
\arg{Predicate} are resources. \arg{Object} is either a resource or a
term \term{literal}{Value}. See rdf/3 for an explanation of \arg{Value}
for typed and language qualified literals. All arguments are subject to
name-space expansion (see \secref{rdfns}).

    \predicate{rdf_assert}{4}{+Subject, +Predicate, +Object, +SourceRef}
As rdf_assert/3, adding \arg{SourceRef} to specify the orgin of the
triple.  \arg{SourceRef} is either an atom or a term of the format
\arg{Atom}:\arg{Int} where \arg{Atom} normally refers to a filename
and \arg{Int} to the line-number where the description starts.

    \predicate{rdf_retractall}{3}{?Subject, ?Predicate, ?Object}
Removes all matching triples from the database.  Previous Prolog
implementations also provided a backtracking \predref{rdf_retract}{3},
but this proved to be rarely used and could always be replaced with
rdf_retractall/3. As rdf_retractall/4 using an unbound \arg{SourceRef}.

    \predicate{rdf_retractall}{4}{?Subject, ?Predicate, ?Object, ?SourceRef}
As rdf_retractall/4, also matching on the \arg{SourceRef}.  This is
particulary useful to update all triples coming from a loaded file.

    \predicate{rdf_update}{4}{+Subject, +Predicate, +Object, +Action}
Replaces one of the three fields on the matching triples depending
on \arg{Action}:

\begin{description}
    \termitem{subject}{Resource}
Changes the first field of the triple.
    \termitem{predicate}{Resource}
Changes the second field of the triple.
    \termitem{object}{Object}
Changes the last field of the triple to the given resource or
\term{literal}{Value}.
    \termitem{source}{Source}
Changes the source location (\jargon{payload}).  Note that updating the
source has no consequences for the semantics and therefore the
\jargon{generation} (see rdf_generation/1) is \emph{not} updated.
\end{description}

    \predicate{rdf_update}{5}{+Subject, +Predicate, +Object,
			      +Source,+Action}
As rdf_update/4 but allows for specifying the source.

\end{description}


\subsection{Transactions}			\label{transactions}

\index{transaction}%
The predicates from \secref{modpreds} perform immediate and atomic
modifications to the database. There are two cases where this is not
desirable:

\begin{enumerate}
    \item
If the database is modified using information based on reading the same
database. A typical case is a forward reasoner examining the database
and asserting new triples that can be deduced from the already existing
ones.   For example, \emph{if length(X) > 2 then size(X) is large}:

\begin{code}
	(   rdf(X, length, literal(L)),
	    atom_number(L, IL),
	    IL > 2,
	    rdf_assert(X, size, large),
	    fail
	;   true
	).
\end{code}

Running this code without precautions causes an error because
rdf_assert/3 tries to get a write lock on the database which has
an a read operation (rdf/3 has choicepoints) in progress.

    \item
Multi-threaded access making multiple changes to the database that
must be handled as a unit.
\end{enumerate}

Where the second case is probably obvious, the first case is less so.
The storage layer may require reindexing after adding or deleting
triples.  Such reindexing operatations however are not possible while
there are active read operations in other threads or from choicepoints
that can be in the same thread. For this reason we added
rdf_transaction/1.

\begin{description}
    \predicate{rdf_transaction}{1}{:Goal}
After starting a transaction, all predicates from \secref{modpreds}
append their operation to the \emph{transaction} instead of modifying
the database. If \arg{Goal} succeeds rdf_transaction cuts all
choicepoints in \arg{Goal} and executes all recorded operations. If
\arg{Goal} fails or throws an exception, all recorded operations are
discarded and rdf_transaction/1 fails or re-throws the exception. 

On entry, rdf_transaction/1 gains exclusive access to the database, but
does allow readers to come in from all threads. After the successful
completion of \arg{Goal} rdf_transaction/1 gains completely exclusive
access while performing the database updates.

Transactions may be nested.  Committing a nested transactions merges
its change records into the outer transaction, while discarding a
nested transaction simply destroys the change records belonging to
the nested transaction.
\end{description}


\subsection{Loading and saving to file}		\label{sec:rdffile}

The \file{rdf_db} module can read and write RDF-XML for import and
export as well as a binary format built for quick load and save
described in \secref{rdffastfile}.  Here are the predicates
for portable RDF load and save.

\begin{description}
    \predicate{rdf_load}{1}{+In}
Load triples from \arg{In}, which is either a stream opened for
reading or an atom specifying a filename.  This predicate calls
process_rdf/3 to read the source one description at a time, avoiding
limits to the size of the input.  If \arg{In} is a file, rdf_load/1
provides for caching the results for quick-load using rdf_load_db/1
described below.  Caching is activated by creating a directory
\file{.cache} (or \file{_cache} on Windows) in the directory holding
the \fileext{rdf} files.  Cached RDF files are loaded at approx.\
25 times the speed of RDF-XML files.

    \predicate{rdf_load}{2}{+File, +Options}
As rdf_load/1, providing additional options.  The options are handed
to the RDF parser as implemented by process_rdf/3.

    \predicate{rdf_unload}{1}{+Spec}
Remove all triples loaded from \arg{Spec}. In the current implementation
\arg{Spec} must refer to a file.

    \predicate{rdf_save}{1}{+File}
Save all known triples to the given \arg{File}.  Same as
\term{rdf_save}{File, \[\]}.

    \predicate{rdf_save}{2}{+File, +Options}
Save with options.  Provided options are:

    \begin{description}
        \termitem{db}{+FileRef}
Save all triples whose file-part of their \arg{SourceRef} matches
\arg{FileRef} to the given \arg{File}.   Saving arbitrary selections
is possible using predicates from \secref{partsave}.

        \termitem{anon}{+Bool}
if \term{anon}{false} is provided anonymous resources are only saved
if the resource appears in the object field of another triple that is
saved.

	\termitem{convert_typed_literal}{:Converter}
If present, raw literal values are first passed to \arg{Converter} to
apply the reverse of the \const{convert_typed_literal} option of the
RDF parser.  The \arg{Converter} is called with the same arguments
as in the RDF parser, but now with the last argument instantiated
and the first two unbound.   A proper convertor that can be used for
both loading and saving must be a logical predicate.
    \end{description}

    \predicate{rdf_source}{1}{?File}
Test or enumerate the files loaded using rdf_load/1.

    \predicate{rdf_make}{0}{}
Re-load all RDF sourcefiles (see rdf_source/1) that have changed since
they were loaded the last time.  This implies all triples that originate
from the file are removed and the file is re-loaded.  If the file is
cached a new cache-file is written.  Please note that the new triples
are added at the end of the database, possibly changing the order of
(conflicting) triples.
\end{description}

\subsubsection{Partial save}			\label{sec:partsave}

Sometimes it is necessary to make more arbitrary selections of material
to be saved or exchange RDF descriptions over an open network link. The
predicates in this section provide for this.

\begin{description}
    \predicate{rdf_save_header}{2}{+Stream, +Options}
Save an RDF header, with the XML header, \const{DOCTYPE},
\const{ENTITY} and opening the \const{rdf:RDF} element with appropriate
namespace declarations.  It uses the primitives from \secref{rdfns} to
generate the required namespaces and desired short-name.  \arg{Options}
is one of:

    \begin{description}
	\termitem{db}{+FileRef}
    Only search for namespaces used in triples labeled with
    \arg{FileRef}.
    \end{description}

    \predicate{rdf_save_footer}{1}{+Stream}
Close the work opened with rdf_save_header/2.

    \predicate{rdf_save_subject}{3}{+Stream, +Subject, +FileRef}
Save everything known about \arg{Subject} that matches \arg{FileRef}.
Using an variable for \arg{FileRef} saves all triples with
\arg{Subject}.
\end{description}


\subsubsection{Fast loading and saving}		\label{sec:rdffastfile}

Loading and saving RDF format is relatively slow.  For this reason we
designed a binary format that is more compact, avoids the complications
of the RDF parser and avoids repetitive lookup of (URL) identifiers.
Especially the speed improvement of about 25 times is worth-while when
loading large databases.  These predicates are used for caching by
rdf_load/[1,2] under certain conditions.

\begin{description}
    \predicate{rdf_save_db}{1}{+File}
Save all known triples into \arg{File}.  The saved version includes the
\arg{SourceRef} information.

    \predicate{rdf_save_db}{1}{+File, +FileRef}
Save all triples with \arg{SourceRef} \arg{FileRef}, regardless of the
line-number. For example, using \const{user} all information added
using rdf_assert/3 is stored in the database.

    \predicate{rdf_load_db}{1}{+File}
Load triples from \arg{File}.  
\end{description}


\subsubsection{MD5 digests}

The \file{rdf_db} library provides for \jargon{MD5 digests}. An MD5
digest is a 128 bit long hash key computed from the triples based on the
RFC-1321 standard.  MD5 keys are computed for each individual triple
and added together to compute the final key, resulting in a key that
describes the triple-set but is independant from the order in which
the triples appear.  It is claimed that it is practically impossible
for two different datasets to generate the same MD5 key.  The
Triple20 editor uses the MD5 key for detecting whether the triples
associated to a file have changed as well as to maintain a directory
with snapshots of versioned ontology files.

\begin{description}
    \predicate{rdf_md5}{2}{+Source, -MD5}
Return the MD5 digest for all triples in the database associated to
\arg{Source}. The \arg{MD5} digest itself is represented as an atom
holding a 32-character hexadecimal string.  The library maintains the
digest incrementally on rdf_load/[1,2], rdf_load_db/1, rdf_assert/[3,4]
and rdf_retractall/[3,4].  Checking whether the digest has changed since
the last rdf_load/[1,2] call provides a practical means for checking
whether the file needs to be saved.

    \predicate{rdf_atom_md5}{3}{+Text, +Times, -MD5}
Computes the MD5 hash from \arg{Text}, which is an atom, string or
list of character codes.  \arg{Times} is an integer $\geq 1$.  When
$> 0$, the MD5 algorithm is repeated \arg{Times} times on the
generated hash.  This can be used for password encryption algorithms
to make generate-and-test loops slow.

This predicate bears little relation to RDF handling. It is provided
because the RDF library already contains the MD5 algorithm and semantic
web services may involve security and consistency checking. This
predicate provides a platform independant alternative to the
\pllib{crypt} library provided with the \texttt{clib} package.
\end{description}


\subsection{Namespace Handling}			\label{sec:rdfns}

Prolog code often contains references to constant resources in a known
XML namespace. For example,
\const{http://www.w3.org/2000/01/rdf-schema\#Class} refers to the most
general notion of a class. Readability and maintability concerns require
for abstraction here.  The dynamic and multifile predicate rdf_db:ns/2
maintains a mapping between short meaningful names and namespace
locations very much like the XML \const{xmlns} construct.  The initial
mapping contains the namespaces required for the semantic web languages
themselves:

\begin{code}
ns(rdf,  'http://www.w3.org/1999/02/22-rdf-syntax-ns#').
ns(rdfs, 'http://www.w3.org/2000/01/rdf-schema#').
ns(owl,  'http://www.w3.org/2002/7/owl#').
ns(xsd,  'http://www.w3.org/2000/10/XMLSchema#').
ns(dc,   'http://purl.org/dc/elements/1.1/').
ns(eor,  'http://dublincore.org/2000/03/13/eor#').
\end{code}

All predicates for the semweb libraries use goal_expansion/2 rules to
make the SWI-Prolog compiler rewrite terms of the form
\infixterm{:}{Id}{Local} into the fully qualified URL.  In addition,
the following predicates are supplied:

\begin{description}
    \predicate{rdf_equal}{2}{Resource1, Resource2}
Defined as \infixterm{=}{Resource1}{Resource2}.  As this predicate is
subject to goal-expansion it can be used to obtain or test global URL
values to readable values. The following goal unifies \arg{X} with
\const{http://www.w3.org/2000/01/rdf-schema\#Class} without more
runtime overhead than normal Prolog unification.

\begin{code}
	rdf_equal(rdfs:'Class', X)
\end{code}

    \predicate{rdf_register_ns}{2}{+Alias, +URL}
Register \arg{Alias} as a shorthand for \arg{URL}.  Note that the
registration must be done before loading any files using them as
namespace aliases are handled at compiletime through goal_expansion/2.

    \predicate{rdf_global_id}{2}{?Alias:Local, ?Global}
Runtime translation between \arg{Alias} and \arg{Local} and a
\arg{Global} URL.  Expansion is normally done at compiletime.  This
predicate is often used to turn a global URL into a more readable
term.

    \predicate{rdf_global_object}{2}{?Object, ?NameExpandedObject}
As rdf_global_id/2, but also expands the type field if the object
is of the form \term{literal}{\term{type}{Type, Value}}.  This predicate
is used for goal expansion of the object fields in rdf/3 and similar
goals.

    \predicate{rdf_global_term}{2}{+Term0, -Term}
Expands all \arg{Alias}:\arg{Local} in \arg{Term0} and return the
result in \arg{Term}.  Use infrequently for runtime expansion of
namespace identifiers.

    \predicate{rdf_split_url}{3}{?Base, ?Local, ?URL}
Split a URL into a prefix and local part if used in mode -,-,+
or simply behave as atom_concat/3 in other modes.  The \arg{URL}
is split on the last \chr{\#} or \chr{/} character.
\end{description}


\subsection{Miscellaneous predicates}

This section describes the remaining predicates of the \file{rdf_db}
module.

\begin{description}
    \predicate{rdf_node}{1}{-Id}
Generate a unique reference.  The returned atom is guaranteed not to
occur in the current database in any field of any triple.

    \predicate{rdf_bnode}{1}{-Id}
Generate a unique blank node reference. The returned atom is guaranteed
not to occur in the current database in any field of any triple and
starts with '__bnode'.

    \predicate{rdf_is_bnode}{1}{+Id}
Succeeds if \arg{Id} is a blank node identifier (also called
\jargon{anonymous resource}).  In the current implementation this
implies it is an atom starting with a double underscore.

    \predicate{rdf_source_location}{2}{+Subject, -SourceRef}
Return the source-location as \arg{File}:\arg{Line} of the first triple
that is about \arg{Subject}.

    \predicate{rdf_generation}{1}{-Generation}
Returns the \arg{Generation} of the database. Each modification to the
database increments the generation. It can be used to check the validity
of cached results deduced from the database. Modifications changing
multiple triples increment \arg{Generation} with the number of triples
modified, providing a heuristic for `how dirty' cached results may be.

    \predicate{rdf_estimate_complexity}{?Subject, ?Predicate, ?Object,
					-Complexity}
Return the number of alternatives as indicated by the database 
internal hashed indexing.  This is a rough measure for the number
of alternatives we can expect for an rdf_has/3 call using the
given three arguments. When called with three variables, the total
number of triples is returned. This estimate is used in query
optimisation. See also rdf_predicate_property/2 and rdf_statistics/1 for
additional information to help optimisers.

    \predicate{rdf_statistics}{1}{?Statistics}
Report statistics collected by the \file{rdf_db} module.  Defined
values for \arg{Statistics} are:

    \begin{description}
	\termitem{lookup}{?Index, -Count}
Number of lookups using a pattern of instantiated fields.  \arg{Index}
is a term \term{rdf}{S,P,O}, where \arg{S}, \arg{P} and \arg{O} are
either \const{+} or \const{-}.  For example \term{rdf}{+,+,-} returns
the lookups with subject and predicate specified and object unbound.

	\termitem{properties}{-Count}
Number of unique values for the second field of the triple set.

	\termitem{sources}{-Count}
Number of files loaded through rdf_load/1.

	\termitem{subjects}{-Count}
Number of unique values for the first field of the triple set.

	\termitem{triples}{-Count}
Total number of triples in the database.
        \end{description}

    \predicate{rdf_match_label}{3}{+Method, +Search, +Atom}
True if \arg{Search} matches \arg{Atom} as defined by \arg{Method}.
All matching is performed case-insensitive.  Defines methods are:
    \begin{description}
	\termitem{exact}{}
    	    Perform exact, but case-insensitive match.
	\termitem{substring}{}
	    \arg{Search} is a sub-string of \arg{Text}.
	\termitem{word}{}
	    \arg{Search} appears as a whole-word in \arg{Text}.
	\termitem{prefix}{}
	    \arg{Text} start with \arg{Search}.
	\termitem{like}{}
	    \arg{Text} matches \arg{Search}, case insensitively, where
	    the `*' character in \arg{Search} matches zero or more
	    characters.
    \end{description}

    \predicate{rdf_reset_db}{0}{}
Erase all triples from the database and reset all counts and statistics
information.

    \predicate{rdf_version}{1}{-Version}
Unify \arg{Version} with the library version number.  This number is,
like to the SWI-Prolog version flag, defined as $10,000 \times
Major + 100 \times Minor + Patch$.
\end{description}


\subsection{Issues with rdf_db}				\label{sec:rdfissues}

This RDF low-level module has been created after two year experimenting
with a plain Prolog based module and a brief evaluation of a second
generation pure Prolog implementation. The aim was to be able to handle
upto about 2 million triples on standard (notebook) hardware and deal
efficiently with \const{subPropertyOf} which was identified as a crucial
feature of RDFS to realise fusion of different data-sets.

The following issues are identified and not solved in suitable manner.

\begin{description}
    \item [Logical update] as provided by Prolog means that active queries
are not affected by subsequent modification of the database. The current
C-based implementation adheres the \jargon{immediate} update model,
mainly because the current foreign language interface does not provide
the required information to realise logical updates in C.

    \item [\const{subPropertyOf} of \const{subPropertyOf}] is not
supported.

    \item [Equivalence]
Similar to \const{subPropertyOf}, it is likely to be profitable to
handle resource identity efficient.  The current system has no support
for it.
\end{description}


		 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		 %	       RDFS		%
		 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Module rdfs}				\label{sec:rdfs}

\index{RDF-Schema}%
The \pllib{rdfs} library adds interpretation of the triple store in
terms of concepts from RDF-Schema (RDFS).  

\subsection{Hierarchy and class-individual relations}

The predicates in this section explore the \const{rdfs:subPropertyOf},
\const{rdfs:subClassOf} and \const{rdf:type} relations.  Note that the
most fundamental of these, \const{rdfs:subPropertyOf}, is also used 
by rdf_has/[3,4].

\begin{description}
    \predicate{rdfs_subproperty_of}{2}{?SubProperty, ?Property}
True if \arg{SubProperty} is equal to \arg{Property} or \arg{Property}
can be reached from \arg{SubProperty} following the
\const{rdfs:subPropertyOf} relation. It can be used to test as well as
generate sub-properties or super-properties. Note that the commonly used
semantics of this predicate is wired into rdf_has/[3,4].%
	\bug{The current implementation cannot deal with
	     cycles}.%
	\bug{The current implementation cannot deal with predicates
	     that are an \const{rdfs:subPropertyOf} of
	     \const{rdfs:subPropertyOf}, such as
	     \const{owl:samePropertyAs}.}

    \predicate{rdfs_subclass_of}{2}{?SubClass, ?Class}
True if \arg{SubClass} is equal to \arg{Class} or \arg{Class}
can be reached from \arg{SubClass} following the
\const{rdfs:subClassOf} relation. It can be used to test as
well as generate sub-classes or super-classes.%
	\bug{The current implementation cannot deal with
	     cycles}.

    \predicate{rdfs_class_property}{2}{+Class, ?Property}
True if the domain of \arg{Property} includes \arg{Class}.  Used to
generate all properties that apply to a class.

    \predicate{rdfs_individual_of}{2}{?Resource, ?Class}
True if \arg{Resource} is an indivisual of \arg{Class}.  This implies
\arg{Resource} has an \const{rdf:type} property that refers to
\arg{Class} or a sub-class thereof.  Can be used to test, generate
classes \arg{Resource} belongs to or generate individuals described
by \arg{Class}.
\end{description}

\subsection{Collections and Containers}

\index{parseType,Collection}%
\index{Collection,parseType}%
The RDF construct \const{rdf:parseType}=\const{Collection} constructs
a list using the \const{rdf:first} and \const{rdf:next} relations.

\begin{description}
    \predicate{rdfs_member}{2}{?Resource, +Set}
Test or generate the members of \arg{Set}.  \arg{Set} is either an
individual of \const{rdf:List} or \const{rdf:Container}.

    \predicate{rdfs_list_to_prolog_list}{2}{+Set, -List}
Convert \arg{Set}, which must be an individual of \const{rdf:List} into
a Prolog list of objects.

    \predicate{rdfs_assert_list}{2}{+List, -Resource}
If \arg{List} is a list of resources, create an RDF list \arg{Resource}
that reflects these resources.  \arg{Resource} and the sublist resources
are generated with rdf_bnode/1.
\end{description}

\subsection{Labels and textual search}

Textual search is partly handled by the predicates from the
\pllib{rdf_db} module and its underlying C-library.  For example,
literal objects are hashed case-insensitive to speed up the commonly
used case-insensitive search.

\begin{description}
    \predicate{rdfs_label}{3}{?Resource, ?Language, ?Label}
Extract the label from \arg{Resource} or generate all resources with
the given \arg{Label}. The label is either associated using
a sub-property of \const{rdfs:label} or it is extracted from the URL
using rdf_split_url/3.  \arg{Language} is unified to the value of
the \const{xml:lang} attribute of the label or a variable if the
label has no language specified.

    \predicate{rdfs_label}{2}{?Resource, ?Label}
Defined as \term{rdfs_label}{Resource, _, Label}.

    \predicate{rdfs_ns_label}{3}{?Resource, ?Language, ?Label}
Similar to rdfs_label/2, but prefixes the result using the declared
namespace alias (see \secref{rdfns}) to facilitate user-friendly labels
in applications using multiple namespaces that may lead to confusion.

    \predicate{rdfs_ns_label}{2}{?Resource, ?Label}
Defined as \term{rdfs_ns_label}{Resource, _, Label}.

    \predicate{rdfs_find}{5}{+String, +Description, +Properties, +Method, -Subject}
\index{search}%
Find (on backtracking) \arg{Subject}s that satisfy a search
specification for textual attributes.  \arg{String} is the string
searched for. \arg{Description} is an OWL description (see \secref{owl})
specifying candidate resources. \arg{Properties} is a list of properties
to search for literal objects where \arg{rdfs:label} is replaced by a
call to rdfs_label/2 and finally, \arg{Method} defines the textual
matching algorithm.  All textual mapping is performed case-insensitive.
The matching-methods are described with rdf_match_label/3.
\end{description}


		 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		 %	       OWL		%
		 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Module owl}				\label{sec:owl}

\index{OWL}%
The current SemWeb library distributed with SWI-Prolog does not yet
contain an OWL module.  A module \file{owl.pl} is part of the
\url[Triple20]{http://www.swi-prolog.org/packages/Triple20/}
triple browser and editor provides limited support for OWL
reasoning.



		 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		 %	     RDF-EDIT		%
		 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Module rdf_edit}			\label{sec:rdfedit}

\index{undo}\index{journal}\index{transactions}
The module \file{rdf_edit.pl} is a layer than encasulates the
modification predicates from \secref{rdfmodify} for use from
a (graphical) editor of the triple store.  It adds the
following features:

\begin{itemlist}
    \item [Transaction management]
Modifications are grouped into \emph{transactions} to safeguard
the system from failing operations as well as provide meaningfull
chunks for undo and journalling.

    \item [Undo]
Undo and redo-transactions using a single mechanism to support
user-friendly editing.

    \item [Journalling]
Record all actions to support analysis, versioning, crash-recovery
and an alternative to saving.
\end{itemlist}

\subsection{Transaction management}

Transactions group low-level modification actions together.

\begin{description}
    \predicate{rdfe_transaction}{1}{:Goal}
Run \arg{Goal}, recording all modifications to the triple store made
through \secref{rdfeencap}.  Execution is performed as in once/1.  If
\arg{Goal} succeeds the changes are committed.  If \arg{Goal} fails 
or throws an exception the changes are reverted.

Transactions may be nested.  A failing nested transaction only reverts
the actions performed inside the nested transaction.  If the outer
transaction succeeds it is committed normally.  Contrary, if the
outer transaction fails, comitted nested transactions are reverted
as well.  If any of the modifications inside the transaction modifies
a protected file (see rdfe_set_file_property/2) the transaction is
reverted and rdfe_transaction/1 throws a permission error.

A successful outer transaction (`level-0') may be undone using
rdfe_undo/0.

    \predicate{rdfe_transaction}{2}{:Goal, +Name}
As rdfe_transaction/1, naming the transaction \arg{Name}.  Transaction
naming is intended for the GUI to give the user an idea of the next undo
action. See also rdfe_set_transaction_name/1 and
rdfe_transaction_name/2.

    \predicate{rdfe_set_transaction_name}{1}{+Name}
Set the `name' of the current transaction to \arg{Name}.

    \predicate{rdfe_transaction_name}{2}{?TID, ?Name}
Query assigned transaction names.

    \predicate{rdfe_transaction_member}{2}{+TID, -Action}
Enumerate the actions that took place inside a transaction.  This can
be used by a GUI to optimise the MVC (Model-View-Controller) feedback
loop.  \arg{Action} is one of:

\begin{description}
    \termitem{assert}{Subject, Predicate, Object}
    \termitem{retract}{Subject, Predicate, Object}
    \termitem{update}{Subject, Predicate, Object, Action}
    \termitem{file}{load(Path)}
    \termitem{file}{unload(Path)}
\end{description}
\end{description}

\subsection{File management}			\label{sec:file}

\begin{description}
    \predicate{rdfe_is_modified}{1}{?File}
Enumerate/test whether \arg{File} is modified sinds it was loaded or
sinds the last call to rdfe_clear_modified/1.  Whether or not a file
is modified is determined by the MD5 checksum of all triples belonging
to the file.

    \predicate{rdfe_clear_modified}{1}{+File}
Set the \emph{unmodified-MD5} to the current MD5 checksum.  See also
rdfe_is_modified/1.

    \predicate{rdfe_set_file_property}{2}{+File, +Property}
Control access right and default destination of new triples.
\arg{Property} is one of

    \begin{description}
	\termitem{access}{+Access}
    Where access is one of \const{ro} or \const{rw}.  Access \const{ro}
    is default when a file is loaded for which the user has no write
    access.  If a transaction (see rdfe_transaction/1) modifies a file
    with access \const{ro} the transaction is reversed.

	\termitem{default}{+Default}
    Set this file to be the default destination of triples.  If
    \arg{Default} is \const{fallback} it is only the default for
    triples that have no clear default destination. If it is \const{all}
    all new triples are added to this file.
    \end{description}

    \predicate{rdfe_get_file_property}{2}{?File, ?Property}
Query properties set with rdfe_set_file_property/2.
\end{description}


\subsection{Encapsulated predicates}		\label{sec:rdfeencap}

The following predicates encapsulate predicates from the \file{rdf_db}
module that modify the triple store. These predicates can only be called
when inside a \emph{transaction}.  See rdfe_transaction/1.

\begin{description}
    \predicate{rdfe_assert}{3}{+Subject, +Predicate, +Object}
Encapsulates rdf_assert/3.
    \predicate{rdfe_retractall}{3}{?Subject, ?Predicate, ?Object}
Encapsulates rdf_retractall/3.
    \predicate{rdfe_update}{4}{+Subject, +Predicate, +Object, +Action}
Encapsulates rdf_update/4.
    \predicate{rdfe_load}{1}{+In}
Encapsulates rdf_load/1.
    \predicate{rdfe_unload}{1}{+In}
Encapsulates rdf_unload/1.
\end{description}

\subsection{High-level modification predicates}	\label{sec:rdfeedit}

This section describes a (yet very incomplete) set of more high-level
operations one would like to be able to perform.  Eventually this set
may include operations based on RDFS and OWL.

\begin{description}
    \predicate{rdfe_delete}{1}{+Resource}
Delete all traces of \arg{resource}.  This implies all triples where
\arg{Resource} appears as \emph{subject}, \emph{predicate} or
\emph{object}.  This predicate starts a transation.
\end{description}

\subsection{Undo}

\index{undo}%
Undo aims at user-level undo operations from a (graphical) editor.

\begin{description}
    \predicate{rdfe_undo}{0}{}
Revert the last outermost (`level 0') transaction (see
rdfe_transaction/1). Successive calls go further back in history. Fails
if there is no more undo information.

    \predicate{rdfe_redo}{0}{}
Revert the last rdfe_undo/0.  Successive calls revert more rdfe_undo/0
operations.   Fails if there is no more redo information.

    \predicate{rdfe_can_undo}{1}{-TID}
Test if there is another transaction that can be reverted.  Used for
activating menus in a graphical environment.  \arg{TID} is unified to
the transaction id of the action that will be reverted.

    \predicate{rdfe_can_redo}{1}{-TID}
Test if there is another undo that can be reverted.  Used for
activating menus in a graphical environment.  \arg{TID} is unified to
the transaction id of the action that will be reverted.
\end{description}

\subsection{Journalling}

\index{journal}%
Optionally, every action through this module is immediately send to a
\jargon{journal-file}. The journal provides a full log of all actions
with a time-stamp that may be used for inspection of behaviour, version
management, crash-recovery or an alternative to regular save operations.

\begin{description}
    \predicate{rdfe_open_journal}{2}{+File, +Mode}
Open a existing or new journal.  If \arg{Mode} equala \const{append}
and \arg{File} exists, the journal is first replayed. See
rdfe_replay_journal/1.  If \arg{Mode} is \const{write} the journal is
truncated if it exists.

    \predicate{rdfe_close_journal}{0}{}
Close the currently open journal.

    \predicate{rdfe_current_journal}{1}{-Path}
Test whether there is a journal and to which file the actions are
journalled.

    \predicate{rdfe_replay_journal}{1}{+File}
Read a jorunal, replaying all actions in it.  To do so, the system
reads the journal a transaction at a time.  If the transaction is
closed with a \emph{commit} it executes the actions inside the journal.
If it is closed with a \emph{rollback} or not closed at all due to a
crash the actions inside the journal are discarded.  Using this
predicate only makes sense to inspect the state at the end of a journal
without modifying the journal.  Normally a journal is replayed using the
\const{append} mode of rdfe_open_journal/2.
\end{description}


\subsection{Broadcasting change events}

\index{event}\index{broadcast}%
To realise a modular graphical interface for editing the triple store,
the system must use some sort of \emph{event} mechanism. This is
implemented by the XPCE library \pllib{broadcast} which is described
in the \url[XPCE User
Guide]{http://www.swi.psy.uva.nl/projects/xpce/UserGuide/libbroadcast.html}.
In this section we describe the terms brodcasted by the library.

\begin{description}
    \termitem{rdf_transaction}{+Id}
A `level-0' transaction has been committed. The system passes the
identifier of the transaction in \arg{Id}. In the current implementation
there is no way to find out what happened inside the transaction.  This
is likely to change in time.

If a transaction is reverted due to failure or exception \emph{no} event
is broadcasted.  The initiating GUI element is supposed to handle this
possibility itself and other components are not affected as the triple
store is not changed.

    \termitem{rdf_undo}{+Type, +Id}
This event is broadcasted after an rdfe_undo/0 or rdfe_redo/0.
\arg{Type} is one of \const{undo} or \const{redo} and \arg{Id}
identifies the transaction as above.
\end{description}


\section{Related packages and issues}

\index{Sesame}\index{SeRQL}%
The SWI-Prolog SemWeb package is designed to provide access to the
Semantic Web languages from Prolog.  It consists of the low level
\file{rdf_db.pl} store with layers such as \file{rdfs.pl} to provide
more high level querying of a triple set with relations such as
rdfs_individual_of/2, rdfs_subclass_of/2, etc.
\url[SeRQL]{http://www.openrdf.org} is a semantic web query language
taking another route.  Instead of providing alternative relations
SeRQL defines a graph query on de \jargon{deductive closure} of the
triple set.  For example, under assumption of RDFS entailment rules
this makes the query \term{rdf}{S, rdf:type, Class} equivalent to
\term{rdfs_individual_of}{S, Class}.

\index{optimising,query}%
We developed a parser for SeRQL which compiles SeRQL path expressions
into Prolog conjunctions of \term{rdf}{Subject, Predicate, Object}
calls. \jargon{Entailment modules} realise a fully logical
implementation of rdf/3 including the entailment reasoning required to
deal with a Semantic Web language or application specific reasoning. The
infra structure is completed with a query optimiser and an HTTP server
compliant to the \url[Sesame]{http://www.openrdf.org} implementation of
the SeRQL language.  The Sesame Java client can be used to access Prolog
servers from Java, while the Prolog client can be used to access the
Sesame SeRQL server.  For further details, see the
\url[project
home]{http://gollem.swi.psy.uva.nl/twiki/pl/bin/view/Library/SeRQL}.


		 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		 %	      FOOTER		%
		 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printindex

\end{document}


