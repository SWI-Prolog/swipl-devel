\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\sloppy
\makeindex

\onefile
\htmloutput{html}				% Output directory
\htmlmainfile{index}				% Main document file
\bodycolor{white}				% Page colour

\renewcommand{\runningtitle}{SWI-Prolog documentation package}

\begin{document}

\title{SWI-Prolog Source Documention}
\author{Jan Wielemaker \\
	HCS, \\
	University of Amsterdam \\
	The Netherlands \\
	E-mail: \email{wielemak@science.uva.nl}}

\maketitle

\begin{abstract}
This article presents PlDoc, the SWI-Prolog source-code documentation
infrastructure.  PlDoc is loosely based on JavaDoc, using structured
comments to mix documentation with source-code.  SWI-Prolog's PlDoc
is entirely written in Prolog and well integrated with the environment.
It can create HTML+CSS and \LaTeX{} documentation files as well as act
as a web-server for the loaded project during program development.
\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{Introduction}

When developing Prolog source that has to be maintained for a longer
period or is developed by a ---possibly distributed--- team some basic
quality mechanisms need to be adopted. A shared and well designed
codingstyle is one of them. In addition, documentation of source-files
and their primary interfaces as well as a testing framework must be
established.

Only a few documentation and testing frameworks exist in the Prolog
world. In our view they all fall short realising the basic needs in a
lightweight and easy to addopt system. We have noticed in various
projects as well as through the codee we receive in the cause of testing
and debugging SWI-Prolog that the discipline to come with consistent
style, well commented code and a test-suite is not very well established
in the Prolog community.  If we want to improve this practice, we should
make sure that

\begin{shortlist}
    \item The documentation and testing framework requires a
	  minimum of work and learning.
    \item The framework is immediately rewarding to the individual
          programmer as well as the team,
\end{shortlist}

First, we describe the documentation system we developed for SWI-Prolog.
In \secref{motivation} we motivate our main choices.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}

The PlDoc infrastructure is based on \emph{structured comments}, just
like JavaDoc.  Using comments, no changes have to be made to Prolog to
load the documented source.  If the \pllib{pldoc} library is loaded, 
Prolog will not only load the source, but also parse all structured
comments.  It processes the mode-declarations inside the comments and
stores these as annotations in the Prolog database to support the test
framework and other runtime and compiletime analysis tools that may be
developed in the future.

Documentation for all or some of the loaded files can be written to file
in either HTML+CSS or \LaTeX{} format. Each source file is documented in
a single file. In addition, the documentation generator will generate an
index file that can be used a index for a browser or input file for
\LaTeX{} for producing nicely typeset document.

To support the developer, the documentation system can be asked to start
a web-server that can be used to browse the documentation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Structured comments}

Structured comments come in two flavours, the line-comment (\%) based
one that seen most in the Prolog community and the block-comment
(\verb$/*$\ldots\verb$*/$) based one commonly seen in the Java and
C domain.  As we cannot determine the argument-names, type and modes
from following (predicate) code itself, we must supply this in the
comment.\footnote{See \secref{motivation:modes}.}.  The overall
structure of the comment therefore is:

\begin{shortlist}
    \item Semi-formal type- and mode-description, see \secref{modes}
    \item Wiki-style documentation body, see \secref{wiki}
    \item JavaDoc style tags (\chr{@}keyword value, see \secref{tags})
\end{shortlist}

Using the \verb$/*$\ldots\verb$*/$ style comment, the type and mode
declarations are ended by a blank line. Using \chr{\%} line-comments,
the declaration is ended by the first line that starts with a single \%.

The JavaDoc style keyword list starts at the first line starting
with @<word>.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{File and section comments}
\label{sec:sectioncomments}

An important aspect is documentation of the file or module as a whole,
explaining its design, purpose and relation to other modules. In JavaDoc
this is the comment that preceeds the class definition. The Prolog
equivalent would be to but the module comment in front of the module
declaration. The module declaration itself however is an important index
to the content of the file and is therefore best kept first.

The general comment-structure for section comments is to use a
section-type identifier between angled brackets, followed by the title
of the section. Defined values for \arg{Type} are given in the table
below.

\begin{center}
\begin{tabular}{ll}
\hline
\multicolumn{2}{c}{{\tt\string/** <}\arg{Type}{\tt\string>}\arg{Title}} \\
\multicolumn{2}{c}{{\tt\%\%~~}{\tt\string<}\arg{Type}{\tt\string>}\arg{Title}} \\
\hline
<Type> & Description \\
\hline
module	& Comment of a module file \\
section & Section inside the module documentation \\
subsection & Sub-section inside a section \\
subsubsection & Sub-Sub-section inside a sub-section \\
\hline
\end{tabular}
\end{center}

\subsection*{Example}

\begin{code}
/** <module> Prolog documentation processor

This module processes structured comments and generates both formal
mode declarations from them as well as documentation in the form of
HTML or LaTeX.

@author	Jan Wielemaker
@license GPL
*/
\end{code}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type and mode declarations}
\label{sec:modes}

The type and mode declaration header consists of one or more Prolog
terms.  Each term describes a mode of the predicate.  The syntax is
informally described below:

\begin{center}
\begin{tabular}{lrl}
\hline
<modedef>	\isa <head>['//'] 'is' <determinism> \\
		\ora <head>['//'] \\
<determinism>	\isa 'det' \\
		\ora 'semidet' \\
		\ora 'nondet' \\
<head>		\isa <functor>'('<argspec> {',' <argspec>}')' \\
		\isa <functor> \\
<argspec>	\isa [<instantiation>]<argname>[':'<type>] \\
<instantiation> \isa '+' $\mid$ '-' $\mid$ '?' $\mid$ ':'
		     $\mid$ '@' $\mid$ '!' \\
<type>		\isa <term> \\
\hline
\end{tabular}
\end{center}

Instantiation patters are:

\begin{center}
\begin{tabular}{lp{0.7\linewidth}}
\hline
+ &	Argument must be fully instantiated to a term that satisfies the
	type. \\
- &	Argument must be unbound. \\
? &	Argument must be bound to a \emph{partial term} of the indicated
	type.  Note that a variable is a partial term for any type. \\
: &	Argument is a meta-argument.  Implies \chr{+}. \\
@ &	Argument is not further instantiated. \\
! &	Argument contains a mutable structure that may be modified using
	setarg/3 or nb_setarg/3. \\
\hline
\end{tabular}
\end{center}

In the current version types are represented by an arbitrary term
without formal semantics. In future versions we may adopt a formal
type system that allows for runtime verification and static type
analysis [Ciao assertion language, O'Keefe and Mycroft, Mercury].

\subsection*{Examples}

\begin{verbatim}
%%	length(+List:list, -Length:int) is det.
%%	length(?List:list, -Length:int) is nondet.
%%	length(?List:list, +Length:int) is det.
%
%	True if List is a list of length Length.
%	
%	@compat iso
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tags: \chr{@}param, etc.}
\label{sec:tags}

Optionally, the description may be followed by one or more \emph{tags}.
Our tag convention is strongly based on the conventions of javaDoc.
It is adviced to place tags in the order they are described below.

\begin{description}
    \definition{\chr{@}param}
Defines the parameters. Each parameter has its own param tag. The first
word is the name of the parameter. The remainder of the tag is the
description. Parameter declarations must appear in the argument order
used by the predicate. 

    \definition{\chr{@}throws}
Error condition. First Prolog term is
    the error term. Remainder is the description.

    \definition{\chr{@}error}
As \chr{@}throws, but the exception is embedded in \term{error}{Error,
Context}.

    \definition{\chr{@}author}
Author of the module or predicate. Multiple entries are used if there
are multiple authors.

    \definition{\chr{@}version}
Version of the module.  

    \definition{\chr{@}see}
Related maaterial.

    \definition{\chr{@}depreciated}
The predicate or module is depreciated.  The description specifies what
to use in new code.

    \definition{\chr{@}compat}
When implementing libraries or externally defined interfaces this tag
describes to which standard the interface is compatible.

    \definition{\chr{@}copyright}
Copyright notice.

    \definition{\chr{@}license}
License conditions that apply to the source.

    \definition{\chr{@}bug}
Known problems with the interface or implementation.

    \definition{\chr{@}tbd}
Not yet realised behaviour that is enticipated in future versions.
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Wiki notation}
\label{sec:wiki}

Structured comments that provide part of the documentation are written
in Wiki notation, based on \url[TWiki]{http://www.twiki.org}, with some
Prolog specific additions.

\subsection{Structuring conventions}

\begin{description}
    \item [Paragraphs]
Paragraphs are seperated by a blank line.

    \item [General lists]
The wiki knows three types of lists: \emph{bullet lists} (HTML
\const{ul}), \emph{numbered lists} (HTML \const{ol}) and
\emph{description lists} (HTML \const{dl}). Each list environment is
headed by an empty line and each list-item has a special symbol at the
start, followed by a space.  Each subsequent item must be indented at
exactly the same column.  Lists may be nested by starting a new list at
a higher level of indentation.  The list prefixes are:

\begin{center}
\begin{tabular}{lp{0.7\linewidth}}
 \tt *	& Bulleted list item \\
 \tt 1.	& Numbered list item.  Any number from 1..9 is allowed, which
	  allows for proper numbering in the source.  Actual numbers
	  in the HTML or \LaTeX{} however are re-generated, starting
	  at 1. \\
 \tt \$ Title : Item & Description list item.
\end{tabular}
\end{center}

    \item [Term lists]
Especially when describing option lists or different accepted types,
it is common to describe the behaviour on different terms.  Such
lists must be written as below.  <Term1>, etc. must be valid Prolog
terms and end in the newline.  The Wiki adds \verb$' . '$ to the text
and reads it using the operator definitions also used to read
the mode terms.  See \secref{modes}.

\begin{code}
   * Term1
     Description
   * Term2
     Description
\end{code}

    \item [Tables]
The Wiki provides only for limited support for tables.   A table-row
is started by a \chr{|} sign and the cells are separated by the same
character.  The last cell must be ended with \chr{|}.  Multiple lines
that parse into a table-row together for a table.  Example:

\begin{verbatim}
	| Author  | Jan Wielemaker |
	| Copying | GPL            |
\end{verbatim}

    \item [Section Headers]
Section headers are creates using one of the constructs below taken
from TWiki.  Section headers are normally not used in the source-code,
but can be useful inside README and TODO files.  See \secref{dirindex}.

\begin{verbatim}
---+ Section level 1
---++ Section level 2
---+++ Section level 3
---++++ Section level 4
\end{verbatim}

    \item [Code (verbatim)]
Verbatim is embedded between lines containing only \verb$==$, as shown
in the example below.  The indentation of the \verb$==$ must match and
the indentation of the verbatim text is reduced by the indentation of
the \verb$==$ marks.

\begin{verbatim}
	==
	small(X) :-
		X < 5.
	==
\end{verbatim}
\end{description}

\subsection{Text markup: fonts and links}

Wiki text markup to realise fonts is mostly based on old plaintext
conventions in newsnet and E-mail.  We added some Prolog specific
conventions to this.  For font changing code, The opening symbol must
be followed immediately by a word and the closing one must immediately
follow a word.

As code comment frequently contains symbols such as \verb$=$ we ---in
contrast to normal Wiki conventions--- do font font-switches onlt if a
single word is surrounded by \verb$=$, \verb$*$ or \verb$_$.  Longer
sequences must be created using additional \chr{|}:

\begin{code}
PceEmacs can be set as default editor using
=|set_prolog_flag(editor, pce_emacs)|=
\end{code}

\begin{center}
\begin{tabular}{lp{0.7\linewidth}}
\tt *bold*	& Typset text in \textbf{bold}.
		  Content must be a single word. \\
\tt *|bold|*	& Typset text in \textbf{bold}.
		  Content can be long. \\
\tt _emphasize_ & Typset text as \emph{emphasize}.
		  Content must be a single word. \\
\tt _|emphasize|_ & Typset text as \emph{emphasize}.
		  Content can be long. \\
\tt =code=      & Typset text \texttt{fixed} font.
		  Content must be a single word. \\
\tt =|code|=    & Typset text \texttt{fixed} font.
		  Content can be long. \\
\tt name/arity  & Create a link to a predicate \\
\tt name//arity & Create a link to a DCG rule \\
\tt name.pl	& If <name>.pl is the name of an existing file
		  in the same directory, create a link. \\
\tt\string<url>	& Create a hyperlink to URL. \\
\tt Word	& Capitalised words that appear as argument-name
		  are written in \arg{Italic} \\
\tt $Word: CVS$ & CVS expanded keyword.  Typeset as the plain
		  keyword value. \\
\end{tabular}
\end{center}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Directory indices}
\label{sec:dirindex}

A directory index consists of the contents of the file \file{README}
(or \file{README.TXT}, followed by a table holding all currently loaded
source-files that appear below the given directory (i.e.\ traversal is
\emph{recursive} and for each file a list of public predicates and their
descriptive summary.  Finally, if a file \file{TODO} or \file{TODO.TXT}
exists, use add its contents at the end of the directory index.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Running the documentation system}
\label{sec:running}


\subsection{During development}

To support the developer with an up-to-date version of the documentation
of both the application under development and the system libraries the
developer can start an HTTP documentation server using the command
\term{doc_server}{?Port}.


\begin{description}
    \predicate{doc_collect}{1}{+Bool}
Enable/disable collecting structured comments into the Prolog database. 

    \predicate{doc_server}{1}{?Port}
Start documentation server at \arg{Port}.  Same as
\term{doc_server}{Port, [allow(localhost), workers(1)]}.

    \predicate{doc_server}{2}{?Port, +Options}
Start documentation server at \arg{Port} using \arg{Options}.  Provided
options are:

    \begin{description}
	\termitem{allow}{+HostOrIP}
Allow connections from \arg{HostOrIP}.  If \arg{Host} is an atom
starting with a '.', suffix matching is preformed.  I.e.\ 
\verb$allow('.uva.nl')$ grants access to all machines in this domain.
IP addresses are specified using the library(socket) ip/4 term.  I.e.
to allow access from the 10.0.0.X domain, specify
\verb$allow(ip(10,0,0,_))$.

	\termitem{deny}{+HostOrIP}
Deny access from the given location.  Matching is equal to the
\const{allow} option.
    \end{description}

Access is granted iff

\begin{shortlist}
    \item Both \emph{deny} and \emph{allow} match
    \item \emph{allow} exists and matches
    \item \emph{allow} does not exit and \emph{deny} does not match.
\end{shortlist}

    \predicate{doc_browser}{0}{}
Open the user's default browser on the running documentation server.
Fails if no server is running.

    \predicate{doc_browser}{1}{+Spec}
Open the user's default browser on the specified page.  \arg{Spec} is
handled similar to edit/1, resolving anything that relates somehow to
the given specification and ask the user to select.%
	\bug{This flexibility is not yet implemented}.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{As a manual server}
\label{sec:manserver}

The library \pllib{doc/doc_library} defines doc_load_library/0 to
load the entire library.

\begin{description}
    \predicate{doc_load_library}{0}{}
Load all library files.  This is intended to setup a local documentation
server.  A typical scenario, making the server available at port 4000 of
the hosting machine from all locations in a domain is given below.

\begin{code}
:- doc_server(4000,
	      [ allow('.my.org')
	      ]).
:- use_module(library('doc/doc_library')).
:- doc_load_library.
\end{code}
 \end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using the browser interface}
\label{sec:browser}

The documentation system is normally accessed from a web-browser after
starting the server using doc_server/1.  This section briefly explains
the user-interface provided from the browser.

\subsubsection{Searching}

The top-right of the screen provides a search-form. The search string
typed is searched as a substring and case-insensitive. Multiple strings
seperated by spaces search for the intersection. Searching for objects
that do not contain a string is written as \chr{-}<string>.  A search
for adjacent strings is specified as \chr{"}<string>\chr{"}.  Here
are some examples:

\begin{center}
\begin{tabular}{|l|p{0.6\linewidth}|}
\hline
\tt load file	& Searches for all objects with the strings
		  \texttt{load} and \texttt{file}. \\
\tt load -file  & Searches for objects with \texttt{load}, but
		  \emph{without} \texttt{file}. \\
\tt "load file" & Searches for the string \texttt{load file}.\\
\hline
\end{tabular}
\end{center}

The two radio-buttons below the search box can be used to limit the
search. \textsf{All} searches both the application and manuals.
Searching for \textsf{Summary} also implies \textsf{Name}.

\subsubsection{Views}

The web-browser supports several views, which we briefly summarise
here:

\begin{itemlist}
    \item [ Directory ]
In directory-view mode, the contents of a directory holding Prolog
source-files is shown file-by-file in a summary-table.   In addition,
the contents of the \file{README} and \file{TODO} files is given.

    \item [ Source File ]
When showing a Prolog source-file it displays the module documentation
from the \verb$/** <module ... */$ comment and the public predicates
with their full documentation.  Using the zoom button the user can
select to view both public and documentated private predicates.

    \item [ Predicate ]
When selecting a predicate link the system presents a page with the
documentation of the predicate.  The navigation bar allows switching
to the Source File if the documentation comes from source or the
containing section if the documentation comes from a manual.

    \item [ Section ]
Section from the manual. The navigation bars allows viewing the
enclosing section (\emph{Up}).
\end{itemlist}


\subsubsection{Editing}

If the browser is accessed from \const{localhost}, each object that
is related to a known source-location has an edit icon at the right
side.  Clicking this calls edit/1 on the object, calling the user's
default editor in the file.  To use the built-in PceEmacs editor,
either set the Prolog flag \const{editor} to \const{pce_emacs} or
run \exam{?- emacs.} before clicking an edit button.

Prolog source-files have a \emph{reload} button attached. Clicking this
reloads the sourcefile if it was modified and refreshes the page. This
supports a comfortable edit-view loop to maintain the source-code
documentation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Motivation of choices}
\label{sec:motivation}

Literal programming is an old field.  The \TeX{} source is one of the
oldest and welknown examples of this approach were input files are a 
mixture of \TeX{} and PASCAL source. External tools are used to untangle
the common source, process one branche to produce the documentation
while the other is compiled to produce the program.

A program and its documentation consists of various different parts:

\begin{shortlist}
    \item The program text itself.  This is the minimum that must be
          handed to the compiler to create an executable (module).
    \item Meta information about the program: author, modifications,
          license, etc.
    \item Documentation about the overall structure and purpose of
	  the source.
    \item Description of the interface: public predicates, their
	  types, modes and whether or not they are deterministic as
	  wel as an informative text on each public predicate.
    \item Description of key private predicates necessary to understand
	  how the public interface is realised.
\end{shortlist}

\subsection*{Structured comments or directives}

Comments can be added through Prolog directives, a route taken by Ciao
Prolog and Logtalk. We feel structured comments are a better alternative
for the following reasons:

\begin{itemize}
    \item Prolog programmers are used to writing comments as Prolog
          comments.
    \item Using Prolog strings requires unnatural escape sequences for
	  string quotes and long literal values tend to result in hard
	  to find quote-mismatches.
    \item Comments should not look like code, as that makes it more
	  difficult to find the actual code.
\end{itemize}

We are aware that the above problems can be dealt with using
syntax-aware editors. Only a few editors are sufficiently powerful to
support this correctly though and we do not expect the required advanced
modes to be widely available.  Using comments we do not need to force
users into using a particular editor.

\subsection*{Wiki or HTML}

JavaDoc uses HTML as markup inside the structured comments. Although
HTML is more widely known than ---for example--- \LaTeX{} or TeXinfo, we
think the Wiki approach is sufficiently widely known today. Using text
with minimal layout conventions taken largely from plaintext newsnet and
E-mail, Wiki input is much easier to read in the source-file than HTML
without syntax support from an editor.


\subsection*{Types and modes}
\label{sec:motivation:modes}

Types and modes are not a formal part of the Prolog language.
Nevertheless, their role goes beyond purely documentation. The test
system can use information about non-determinism to validate that
deterministic calls are indeed deterministic.  Type information can
be used to analyse coverage from the test-suite, to generate runtime
type verification or to perform static type-analysis.  We have choosen
to use a structured comment with formal syntax for the following
reasons:

\begin{itemize}
    \item As a comment, they stay together with the comment block
          of a predicate. we feel it is best to keep documentation
	  as close as possible to the source.
    \item As we parse them seperately, we can pick up argument names
	  and create a readable syntax without introducing possibly
	  conflicting operators.
    \item As a comment they do not introduce incompatibilities with
          other Prolog systems.
\end{itemize}


\subsection*{Few requirements}

SWI-Prolog aims at platform independency. We want to tools to rely as
much as possible on Prolog itself. Therefore the entire infrastructure
is written in Prolog. Output as HTML is suitable for browsing and not
very high quality printing on virtuall every platform. Output to
\LaTeX{} requires more infrastructure for processing, but allows for
producing high-quality PDF documents.

\printindex

\end{document}

