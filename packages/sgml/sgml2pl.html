<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<HTML>
<HEAD>
<TITLE>SWI-Prolog SGML/XML parser</TITLE>
</HEAD>
<BODY BGCOLOR="white">
<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<CENTER>

<H1>SWI-Prolog SGML/XML parser</H1>

</CENTER>
<HR>
<CENTER>
<I>Jan Wielemaker <BR>
SWI, <BR>
University of Amsterdam <BR>
The Netherlands <BR>
E-mail: <A HREF="mailto:jan@swi.psy.uva.nl">jan@swi.psy.uva.nl</A></I>
</CENTER>
<HR>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>
<CENTER><H3>Abstract</H3></Center>
<TABLE WIDTH="90%" ALIGN=center BORDER=2 BGCOLOR="#f0f0f0"><TR><TD>
Markup languages are an increasingly important method for 
data-representation and exchange. This article documents the package
<EM>sgml2pl</EM>, a foreign library for SWI-Prolog to parse SGML and XML 
documents, returning information on both the document and the document's 
DTD. The parser is designed to be small, fast and flexible.
</TABLE>

<H1><A NAME="document-contents">Table of Contents</A></H1>

<UL>
<LI><A HREF="#sec:1"><B>1 Introduction</B></A>
<LI><A HREF="#sec:2"><B>2 Bluffers Guide</B></A>
<UL>
<LI><A HREF="#sec:2.1">2.1 `Goodies' Predicates</A>
</UL>
<LI><A HREF="#sec:3"><B>3 Predicate Reference</B></A>
<UL>
<LI><A HREF="#sec:3.1">3.1 Loading Structured Documents</A>
<LI><A HREF="#sec:3.2">3.2 Handling white-space</A>
<LI><A HREF="#sec:3.3">3.3 XML documents</A>
<UL>
<LI><A HREF="#sec:3.3.1">3.3.1 XML Namespaces</A>
</UL>
<LI><A HREF="#sec:3.4">3.4 DTD-Handling</A>
<UL>
<LI><A HREF="#sec:3.4.1">3.4.1 The DOCTYPE declaration</A>
</UL>
<LI><A HREF="#sec:3.5">3.5 Extracting a DTD</A>
<LI><A HREF="#sec:3.6">3.6 Parsing Primitives</A>
<UL>
<LI><A HREF="#sec:3.6.1">3.6.1 Partial Parsing</A>
</UL>
</UL>
<LI><A HREF="#sec:4"><B>4 Processing Indexed Files</B></A>
<LI><A HREF="#sec:5"><B>5 External entities</B></A>
<LI><A HREF="#sec:6"><B>6 Missing functionality</B></A>
<LI><A HREF="#sec:7"><B>7 Installation</B></A>
<UL>
<LI><A HREF="#sec:7.1">7.1 Unix systems</A>
<LI><A HREF="#sec:7.2">7.2 Acknowledgements</A>
</UL>
</UL>

<P>

<H2><A NAME="sec:1">1 Introduction</A></H2>

<P>Markup languages have recently regained popularity for two reasons. 
One is document exchange, which is largely based on HTML, an instance of 
SGML and the other is for data-exchange between programs, which is often 
based on XML, which can be considered simplified and rationalised 
version of SGML.

<P>James Clark's SP parser is a flexible SGML and XML parser. 
Unfortunately it has some drawbacks. It is very big, not very fast, 
cannot work under event-driven input and is generally hard to program 
beyond the scope of the well designed generic interface. The generic 
interface however does not provide access to the DTD, does not allow for 
flexible handling of input or parsing the DTD independently of a 
document instance.

<P>The parser described in this document is small (less than 50 Kbytes 
executable on a Pentium), fast (between 2 and 5 times faster than SP), 
provides access to the DTD and flexible input handling.

<P>The document output is equal to the output produced by <EM>xml2pl</EM>, 
an SP interface to SWI-Prolog written by Anjo Anjewierden.

<H2><A NAME="sec:2">2 Bluffers Guide</A></H2>

<P>This package allows you to parse SGML, XML and HTML data into a 
Prolog data structure. The high-level interface defined in <CODE>library(sgml)</CODE> 
provides access at the file-level, while the low-level interface defined 
in the foreign module works with Prolog streams. Please use the source 
of <CODE>sgml.pl</CODE> as a starting point for dealing with data from 
other sources than files, such as SWI-Prolog resources, network-sockets, 
character strings, etc. In the first example below loads an HTML file.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;

&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 align=center&gt;This is a demo&lt;/h1&gt;

&lt;p&gt;Paragraphs in HTML need not be closed.

&lt;p&gt;This is called `omitted-tag' handling.
&lt;/body&gt;
&lt;/html&gt;
</PRE>
</TABLE>

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

?- load_html_file('test.html', Term),
   pretty_print(Term).

[ element(html,
          [],
          [ element(head,
                    [],
                    [ element(title,
                              [],
                              [ 'Demo'
                              ])
                    ]),
            element(body,
                    [],
                    [ '\n',
                      element(h1,
                              [ align = center
                              ],
                              [ 'This is a demo'
                              ]),
                      '\n\n',
                      element(p,
                              [],
                              [ 'Paragraphs in HTML need not be closed.\n'
                              ]),
                      element(p,
                              [],
                              [ 'This is called `omitted-tag\' handling.'
                              ])
                    ])
          ])
].
</PRE>
</TABLE>

<P>The document is represented as a list, each element being an atom to 
represent <CODE>CDATA</CODE> or a term <CODE>element(Name, Attributes, 
Content)</CODE>. Entities (e.g. <CODE>&amp;lt</CODE>) are returned as 
part of
<CODE>CDATA</CODE>, unless they cannot be represented. See <A NAME="idx:loadsgmlfile2:1"></A><A HREF="#load_sgml_file/2">load_sgml_file/2</A> 
for details.

<H3><A NAME="sec:2.1">2.1 `Goodies' Predicates</A></H3>

<P>These predicates are for basic usage of the library, converting 
entire and self-contained files in one of the three supported <I>X</I>ML 
dialects into a structured term. They are all expressed in <A NAME="idx:loadstructure3:2"></A><A HREF="#load_structure/3">load_structure/3</A>.

<DL>
<DT><A NAME="load_sgml_file/2"><STRONG>load_sgml_file</STRONG>(<VAR>+File, 
-ListOfContent</VAR>)</A><DD>
Same as <CODE>load_structure(File, ListOfContent, [dialect(sgml)])</CODE>.
<DT><A NAME="load_xml_file/2"><STRONG>load_xml_file</STRONG>(<VAR>+File, 
-ListOfContent</VAR>)</A><DD>
Same as <CODE>load_structure(File, ListOfContent, [dialect(xml)])</CODE>.
<DT><A NAME="load_html_file/2"><STRONG>load_html_file</STRONG>(<VAR>+File, 
-Content</VAR>)</A><DD>
Load <VAR>File</VAR> and parse as HTML. Implemented as:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

load_html_file(File, Term) :-
        dtd(html, DTD),
        load_structure(File, Term,
                       [ dtd(DTD),
                         dialect(sgml)
                       ]).
</PRE>
</TABLE>

<P>
</DL>

<H2><A NAME="sec:3">3 Predicate Reference</A></H2>

<H3><A NAME="sec:3.1">3.1 Loading Structured Documents</A></H3>

<P>SGML or XML files are loaded through the common predicate
<A NAME="idx:loadstructure3:3"></A><A HREF="#load_structure/3">load_structure/3</A>. 
This is a predicate with many options. For simplicity a number of 
commonly used shorthands are provided: <A NAME="idx:loadsgmlfile2:4"></A><A HREF="#load_sgml_file/2">load_sgml_file/2</A>,
<A NAME="idx:loadxmlfile2:5"></A><A HREF="#load_xml_file/2">load_xml_file/2</A>, 
and <A NAME="idx:loadhtmlfile2:6"></A><A HREF="#load_html_file/2">load_html_file/2</A>.

<DL>
<DT><A NAME="load_structure/3"><STRONG>load_structure</STRONG>(<VAR>+File, 
--ListOfContent, +Options</VAR>)</A><DD>
Load the <I>X</I>ML file <VAR>File</VAR> and return the resulting 
structure in <VAR>ListOfContent</VAR>. <VAR>Options</VAR> is a list of 
options controlling the conversion process.

<P>A proper <I>X</I>ML document contains only a single toplevel element 
whose name matches the document type. Nevertheless, a list is returned 
for consistency with the representation of element content. The
<VAR>ListOfContent</VAR> consists of three types:

<DL>
<DT><STRONG><VAR>Atom</VAR></STRONG><DD>
Atoms are used to represent <CODE>CDATA</CODE>. Note this is possible in 
SWI-Prolog, as there is no length-limit on atoms and atom garbage 
collection is provided.
<DT><STRONG>element</STRONG>(<VAR>Name, ListAttributes, ListOfContent</VAR>)<DD>
<VAR>Name</VAR> is the name of the element. Using SGML, which is 
case-insensitive, all element names are returned as lowercase atoms.

<P><VAR>ListOfAttributes</VAR> is a list of <VAR>Name</VAR>=<VAR>Value</VAR> 
pairs for attributes that appeared in the source. No information is 
returned on other attributes, such as <CODE>fixed</CODE> or <CODE>default</CODE> 
attributes. See <A NAME="idx:dtdproperty2:7"></A><A HREF="#dtd_property/2">dtd_property/2</A> 
for accessing the DTD for this information. Attributes of type <CODE>CDATA</CODE> 
are returned literal. Attributes of type <CODE>NUMBER</CODE> are 
returned as a Prolog integer. Multi-valued attributes (<CODE>NAMES</CODE>, 
etc.) are returned as a list of atoms. For the type <CODE>NUMBERS</CODE>, 
a list of Prolog integers is returned for any element of the list that 
can be converted into an integer.

<P><VAR>ListOfContent</VAR> defines the content for the element.
<DT><STRONG>entity</STRONG>(<VAR>Code</VAR>)<DD>
If a character-entity (e.g. <CODE>&amp;#913;</CODE>) is encoutered that 
cannot be represented in the Prolog character set, this term is 
returned, representing the referred character code.
<DT><STRONG>entity</STRONG>(<VAR>Name</VAR>)<DD>
If an entity refers to a character-entity holding a single character, 
but this character cannot be represented in the Prolog character set, 
this term is returned. For example, the HTML input text
<CODE>&amp;Alpha; &amp;lt &amp;Beta;</CODE> is returned as below. Please 
note that neither in XML nor SGML entities are case-insensitive.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

[ entity('Alpha'), ' &lt; ', entity('Beta') ]
</PRE>
</TABLE>

<P>This is a special case of <CODE>entity(Code)</CODE>, intended to 
handle special symbols by their name rather then character code.
<DT><STRONG>sdata</STRONG>(<VAR>Text</VAR>)<DD>
If an entity width declared content-type <CODE>SDATA</CODE> is 
encountered, this term is returned holding the data in <VAR>Text</VAR>.
<DT><STRONG>ndata</STRONG>(<VAR>Text</VAR>)<DD>
If an entity width declared content-type <CODE>NDATA</CODE> is 
encountered, this term is returned holding the data in <VAR>Text</VAR>.
<DT><STRONG>pi</STRONG>(<VAR>Text</VAR>)<DD>
If a processing instruction is encoutered (<CODE>&lt;?...?&gt;</CODE>), <VAR>Text</VAR> 
holds the text of the processing instruction. Please note that the
<CODE>&lt;?xml ...?&gt;</CODE> instruction is handled internally.
</DL>

<P>The <VAR>Options</VAR> list controls the conversion process. 
Currently defined options are:

<DL>
<DT><STRONG>dtd</STRONG>(<VAR>?DTD</VAR>)<DD>
Reference to a DTD object. If specified, the <CODE>&lt;!DOCTYPE ...&gt;</CODE> 
declaration is ignored and the document is parsed and validated against 
the provided DTD. If provided as a variable, the implicitly created DTD 
is returned. See <A HREF="#sec:implicitdtd">section 3.5</A>.
<DT><STRONG>dialect</STRONG>(<VAR>+Dialect</VAR>)<DD>
Specify the parsing dialect. Supported are <CODE>sgml</CODE> (default),
<CODE>xml</CODE> and <CODE>xmlns</CODE>. See <A HREF="#sec:xml">section 
3.3</A> for details on the differences.
<DT><STRONG>space</STRONG>(<VAR>+SpaceMode</VAR>)<DD>
Sets the `space-handling-mode' for the initial environment. This mode is 
inherited by the other environments and subject to the XML reserved tag <TT>&lt;xml:space&gt;</TT>. 
See <A HREF="#sec:space">section 3.2</A>.
<DT><STRONG>file</STRONG>(<VAR>+Name</VAR>)<DD>
Sets the name of the file on which errors are reported. Sets the 
linenumber to 1.
<DT><STRONG>line</STRONG>(<VAR>+Line</VAR>)<DD>
Sets the starting line-number for reporting errors.
<DT><STRONG>max_errors</STRONG>(<VAR>+Max</VAR>)<DD>
Sets the maximum number of errors. If this number is reached, an 
exception of the format below is raised. The default is 50.
<BLOCKQUOTE>
<CODE>error(<CODE>limit_exceeded(max_errors, Max)</CODE>, _)</CODE>
</BLOCKQUOTE>
</DL>

</DL>

<H3><A NAME="sec:3.2">3.2 Handling white-space</A></H3>

<A NAME="sec:space"></A>

<P>SGPL2PL has four modes for handling white-space. The initial mode can 
be switched using the <CODE>space(SpaceMode)</CODE> option to <A NAME="idx:loadstructure3:8"></A><A HREF="#load_structure/3">load_structure/3</A> 
and <A NAME="idx:setsgmlparser2:9"></A><A HREF="#set_sgml_parser/2">set_sgml_parser/2</A>. 
In XML mode, the mode is further controlled by the <TT>&lt;xml:space&gt;</TT> 
attribute, which may be specified both in the DTD as in the document. 
The defined modes are:

<DL>
<DT><STRONG>space</STRONG>(<VAR>sgml</VAR>)<DD>
In SGML, newlines at the start and end of an element are removed.<A NAME=back-to-note-1 HREF="index.html#note-1"> (1)</A> 
This is the default mode for the SGML dialect.
<DT><STRONG>space</STRONG>(<VAR>preserve</VAR>)<DD>
White space is passed literally to the application. This is the default 
mode. This mode leaves all white space handling to the application. This 
is the default mode for the XML dialect.
<DT><STRONG>space</STRONG>(<VAR>default</VAR>)<DD>
In addition to <CODE>sgml</CODE> space-mode, all consequtive white-space 
is reduced to a single space-character. This mode canonises all white 
space.
<DT><STRONG>space</STRONG>(<VAR>remove</VAR>)<DD>
In addition to <CODE>default</CODE>, all leading and trailing 
white-space is removed from <CODE>CDATA</CODE> objects. If, as a result, 
if the
<CODE>CDATA</CODE> becomes empty, nothing is passed to the application. 
This mode is especially handy for processing `data-oriented' documents, 
such as RDF. It is not suitable for normal text documents. Consider the 
HTML statement below. When processed in this mode, the spaces between 
the three modified words are lost. This mode is, unlike the two others, 
not part of the XML standard.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

Consider adjecent &lt;b&gt;bold&lt;/b&gt; &lt;ul&gt;and&lt;/ul&gt; &lt;it&gt;italic&lt;/it&gt; words.
</PRE>
</TABLE>

<P>
</DL>

<H3><A NAME="sec:3.3">3.3 XML documents</A></H3>

<A NAME="sec:xml"></A>

<P>The parser can operate in two modes: <CODE>sgml</CODE> mode and <CODE>xml</CODE> 
mode, as defined by the <CODE>dialect(Dialect)</CODE> option. Regardless 
of this option, if the first line of the document reads as below, the 
parser is switched automatically into XML mode.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

&lt;?xml ... ?&gt;
</PRE>
</TABLE>

<P>Currently switching to XML mode implies:

<P>
<UL>
<LI><I>XML empty elements</I><BR>
The construct <CODE>&lt;element [attribute...] /&gt;</CODE> is 
recognised as an empty element.
<LI><I>Predefined entities</I><BR>
The following entitities are predefined:
<CODE>lt</CODE> (<CODE>&lt;</CODE>),
<CODE>gt</CODE> (<CODE>&gt;</CODE>),
<CODE>amp</CODE> (<CODE>&amp;</CODE>),
<CODE>apos</CODE> (<CODE>'</CODE>) and
<CODE>quot</CODE> (<CODE>"</CODE>).
<LI><I>Case sensitivity</I><BR>
In XML mode, names are treated case-sensitive, except for the DTD 
reserved names (i.e. <CODE>ELEMENT</CODE>, etc.).
<LI><I>Character classes</I><BR>
In XML mode, underscores (<CODE>_</CODE>) and colon (<CODE>:</CODE>) are 
allowed in names.
<LI><I>White-space handling</I><BR>
White space mode is set to <CODE>preserve</CODE>. In addition to setting 
white-space handling at the toplevel the XML reserved attribute
<TT>&lt;xml:space&gt;</TT> is honoured. It may appear both in the 
document as the DTD. The <CODE>remove</CODE> extension is honoured as <TT>&lt;xml:space&gt;</TT> 
value. For example, the DTD statement below ensures that the <TT>&lt;pre&gt;</TT> 
element preserves space, regardless of the default processing mode.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

&lt;!ATTLIST pre xml:space nmtoken #fixed preserve&gt;
</PRE>
</TABLE>

<P>
</UL>

<H4><A NAME="sec:3.3.1">3.3.1 XML Namespaces</A></H4>

<A NAME="sec:xmlns"></A>

<P>Using the <EM>dialect</EM> <CODE>xmlns</CODE>, the parser will 
interpret XML namespaces. In this case, the names of elements are 
returned as a term of the format
<BLOCKQUOTE>
<VAR>URL</VAR><CODE>:</CODE><VAR>LocalName</VAR>
</BLOCKQUOTE>

<P>If an identifier has no namespace and there is no default namespace 
it is returned as a simple atom. If an identifier has a namespace but 
this namespace is undeclared, the namespace name rather than the related 
URL is returned.

<P>Attributes declaring namespaces (<CODE>xmlns:<VAR>ns</VAR>=<VAR>url</VAR></CODE> 
are reported as if <CODE>xmlns</CODE> is not a defined resource.

<P>In many cases, getting attribute-names as <CODE><VAR>url</VAR>:<VAR>name</VAR></CODE> 
is not desirable. Such terms are hard to unified and sometimes multiple 
URLs may be mapped to the same identifier. This may happen due to poor 
version management, poor standardisation or because the the application 
doesn't care too much about versions. This package defines two 
call-backs that can be set using <A NAME="idx:setsgmlparser2:10"></A><A HREF="#set_sgml_parser/2">set_sgml_parser/2</A> 
to deal with this problem.

<P>the call-back <CODE>xmlns()</CODE> is called as XML namespaces are 
pushed on the environment. It can be used to extend a canonical mapping 
for later use by the <CODE>urlns()</CODE> call-back. The following 
illustrates this behaviour. Any namespace containing <CODE>rdf-syntax</CODE> 
in its URL or that is used as <CODE>rdf</CODE> namespace is canonised to <CODE>rdf</CODE>. 
This implies that any attribute and element name from the RDF namespace 
appears as <CODE>rdf:<VAR>name</VAR></CODE>.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

:- dynamic
        xmlns/3.

on_xmlns(rdf, URL, _Parser) :- !,
        asserta(xmlns(URL, rdf, _)).
on_xmlns(_, URL, _Parser) :-
        sub_atom(URL, _, _, _, rdf-syntax), !,
        asserta(xmlns(URL, rdf, _)).

load_rdf_xml(File, Term) :-
        load_structure(File, Term,
                       [ dialect(xmlns),
                         call(xmlns, on_xmlns),
                         call(urlns, xmlns)
                       ]).
</PRE>
</TABLE>

<H3><A NAME="sec:3.4">3.4 DTD-Handling</A></H3>

<P>The DTD (<B>D</B>ocument <B>T</B>ype <B>D</B>efinition) is a separate 
entity in sgml2pl, that can be created, freed, defined and inspected. 
Like the parser itself, it is filled by opening it it as a Prolog output 
stream and sending data to it. This section summarises the predicates 
for handling the DTD.

<DL>
<DT><A NAME="new_dtd/2"><STRONG>new_dtd</STRONG>(<VAR>+DocType, -DTD</VAR>)</A><DD>
Creates an empty DTD for the named <VAR>DocType</VAR>. The returned 
DTD-reference is an opaque term that can be used in the other predicates 
of this package.
<DT><A NAME="free_dtd/1"><STRONG>free_dtd</STRONG>(<VAR>+DTD</VAR>)</A><DD>
Deallocate all resources associated to the DTD. Further use of <VAR>DTD</VAR> 
is invalid.
<DT><A NAME="load_dtd/1"><STRONG>load_dtd</STRONG>(<VAR>+DTD, +File</VAR>)</A><DD>
Define the DTD by loading the SGML-DTD file <VAR>File</VAR>. This 
predicate is defined using the low-level <A NAME="idx:opendtd3:11"></A><A HREF="#open_dtd/3">open_dtd/3</A> 
predicate:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

load_dtd(DTD, DtdFile) :-
        open_dtd(DTD, [], DtdOut),
        open(DtdFile, read, DtdIn),
        copy_stream_data(DtdIn, DtdOut),
        close(DtdIn),
        close(DtdOut).
</PRE>
</TABLE>

<DT><A NAME="open_dtd/3"><STRONG>open_dtd</STRONG>(<VAR>+DTD, +Options, 
-OutStream</VAR>)</A><DD>
Open either a DTD as an output stream. The option-list is currently 
empty. See <A NAME="idx:loaddtd2:12"></A><B>load_dtd/2</B> for an 
example.
<DT><A NAME="dtd/2"><STRONG>dtd</STRONG>(<VAR>+DocType, -DTD</VAR>)</A><DD>
Find the DTD representing the indicated <EM>doctype</EM>. This predicate 
uses a cache of DTD objects. If a doctype has no associated dtd, it 
searches for a file using the file search path <CODE>dtd</CODE> using 
the call:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

...,
absolute_file_name(dtd(Type),
                   [ extensions([dtd]),
                     access(read)
                   ], DtdFile),
...
</PRE>
</TABLE>

<DT><A NAME="dtd_property/2"><STRONG>dtd_property</STRONG>(<VAR>+DTD, 
?Property</VAR>)</A><DD>
This predicate is used to examine the content of a DTD. Property is one 
of:

<DL>
<DT><STRONG>doctype</STRONG>(<VAR>DocType</VAR>)<DD>
An atom representing the document-type defined by this DTD.
<DT><STRONG>elements</STRONG>(<VAR>ListOfElements</VAR>)<DD>
A list of atoms representing the names of the elements in this DTD.
<DT><STRONG>element</STRONG>(<VAR>Name, Omit, Content</VAR>)<DD>
The DTD contains an element with the given name. <VAR>Omit</VAR> is a 
term of the format <CODE>omit(OmitOpen, OmitClose)</CODE>, where both 
arguments are booleans (<CODE>true</CODE> or <CODE>false</CODE> 
representing whether the open- or close-tag may be omitted. <VAR>Content</VAR> 
is the content-model of the element represented as a Prolog term. This 
term takes the following form:

<DL>
<DT><STRONG>empty</STRONG><DD>
The element has no content.
<DT><STRONG>cdata</STRONG><DD>
The element contains non-parsed character data
<DT><STRONG>'#pcdata'</STRONG><DD>
The element contains parsed character data
<DT><STRONG><VAR>element</VAR></STRONG><DD>
An element with this name.
<DT><STRONG>*</STRONG>(<VAR>SubModel</VAR>)<DD>
0 or more appearances.
<DT><STRONG>?</STRONG>(<VAR>SubModel</VAR>)<DD>
0 or one appearance.
<DT><STRONG>+</STRONG>(<VAR>SubModel</VAR>)<DD>
1 or more appearances.
<DT><STRONG>,</STRONG>(<VAR>SubModel1, SubModel2</VAR>)<DD>
<VAR>SubModel1</VAR> followed by <VAR>SubModel2</VAR>.
<DT><STRONG>&amp;</STRONG>(<VAR>SubModel1, SubModel2</VAR>)<DD>
<VAR>SubModel1</VAR> and <VAR>SubModel2</VAR> in any order.
<DT><STRONG><TT>|</TT></STRONG>(<VAR>SubModel1, SubModel2</VAR>)<DD>
<VAR>SubModel1</VAR> or <VAR>SubModel2</VAR>.
</DL>

<DT><STRONG>attributes</STRONG>(<VAR>Element, ListOfAttributes</VAR>)<DD>
<VAR>ListOfAttributes</VAR> is a list of atoms representing the 
attributes of the element <VAR>Element</VAR>.
<DT><STRONG>attribute</STRONG>(<VAR>Element, Attribute, Type, Default</VAR>)<DD>
Query an element. <VAR>Type</VAR> is one of <CODE>cdata</CODE>, <CODE>entity</CODE>,
<CODE>id</CODE>, <CODE>idref</CODE>, <CODE>name</CODE>, <CODE>nmtoken</CODE>,
<CODE>notation</CODE>, <CODE>number</CODE> or <CODE>nutoken</CODE>. For 
DTD types that allow for a list, the notation <CODE>list(Type)</CODE> is 
used. Finally, the DTD construct <CODE>(a|b|...)</CODE> is mapped to the 
term
<CODE>nameof(ListOfValues)</CODE>.
<DT><STRONG>entities</STRONG>(<VAR>ListOfEntities</VAR>)<DD>
<VAR>ListOfEntities</VAR> is a list of atoms representing the names of 
the defined entities.
<DT><STRONG>entity</STRONG>(<VAR>Name, Value</VAR>)<DD>
<VAR>Name</VAR> is the name of an entity with given value. Value is one 
of

<DL>
<DT><STRONG><VAR>Atom</VAR></STRONG><DD>
If the value is atomic, it represents the literal value of the entity.
<DT><STRONG>system</STRONG>(<VAR>Url</VAR>)<DD>
<VAR>Url</VAR> is the URL of the system external entity.
<DT><STRONG>public</STRONG>(<VAR>Id, Url</VAR>)<DD>
For external public entities, <VAR>Id</VAR> is the identifier. If an URL 
is provided this is returned in <VAR>Url</VAR>. Otherwise this argument 
is unbound.
</DL>

<DT><STRONG>notations</STRONG>(<VAR>ListOfNotations</VAR>)<DD>
Returns a list holding the names of all <CODE>NOTATION</CODE> 
declarations.
<DT><STRONG>notation</STRONG>(<VAR>Name, File</VAR>)<DD>
Yields the declared file for from a <CODE>NOTATION</CODE> declaration.
</DL>

</DL>

<H4><A NAME="sec:3.4.1">3.4.1 The DOCTYPE declaration</A></H4>

<P>As this parser allows for processing partial documents and process 
the DTD separately, the DOCTYPE declaration plays a special role.

<P>If a document has no DOCTYPE declaraction, the parser returns a list 
holding all elements and CDATA found. If the document has a DOCTYPE 
declaraction, the parser will open the element defined in the DOCTYPE as 
soon as the first real data is encountered.

<H3><A NAME="sec:3.5">3.5 Extracting a DTD</A></H3>

<A NAME="sec:implicitdtd"></A>

<P>Some documents have no DTD. One of the neat facilities of this 
library is that it builds a DTD while parsing a document with an
<EM>implicit</EM> DTD. The resulting DTD contains all elements 
encountered in the document. For each element the content model is a 
disjunction of elements and possibly <CODE>#PCDATA</CODE> that can be 
repeated. Thus, if in element <TT>&lt;x&gt;</TT> whe found element <TT>&lt;y&gt;</TT> 
and CDATA, the model is:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

&lt;!ELEMENT x - - (y|#PCDATA)*&gt;
</PRE>
</TABLE>

<P>Any encountered attribute is added to the attribute list with the 
type <CODE>CDATA</CODE> and default <CODE>#IMPLIED</CODE>.

<P>The example below extracts the elements used in an unknown XML 
document.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

elements_in_xml_document(File, Elements) :-
        load_structure(File, _,
                       [ dialect(xml),
                         dtd(DTD)
                       ]),
        dtd_property(DTD, elements(Elements)),
        free_dtd(DTD).
</PRE>
</TABLE>

<H3><A NAME="sec:3.6">3.6 Parsing Primitives</A></H3>

<DL>
<DT><A NAME="new_sgml_parser/2"><STRONG>new_sgml_parser</STRONG>(<VAR>-Parser, 
+Options</VAR>)</A><DD>
Creates a new parser. A parser can be used one or multiple times for 
parsing documents or parts thereof. It may be bound to a DTD or the DTD 
may be left implicit, in which case it is created from the document 
prologue or parsing is performed without a DTD. Options:

<DL>
<DT><STRONG>dtd</STRONG>(<VAR>?DTD</VAR>)<DD>
If specified with an initialised DTD, this DTD is used for parsing the 
document, regardless of the document prologue. If specified using as a 
variable, a reference to the created DTD is returned. This DTD may be 
created from the document prologue or build implicitely from the 
document's content.
</DL>

<DT><A NAME="free_sgml_parser/2"><STRONG>free_sgml_parser</STRONG>(<VAR>+Parser</VAR>)</A><DD>
Destroy all resources related to the parser. This does not destroy the 
DTD if the parser was created using the <CODE>dtd(DTD)</CODE> option.
<DT><A NAME="set_sgml_parser/2"><STRONG>set_sgml_parser</STRONG>(<VAR>+Parser, 
+Option</VAR>)</A><DD>
Sets attributes to the parser. Currently defined attributes:

<DL>
<DT><STRONG>file</STRONG>(<VAR>File</VAR>)<DD>
Sets the file for reporting errors and warnings. Sets the line to 1.
<DT><STRONG>line</STRONG>(<VAR>Line</VAR>)<DD>
Sets the current line. Useful if the stream is not at the start of the 
(file) object for generating proper line-numbers.
<DT><STRONG>dialect</STRONG>(<VAR>Dialect</VAR>)<DD>
Set the markup dialect. Known dialects:

<DL>
<DT><STRONG>sgml</STRONG><DD>
The default dialect is to process as SGML. This implies markup is 
case-insensitive and standard SGML abbreviation is allowed (abreviated 
attributes and omitted tags).
<DT><STRONG>xml</STRONG><DD>
This dialect is selected automatically if the processing instruction
<CODE>&lt;?xml ...&gt;</CODE> is encountered. See <A HREF="#sec:xml">section 
3.3</A> for details.
<DT><STRONG>xmlns</STRONG><DD>
Process file as XML file with namespace support. See <A HREF="#sec:xmlns">section 
3.3.1</A> for details.
</DL>

</DL>

<DT><A NAME="get_sgml_parser/2"><STRONG>get_sgml_parser</STRONG>(<VAR>+Parser, 
-Option</VAR>)</A><DD>
Retrieve infomation on the current status of the parser. Notably useful 
if the parser is used in the call-back mode. Currently defined options:

<DL>
<DT><STRONG>file</STRONG>(<VAR>-File</VAR>)<DD>
Current file-name. Note that this may be different from the provided 
file if an external entity is being loaded.
<DT><STRONG>charpos</STRONG>(<VAR>-CharPos</VAR>)<DD>
Offset from where the parser started its processing in the file-object. 
See <A HREF="#sec:indexaccess">section 4</A>.
<DT><STRONG>source</STRONG>(<VAR>-Stream</VAR>)<DD>
Prolog stream being processed. May be used in the <CODE>on_begin</CODE>, 
etc. callbacks from <A NAME="idx:sgmlparse2:13"></A><A HREF="#sgml_parse/2">sgml_parse/2</A>.
<DT><STRONG>dialect</STRONG>(<VAR>-Dialect</VAR>)<DD>
Return the current dialect used by the parser (<CODE>sgml</CODE>, <CODE>xml</CODE> 
or <CODE>xmlns</CODE>).
</DL>

<DT><A NAME="sgml_parse/2"><STRONG>sgml_parse</STRONG>(<VAR>+Parser, 
+Options</VAR>)</A><DD>
Parse an <I>X</I>ML file. The parser can operate in two input and two 
output modes. Output is either a structured term as described with
<A NAME="idx:loadstructure2:14"></A><B>load_structure/2</B> or 
call-backs on predefined events. The first is especially suitable for 
manipulating not-too-large documents, while the latter provides a 
primitive means for handling very large documents.

<P>Input is either a stream or an goal that pushes characters into the 
parser. A full description of the option-list is below.

<DL>
<DT><STRONG>document</STRONG>(<VAR>+Term</VAR>)<DD>
A variable that will be unified with a list describing the content of 
the document (see <A NAME="idx:loadstructure2:15"></A><B>load_structure/2</B>).
<DT><STRONG>source</STRONG>(<VAR>+Stream</VAR>)<DD>
An input stream that is read. Either this option or the
<CODE>goal(Goal)</CODE> option must be provided.
<DT><STRONG>goal</STRONG>(<VAR>+Goal</VAR>)<DD>
<VAR>Goal</VAR> is a callable term. The predicate <A NAME="idx:sgmlparse2:16"></A><A HREF="#sgml_parse/2">sgml_parse/2</A> 
opens an output stream to the parser and invokes <CODE>call(Goal, Stream)</CODE>, 
where <VAR>Goal</VAR> should write the data to be parsed to <VAR>Stream</VAR>. 
This option is not compatible to <CODE>parse(element)</CODE>. This 
option can be used for example to parse a Prolog atom:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

parse_atom(Atom, Term) :-
        new_sgml_parser(Parser, []),
        sgml_parse(Parser,
                   [ document(Term),
                     goal(provide_atom(Atom))
                   ]),
        free_sgml_parser(Parser).

provide_atom(Atom, ParserStream) :-
        write(ParserStream, Atom).
</PRE>
</TABLE>

<P>For example:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

?- parse_atom('&lt;h1&gt;hello world&lt;/h1&gt;', X).

X = [element(h1, [], ['hello world'])] 
</PRE>
</TABLE>

<DT><STRONG>parse</STRONG>(<VAR>Unit</VAR>)<DD>
If <CODE>file</CODE> (default), parse everything upto the end of the 
input. If <CODE>element</CODE>, the parser will stop after reading the 
first element. Using <CODE>source(Stream)</CODE>, this implies reading 
is stopped as soon as the element is complete, and another call may be 
issued on the same stream to read the next element. Using <CODE>goal(Goal)</CODE> 
as input, the stream reports an I/O error after completing the first 
element. This exception destroyes the built <CODE>dcoument(Term)</CODE>, 
making this option useless using `Goal' driven input. The value <CODE>content</CODE> 
may be used in a call-back from
<CODE>call(<CODE>on_begin</CODE>, Pred)</CODE> to parse individual 
elements after validating their headers.
<DT><STRONG>max_errors</STRONG>(<VAR>+MaxErrors</VAR>)<DD>
Set the maximum number of errors. If this number is exceeded further 
writes to the stream will yield an I/O error exception. Printing of 
errors is suppressed after reaching this value. The default is 100.
<DT><STRONG>call</STRONG>(<VAR>+Event, :PredicateName</VAR>)<DD>
Issue call-backs on the specified events. <VAR>PredicateName</VAR> is 
the name of the predicate to call on this event, possibly prefixed with 
a module identifier. The defined events are:

<DL>
<DT><STRONG>begin</STRONG><DD>
An open-tag has been parsed. The named handler is called with three 
arguments: <CODE><VAR>Handler</VAR>(+Tag, +Attributes, +Parser)</CODE>.
<DT><STRONG>end</STRONG><DD>
A close-tag has been parsed. The named handler is called with two 
arguments: <CODE><VAR>Handler</VAR>(+Tag, +Parser)</CODE>.
<DT><STRONG>cdata</STRONG><DD>
CDATA has been parsed. The named handler is called with two arguments: <CODE><VAR>Handler</VAR>(+CDATA, 
+Parser)</CODE>, where CDATA is an atom representing the data.
<DT><STRONG>entity</STRONG><DD>
An entity that cannot be represented as CDATA has been parsed. The named 
handler is called with two arguments:
<CODE><VAR>Handler</VAR>(+NameOrCode, +Parser)</CODE>.
<DT><STRONG>pi</STRONG><DD>
A processing instruction has been parsed. The named handler is called 
with two arguments: <CODE><VAR>Handler</VAR>(+Text, +Parser)</CODE>, 
where
<VAR>Text</VAR> is the text of the processing instruction.
<DT><STRONG>xmlns</STRONG><DD>
When parsing an in <CODE>xmlns</CODE> mode, a new namespace declaraction 
is pushed on the environment. The named handler is called with three 
arguments: <CODE><VAR>Handler</VAR>(+NameSpace, +URL, +Parser)</CODE>. 
See
<A HREF="#sec:xmlns">section 3.3.1</A> for details.
<DT><STRONG>urlns</STRONG><DD>
When parsing an in <CODE>xmlns</CODE> mode, this predicate can be used 
to map a url into either a canonical URL for this namespace or another 
internal identifier. See <A HREF="#sec:xmlns">section 3.3.1</A> for 
details.
</DL>

</DL>

</DL>

<H4><A NAME="sec:3.6.1">3.6.1 Partial Parsing</A></H4>

<P>In some cases, part of a document needs to be parsed. One option is 
to use <A NAME="idx:loadstructure2:17"></A><B>load_structure/2</B> or 
one of its variations and extract the desired elements from the returned 
structure. This is a clean solution, especially on small and 
medium-sized documents. It however is unsuitable for parsing really big 
documents. Such documents can only be handled with the call-back output 
interface realised by the
<CODE>call(Event, Action)</CODE> option of <A NAME="idx:sgmlparse2:18"></A><A HREF="#sgml_parse/2">sgml_parse/2</A>. 
Event-driven processing is not very natural in Prolog.

<P>The SGML2PL library allows for a mixed approach. Consider the case 
where we want to process all descriptions from RDF elements in a 
document. The code below calls <A NAME="idx:processrdfdescription1:19"></A><B>process_rdf_description/1</B> 
on any element that is directly inside an RDF element.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

:- dynamic
        in_rdf/0.

load_rdf(File) :-
        retractall(in_rdf),
        open(File, read, In),
        new_sgml_parser(Parser, []),
        set_sgml_parser(Parser, file(File)),
        set_sgml_parser(Parser, dialect(xml)),
        sgml_parse(Parser,
                   [ source(In),
                     call(begin, on_begin),
                     call(end, on_end)
                   ]),
        close(In).

on_end('RDF', _) :-
        retractall(in_rdf).

on_begin('RDF', _, _) :-
        assert(in_rdf).
on_begin(Tag, Attr, Parser) :-
        in_rdf, !,
        sgml_parse(Parser,
                   [ document(Content),
                     parse(content)
                   ]),
        process_rdf_description(element(Tag, Attr, Content)).
</PRE>
</TABLE>

<H2><A NAME="sec:4">4 Processing Indexed Files</A></H2>

<A NAME="sec:indexaccess"></A>

<P>In some cases applications which to process small portions of large 
SGML, XML or RDF files. For example, the <EM>OpenDirectory</EM> project 
by Netscape has produced a 90MB RDF file representing the main index. 
The parser described here can process this document as a unit, but 
loading takes 85 seconds on a Pentium-II 450 and the resulting term 
requires about 70MB global stack. One option is to process the entire 
document and output it as a Prolog fact-based of RDF tripplets, but in 
many cases this is undesirable. Another example is a large SGML file 
containing online documentation. The application normally wishes to 
provide only small portions at a time to the user. Loading the entire 
document into memory is then undesirable.

<P>Using the <CODE>parse(element)</CODE> option, we open a file, seek 
(using
<A NAME="idx:seek4:20"></A><B>seek/4</B>) to the position of the element 
and read the desired element.

<P>The index can be built using the call-back interface of
<A NAME="idx:sgmlparse2:21"></A><A HREF="#sgml_parse/2">sgml_parse/2</A>. 
For example, the following code makes an index of the <CODE>structure.rdf</CODE> 
file of the OpenDirectory projects:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

:- dynamic
        location/3.                     % Id, File, Offset

rdf_index(File) :-
        retractall(location(_,_)),
        open(File, read, In, [type(binary)]),
        new_sgml_parser(Parser, []),
        set_sgml_parser(Parser, file(File)),
        set_sgml_parser(Parser, dialect(xml)),
        sgml_parse(Parser,
                   [ source(In),
                     call(begin, index_on_begin)
                   ]),
        close(In).

index_on_begin(_Element, Attributes, Parser) :-
        memberchk('r:id'=Id, Attributes),
        get_sgml_parser(Parser, charpos(Offset)),
        get_sgml_parser(Parser, file(File)),
        assert(location(Id, File, Offset)).
</PRE>
</TABLE>

<P>The following code extracts the RDF element with required id:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

rdf_element(Id, Term) :-
        location(Id, File, Offset),
        load_structure(File, Term,
                       [ dialect(xml),
                         offset(Offset),
                         parse(element)
                       ]).
</PRE>
</TABLE>

<H2><A NAME="sec:5">5 External entities</A></H2>

<P>While processing an SGML document the document may refer to external 
data. This occurs in three places: external parameter entities, normal 
external entities and the <CODE>DOCTYPE</CODE> declaration. The current 
version of these tools deal rather primitively with external data. 
External entities can only be loaded from a file and the mapping between 
the entity names and the file is done using a <EM>catalog</EM> file in a 
format compatible to that used by James Clark's SP Parser.

<P>Catalog files can be specified using two primitives: the predicate
<A NAME="idx:sgmlregistercatalogfile2:22"></A><A HREF="#sgml_register_catalog_file/2">sgml_register_catalog_file/2</A> 
or the environment variable
<CODE>SGML_CATALOG_FILES</CODE> (compatible to the SP package).

<DL>
<DT><A NAME="sgml_register_catalog_file/2"><STRONG>sgml_register_catalog_file</STRONG>(<VAR>+File, 
+Location</VAR>)</A><DD>
Register the indicated <VAR>File</VAR> as a catalog file. <VAR>Location</VAR> 
is either <CODE>start</CODE> or <CODE>end</CODE> and defines whether the 
catalog is considered first or last. This predicate has no effect if <VAR>File</VAR> 
is already part of the catalog.

<P>If no files are registered using this predicate, the first query on 
the catalog examines <CODE>SGML_CATALOG_FILES</CODE> and fills the 
catalog with all files in this path.
</DL>

<P>Two types of lines are used by this package.
<BLOCKQUOTE>
<CODE>DOCTYPE</CODE> <VAR>doctype</VAR> <VAR>file</VAR><BR>
<CODE>PUBLIC</CODE> <CODE>"</CODE><VAR>Id</VAR><CODE>"</CODE> <VAR>file</VAR>
</BLOCKQUOTE>

<P>The specified <VAR>file</VAR> path is taken relative to the location 
of the catolog file. For the <CODE>DOCTYPE</CODE> declaraction, <CODE>sgml2pl</CODE> 
first makes an attempt to resolve the <CODE>SYSTEM</CODE> or <CODE>PUBLIC</CODE> 
identifier. If this fails it tries to resolve the <VAR>doctype</VAR> 
using the provided catalog files.

<P>In the future we will design a call-back mechanism for locating and 
processing external entities, so Prolog-based file-location and Prolog 
resources can be used to store external entities.

<H2><A NAME="sec:6">6 Missing functionality</A></H2>

<P>The current parser is rather limited. Though suitable to deal with 
many serious documents, it also fails a number of less-used features in 
SGML and XML. Known missing SGML features include

<P>
<UL>
<LI><I>NOTATION on entities</I><BR>
Though notation is fully parsed, notation attributes on external entity 
declarations are not handed to the user.
<LI><I>SHORTTAG</I><BR>
The SGML SHORTTAG syntax is only partially implemented. Currently,
<CODE>&lt;tag/content/</CODE> is a valid abbreviation for
<CODE>\bnfmeta{tag}content&lt;/tag&gt;</CODE>, which can also be written 
as
<CODE>\bnfmeta{tag}content&lt;/&gt;</CODE>.
<LI><I>SGML declaration</I><BR>
The `SGML declaration' is fixed, though most of the parameters are 
handled through indirections in the implementation.
</UL>

<P>In XML mode the parser recognises SGML constructs that are not 
allowed in XML. Also various extensions of XML over SGML are not yet 
realised.

<H2><A NAME="sec:7">7 Installation</A></H2>

<H3><A NAME="sec:7.1">7.1 Unix systems</A></H3>

<P>Installation on Unix system uses the commonly found <EM>configure</EM>,
<EM>make</EM> and <EM>make install</EM> sequence. SWI-Prolog should be 
installed before building this package. If SWI-Prolog is not installed 
as <B>pl</B>, the environment variable <CODE>PL</CODE> must be set to 
the name of the SWI-Prolog executable. Installation is now accomplished 
using:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

% ./configure
% make
% make install
</PRE>
</TABLE>

<P>This installs the foreign libraries in <CODE>$PLBASE/lib/$PLARCH</CODE> 
and the Prolog library files in <CODE>$PLBASE/library</CODE>, where
<CODE>$PLBASE</CODE> refers to the SWI-Prolog `home-directory'.

<H3><A NAME="sec:7.2">7.2 Acknowledgements</A></H3>

<P>The Prolog representation for parsed documents is based on the 
SWI-Prolog interface to SP by Anjo Anjewierden.

<P>Richard O'Keefe pointed out a number of mistakes in a earlier version 
of this parser.

<H1><A NAME="document-notes">Footnotes</A></H1>

<DL>
<DT><A NAME=note-1 HREF="index.html#back-to-note-1">note-1</A><DD>
In addition, newlines at the end of lines containing only markup should 
be deleted. This is not yet implemented.
</DL>

</BODY></HTML>